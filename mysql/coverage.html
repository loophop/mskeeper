
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitlab.papegames.com/fringe/mskeeper/mysql/auth.go (13.5%)</option>
				
				<option value="file1">gitlab.papegames.com/fringe/mskeeper/mysql/buffer.go (65.5%)</option>
				
				<option value="file2">gitlab.papegames.com/fringe/mskeeper/mysql/conncheck.go (68.4%)</option>
				
				<option value="file3">gitlab.papegames.com/fringe/mskeeper/mysql/connection.go (43.0%)</option>
				
				<option value="file4">gitlab.papegames.com/fringe/mskeeper/mysql/connector.go (49.2%)</option>
				
				<option value="file5">gitlab.papegames.com/fringe/mskeeper/mysql/driver.go (40.3%)</option>
				
				<option value="file6">gitlab.papegames.com/fringe/mskeeper/mysql/dsn.go (39.8%)</option>
				
				<option value="file7">gitlab.papegames.com/fringe/mskeeper/mysql/errors.go (0.0%)</option>
				
				<option value="file8">gitlab.papegames.com/fringe/mskeeper/mysql/fields.go (0.0%)</option>
				
				<option value="file9">gitlab.papegames.com/fringe/mskeeper/mysql/infile.go (0.0%)</option>
				
				<option value="file10">gitlab.papegames.com/fringe/mskeeper/mysql/nulltime.go (0.0%)</option>
				
				<option value="file11">gitlab.papegames.com/fringe/mskeeper/mysql/packets.go (51.6%)</option>
				
				<option value="file12">gitlab.papegames.com/fringe/mskeeper/mysql/result.go (50.0%)</option>
				
				<option value="file13">gitlab.papegames.com/fringe/mskeeper/mysql/rows.go (36.5%)</option>
				
				<option value="file14">gitlab.papegames.com/fringe/mskeeper/mysql/statement.go (42.9%)</option>
				
				<option value="file15">gitlab.papegames.com/fringe/mskeeper/mysql/transaction.go (40.0%)</option>
				
				<option value="file16">gitlab.papegames.com/fringe/mskeeper/mysql/utils.go (10.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2018 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/x509"
        "encoding/pem"
        "sync"
)

// server pub keys registry
var (
        serverPubKeyLock     sync.RWMutex
        serverPubKeyRegistry map[string]*rsa.PublicKey
)

// RegisterServerPubKey registers a server RSA public key which can be used to
// send data in a secure manner to the server without receiving the public key
// in a potentially insecure way from the server first.
// Registered keys can afterwards be used adding serverPubKey=&lt;name&gt; to the DSN.
//
// Note: The provided rsa.PublicKey instance is exclusively owned by the driver
// after registering it and may not be modified.
//
//  data, err := ioutil.ReadFile("mykey.pem")
//  if err != nil {
//          log.Fatal(err)
//  }
//
//  block, _ := pem.Decode(data)
//  if block == nil || block.Type != "PUBLIC KEY" {
//          log.Fatal("failed to decode PEM block containing public key")
//  }
//
//  pub, err := x509.ParsePKIXPublicKey(block.Bytes)
//  if err != nil {
//          log.Fatal(err)
//  }
//
//  if rsaPubKey, ok := pub.(*rsa.PublicKey); ok {
//          mysql.RegisterServerPubKey("mykey", rsaPubKey)
//  } else {
//          log.Fatal("not a RSA public key")
//  }
//
func RegisterServerPubKey(name string, pubKey *rsa.PublicKey) <span class="cov0" title="0">{
        serverPubKeyLock.Lock()
        if serverPubKeyRegistry == nil </span><span class="cov0" title="0">{
                serverPubKeyRegistry = make(map[string]*rsa.PublicKey)
        }</span>

        <span class="cov0" title="0">serverPubKeyRegistry[name] = pubKey
        serverPubKeyLock.Unlock()</span>
}

// DeregisterServerPubKey removes the public key registered with the given name.
func DeregisterServerPubKey(name string) <span class="cov0" title="0">{
        serverPubKeyLock.Lock()
        if serverPubKeyRegistry != nil </span><span class="cov0" title="0">{
                delete(serverPubKeyRegistry, name)
        }</span>
        <span class="cov0" title="0">serverPubKeyLock.Unlock()</span>
}

func getServerPubKey(name string) (pubKey *rsa.PublicKey) <span class="cov0" title="0">{
        serverPubKeyLock.RLock()
        if v, ok := serverPubKeyRegistry[name]; ok </span><span class="cov0" title="0">{
                pubKey = v
        }</span>
        <span class="cov0" title="0">serverPubKeyLock.RUnlock()
        return</span>
}

// Hash password using pre 4.1 (old password) method
// https://github.com/atcurtis/mariadb/blob/master/mysys/my_rnd.c
type myRnd struct {
        seed1, seed2 uint32
}

const myRndMaxVal = 0x3FFFFFFF

// Pseudo random number generator
func newMyRnd(seed1, seed2 uint32) *myRnd <span class="cov0" title="0">{
        return &amp;myRnd{
                seed1: seed1 % myRndMaxVal,
                seed2: seed2 % myRndMaxVal,
        }
}</span>

// Tested to be equivalent to MariaDB's floating point variant
// http://play.golang.org/p/QHvhd4qved
// http://play.golang.org/p/RG0q4ElWDx
func (r *myRnd) NextByte() byte <span class="cov0" title="0">{
        r.seed1 = (r.seed1*3 + r.seed2) % myRndMaxVal
        r.seed2 = (r.seed1 + r.seed2 + 33) % myRndMaxVal

        return byte(uint64(r.seed1) * 31 / myRndMaxVal)
}</span>

// Generate binary hash from byte string using insecure pre 4.1 method
func pwHash(password []byte) (result [2]uint32) <span class="cov0" title="0">{
        var add uint32 = 7
        var tmp uint32

        result[0] = 1345345333
        result[1] = 0x12345671

        for _, c := range password </span><span class="cov0" title="0">{
                // skip spaces and tabs in password
                if c == ' ' || c == '\t' </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">tmp = uint32(c)
                result[0] ^= (((result[0] &amp; 63) + add) * tmp) + (result[0] &lt;&lt; 8)
                result[1] += (result[1] &lt;&lt; 8) ^ result[0]
                add += tmp</span>
        }

        // Remove sign bit (1&lt;&lt;31)-1)
        <span class="cov0" title="0">result[0] &amp;= 0x7FFFFFFF
        result[1] &amp;= 0x7FFFFFFF

        return</span>
}

// Hash password using insecure pre 4.1 method
func scrambleOldPassword(scramble []byte, password string) []byte <span class="cov0" title="0">{
        if len(password) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">scramble = scramble[:8]

        hashPw := pwHash([]byte(password))
        hashSc := pwHash(scramble)

        r := newMyRnd(hashPw[0]^hashSc[0], hashPw[1]^hashSc[1])

        var out [8]byte
        for i := range out </span><span class="cov0" title="0">{
                out[i] = r.NextByte() + 64
        }</span>

        <span class="cov0" title="0">mask := r.NextByte()
        for i := range out </span><span class="cov0" title="0">{
                out[i] ^= mask
        }</span>

        <span class="cov0" title="0">return out[:]</span>
}

// Hash password using 4.1+ method (SHA1)
func scramblePassword(scramble []byte, password string) []byte <span class="cov8" title="1">{
        if len(password) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // stage1Hash = SHA1(password)
        <span class="cov8" title="1">crypt := sha1.New()
        _, _ = crypt.Write([]byte(password))
        stage1 := crypt.Sum(nil)

        // scrambleHash = SHA1(scramble + SHA1(stage1Hash))
        // inner Hash
        crypt.Reset()
        _, _ = crypt.Write(stage1)
        hash := crypt.Sum(nil)

        // outer Hash
        crypt.Reset()
        _, _ = crypt.Write(scramble)
        _, _ = crypt.Write(hash)
        scramble = crypt.Sum(nil)

        // token = scrambleHash XOR stage1Hash
        for i := range scramble </span><span class="cov8" title="1">{
                scramble[i] ^= stage1[i]
        }</span>
        <span class="cov8" title="1">return scramble</span>
}

// Hash password using MySQL 8+ method (SHA256)
func scrambleSHA256Password(scramble []byte, password string) []byte <span class="cov0" title="0">{
        if len(password) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // XOR(SHA256(password), SHA256(SHA256(SHA256(password)), scramble))

        <span class="cov0" title="0">crypt := sha256.New()
        _, _ = crypt.Write([]byte(password))
        message1 := crypt.Sum(nil)

        crypt.Reset()
        _, _ = crypt.Write(message1)
        message1Hash := crypt.Sum(nil)

        crypt.Reset()
        _, _ = crypt.Write(message1Hash)
        _, _ = crypt.Write(scramble)
        message2 := crypt.Sum(nil)

        for i := range message1 </span><span class="cov0" title="0">{
                message1[i] ^= message2[i]
        }</span>

        <span class="cov0" title="0">return message1</span>
}

func encryptPassword(password string, seed []byte, pub *rsa.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        plain := make([]byte, len(password)+1)
        copy(plain, password)
        for i := range plain </span><span class="cov0" title="0">{
                j := i % len(seed)
                plain[i] ^= seed[j]
        }</span>
        <span class="cov0" title="0">sha1 := sha1.New()
        return rsa.EncryptOAEP(sha1, rand.Reader, pub, plain, nil)</span>
}

func (mc *mysqlConn) sendEncryptedPassword(seed []byte, pub *rsa.PublicKey) error <span class="cov0" title="0">{
        enc, err := encryptPassword(mc.cfg.Passwd, seed, pub)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return mc.writeAuthSwitchPacket(enc)</span>
}

func (mc *mysqlConn) auth(authData []byte, plugin string) ([]byte, error) <span class="cov8" title="1">{
        switch plugin </span>{
        case "caching_sha2_password":<span class="cov0" title="0">
                authResp := scrambleSHA256Password(authData, mc.cfg.Passwd)
                return authResp, nil</span>

        case "mysql_old_password":<span class="cov0" title="0">
                if !mc.cfg.AllowOldPasswords </span><span class="cov0" title="0">{
                        return nil, ErrOldPassword
                }</span>
                // Note: there are edge cases where this should work but doesn't;
                // this is currently "wontfix":
                // https://github.com/go-sql-driver/mysql/issues/184
                <span class="cov0" title="0">authResp := append(scrambleOldPassword(authData[:8], mc.cfg.Passwd), 0)
                return authResp, nil</span>

        case "mysql_clear_password":<span class="cov0" title="0">
                if !mc.cfg.AllowCleartextPasswords </span><span class="cov0" title="0">{
                        return nil, ErrCleartextPassword
                }</span>
                // http://dev.mysql.com/doc/refman/5.7/en/cleartext-authentication-plugin.html
                // http://dev.mysql.com/doc/refman/5.7/en/pam-authentication-plugin.html
                <span class="cov0" title="0">return append([]byte(mc.cfg.Passwd), 0), nil</span>

        case "mysql_native_password":<span class="cov8" title="1">
                if !mc.cfg.AllowNativePasswords </span><span class="cov0" title="0">{
                        return nil, ErrNativePassword
                }</span>
                // https://dev.mysql.com/doc/internals/en/secure-password-authentication.html
                // Native password authentication only need and will need 20-byte challenge.
                <span class="cov8" title="1">authResp := scramblePassword(authData[:20], mc.cfg.Passwd)
                return authResp, nil</span>

        case "sha256_password":<span class="cov0" title="0">
                if len(mc.cfg.Passwd) == 0 </span><span class="cov0" title="0">{
                        return []byte{0}, nil
                }</span>
                <span class="cov0" title="0">if mc.cfg.tls != nil || mc.cfg.Net == "unix" </span><span class="cov0" title="0">{
                        // write cleartext auth packet
                        return append([]byte(mc.cfg.Passwd), 0), nil
                }</span>

                <span class="cov0" title="0">pubKey := mc.cfg.pubKey
                if pubKey == nil </span><span class="cov0" title="0">{
                        // request public key from server
                        return []byte{1}, nil
                }</span>

                // encrypted password
                <span class="cov0" title="0">enc, err := encryptPassword(mc.cfg.Passwd, authData, pubKey)
                return enc, err</span>

        default:<span class="cov0" title="0">
                errLog.Print("unknown auth plugin:", plugin)
                return nil, ErrUnknownPlugin</span>
        }
}

func (mc *mysqlConn) handleAuthResult(oldAuthData []byte, plugin string) error <span class="cov8" title="1">{
        // Read Result Packet
        authData, newPlugin, err := mc.readAuthResult()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // handle auth plugin switch, if requested
        <span class="cov8" title="1">if newPlugin != "" </span><span class="cov0" title="0">{
                // If CLIENT_PLUGIN_AUTH capability is not supported, no new cipher is
                // sent and we have to keep using the cipher sent in the init packet.
                if authData == nil </span><span class="cov0" title="0">{
                        authData = oldAuthData
                }</span> else<span class="cov0" title="0"> {
                        // copy data from read buffer to owned slice
                        copy(oldAuthData, authData)
                }</span>

                <span class="cov0" title="0">plugin = newPlugin

                authResp, err := mc.auth(authData, plugin)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err = mc.writeAuthSwitchPacket(authResp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Read Result Packet
                <span class="cov0" title="0">authData, newPlugin, err = mc.readAuthResult()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Do not allow to change the auth plugin more than once
                <span class="cov0" title="0">if newPlugin != "" </span><span class="cov0" title="0">{
                        return ErrMalformPkt
                }</span>
        }

        <span class="cov8" title="1">switch plugin </span>{

        // https://insidemysql.com/preparing-your-community-connector-for-mysql-8-part-2-sha256/
        case "caching_sha2_password":<span class="cov0" title="0">
                switch len(authData) </span>{
                case 0:<span class="cov0" title="0">
                        return nil</span> // auth successful
                case 1:<span class="cov0" title="0">
                        switch authData[0] </span>{
                        case cachingSha2PasswordFastAuthSuccess:<span class="cov0" title="0">
                                if err = mc.readResultOK(); err == nil </span><span class="cov0" title="0">{
                                        return nil // auth successful
                                }</span>

                        case cachingSha2PasswordPerformFullAuthentication:<span class="cov0" title="0">
                                if mc.cfg.tls != nil || mc.cfg.Net == "unix" </span><span class="cov0" title="0">{
                                        // write cleartext auth packet
                                        err = mc.writeAuthSwitchPacket(append([]byte(mc.cfg.Passwd), 0))
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        pubKey := mc.cfg.pubKey
                                        if pubKey == nil </span><span class="cov0" title="0">{
                                                // request public key from server
                                                data, err := mc.buf.takeSmallBuffer(4 + 1)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov0" title="0">data[4] = cachingSha2PasswordRequestPublicKey
                                                _ = mc.writePacket(data)

                                                // parse public key
                                                if data, err = mc.readPacket(); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>

                                                <span class="cov0" title="0">block, _ := pem.Decode(data[1:])
                                                pkix, err := x509.ParsePKIXPublicKey(block.Bytes)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov0" title="0">pubKey = pkix.(*rsa.PublicKey)</span>
                                        }

                                        // send encrypted password
                                        <span class="cov0" title="0">err = mc.sendEncryptedPassword(oldAuthData, pubKey)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                                <span class="cov0" title="0">return mc.readResultOK()</span>

                        default:<span class="cov0" title="0">
                                return ErrMalformPkt</span>
                        }
                default:<span class="cov0" title="0">
                        return ErrMalformPkt</span>
                }

        case "sha256_password":<span class="cov0" title="0">
                switch len(authData) </span>{
                case 0:<span class="cov0" title="0">
                        return nil</span> // auth successful
                default:<span class="cov0" title="0">
                        block, _ := pem.Decode(authData)
                        pub, err := x509.ParsePKIXPublicKey(block.Bytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // send encrypted password
                        <span class="cov0" title="0">err = mc.sendEncryptedPassword(oldAuthData, pub.(*rsa.PublicKey))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return mc.readResultOK()</span>
                }

        default:<span class="cov8" title="1">
                return nil</span> // auth successful
        }

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "io"
        "net"
        "time"
)

const defaultBufSize = 4096
const maxCachedBufSize = 256 * 1024

// A buffer which is used for both reading and writing.
// This is possible since communication on each connection is synchronous.
// In other words, we can't write and read simultaneously on the same connection.
// The buffer is similar to bufio.Reader / Writer but zero-copy-ish
// Also highly optimized for this particular use case.
// This buffer is backed by two byte slices in a double-buffering scheme
type buffer struct {
        buf     []byte // buf is a byte buffer who's length and capacity are equal.
        nc      net.Conn
        idx     int
        length  int
        timeout time.Duration
        dbuf    [2][]byte // dbuf is an array with the two byte slices that back this buffer
        flipcnt uint      // flipccnt is the current buffer counter for double-buffering
}

// newBuffer allocates and returns a new buffer.
func newBuffer(nc net.Conn) buffer <span class="cov8" title="1">{
        fg := make([]byte, defaultBufSize)
        return buffer{
                buf:  fg,
                nc:   nc,
                dbuf: [2][]byte{fg, nil},
        }
}</span>

// flip replaces the active buffer with the background buffer
// this is a delayed flip that simply increases the buffer counter;
// the actual flip will be performed the next time we call `buffer.fill`
func (b *buffer) flip() <span class="cov8" title="1">{
        b.flipcnt += 1
}</span>

// fill reads into the buffer until at least _need_ bytes are in it
func (b *buffer) fill(need int) error <span class="cov8" title="1">{
        n := b.length
        // fill data into its double-buffering target: if we've called
        // flip on this buffer, we'll be copying to the background buffer,
        // and then filling it with network data; otherwise we'll just move
        // the contents of the current buffer to the front before filling it
        dest := b.dbuf[b.flipcnt&amp;1]

        // grow buffer if necessary to fit the whole packet.
        if need &gt; len(dest) </span><span class="cov8" title="1">{
                // Round up to the next multiple of the default size
                dest = make([]byte, ((need/defaultBufSize)+1)*defaultBufSize)

                // if the allocated buffer is not too large, move it to backing storage
                // to prevent extra allocations on applications that perform large reads
                if len(dest) &lt;= maxCachedBufSize </span><span class="cov8" title="1">{
                        b.dbuf[b.flipcnt&amp;1] = dest
                }</span>
        }

        // if we're filling the fg buffer, move the existing data to the start of it.
        // if we're filling the bg buffer, copy over the data
        <span class="cov8" title="1">if n &gt; 0 </span><span class="cov8" title="1">{
                copy(dest[:n], b.buf[b.idx:])
        }</span>

        <span class="cov8" title="1">b.buf = dest
        b.idx = 0

        for </span><span class="cov8" title="1">{
                if b.timeout &gt; 0 </span><span class="cov0" title="0">{
                        if err := b.nc.SetReadDeadline(time.Now().Add(b.timeout)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">nn, err := b.nc.Read(b.buf[n:])
                n += nn

                switch err </span>{
                case nil:<span class="cov8" title="1">
                        if n &lt; need </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">b.length = n
                        return nil</span>

                case io.EOF:<span class="cov0" title="0">
                        if n &gt;= need </span><span class="cov0" title="0">{
                                b.length = n
                                return nil
                        }</span>
                        <span class="cov0" title="0">return io.ErrUnexpectedEOF</span>

                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
}

// returns next N bytes from buffer.
// The returned slice is only guaranteed to be valid until the next read
func (b *buffer) readNext(need int) ([]byte, error) <span class="cov8" title="1">{
        if b.length &lt; need </span><span class="cov8" title="1">{
                // refill
                if err := b.fill(need); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">offset := b.idx
        b.idx += need
        b.length -= need
        return b.buf[offset:b.idx], nil</span>
}

// takeBuffer returns a buffer with the requested size.
// If possible, a slice from the existing buffer is returned.
// Otherwise a bigger buffer is made.
// Only one buffer (total) can be used at a time.
func (b *buffer) takeBuffer(length int) ([]byte, error) <span class="cov8" title="1">{
        if b.length &gt; 0 </span><span class="cov8" title="1">{
                return nil, ErrBusyBuffer
        }</span>

        // test (cheap) general case first
        <span class="cov8" title="1">if length &lt;= cap(b.buf) </span><span class="cov8" title="1">{
                return b.buf[:length], nil
        }</span>

        <span class="cov0" title="0">if length &lt; maxPacketSize </span><span class="cov0" title="0">{
                b.buf = make([]byte, length)
                return b.buf, nil
        }</span>

        // buffer is larger than we want to store.
        <span class="cov0" title="0">return make([]byte, length), nil</span>
}

// takeSmallBuffer is shortcut which can be used if length is
// known to be smaller than defaultBufSize.
// Only one buffer (total) can be used at a time.
func (b *buffer) takeSmallBuffer(length int) ([]byte, error) <span class="cov8" title="1">{
        if b.length &gt; 0 </span><span class="cov8" title="1">{
                return nil, ErrBusyBuffer
        }</span>
        <span class="cov8" title="1">return b.buf[:length], nil</span>
}

// takeCompleteBuffer returns the complete existing buffer.
// This can be used if the necessary buffer size is unknown.
// cap and len of the returned buffer will be equal.
// Only one buffer (total) can be used at a time.
func (b *buffer) takeCompleteBuffer() ([]byte, error) <span class="cov8" title="1">{
        if b.length &gt; 0 </span><span class="cov0" title="0">{
                return nil, ErrBusyBuffer
        }</span>
        <span class="cov8" title="1">return b.buf, nil</span>
}

// store stores buf, an updated buffer, if its suitable to do so.
func (b *buffer) store(buf []byte) error <span class="cov0" title="0">{
        if b.length &gt; 0 </span><span class="cov0" title="0">{
                return ErrBusyBuffer
        }</span> else<span class="cov0" title="0"> if cap(buf) &lt;= maxPacketSize &amp;&amp; cap(buf) &gt; cap(b.buf) </span><span class="cov0" title="0">{
                b.buf = buf[:cap(buf)]
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2019 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

// +build linux darwin dragonfly freebsd netbsd openbsd solaris illumos

package mysql

import (
        "errors"
        "io"
        "net"
        "syscall"
)

var errUnexpectedRead = errors.New("unexpected read from socket")

func connCheck(conn net.Conn) error <span class="cov8" title="1">{
        var sysErr error

        sysConn, ok := conn.(syscall.Conn)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">rawConn, err := sysConn.SyscallConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = rawConn.Read(func(fd uintptr) bool </span><span class="cov8" title="1">{
                var buf [1]byte
                n, err := syscall.Read(int(fd), buf[:])
                switch </span>{
                case n == 0 &amp;&amp; err == nil:<span class="cov0" title="0">
                        sysErr = io.EOF</span>
                case n &gt; 0:<span class="cov0" title="0">
                        sysErr = errUnexpectedRead</span>
                case err == syscall.EAGAIN || err == syscall.EWOULDBLOCK:<span class="cov8" title="1">
                        sysErr = nil</span>
                default:<span class="cov0" title="0">
                        sysErr = err</span>
                }
                <span class="cov8" title="1">return true</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return sysErr</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "context"
        "database/sql"
        "database/sql/driver"
        "encoding/json"
        "io"
        // syslog "log"
        "net"
        "strconv"
        "strings"
        "time"
)

type mysqlConn struct {
        buf              buffer
        netConn          net.Conn
        rawConn          net.Conn // underlying connection when netConn is TLS connection.
        affectedRows     uint64
        insertId         uint64
        cfg              *Config
        maxAllowedPacket int
        maxWriteSize     int
        writeTimeout     time.Duration
        flags            clientFlag
        status           statusFlag
        sequence         uint8
        parseTime        bool
        reset            bool // set when the Go SQL package calls ResetSession

        // for mskeeper
        connector *connector

        // for context support (Go 1.8+)
        watching bool
        watcher  chan&lt;- context.Context
        closech  chan struct{}
        finished chan&lt;- struct{}
        canceled atomicError // set non-nil if conn is canceled
        closed   atomicBool  // set when conn is closed, before closech is closed
}

// Handles parameters set in DSN after the connection is established
func (mc *mysqlConn) handleParams() (err error) <span class="cov8" title="1">{
        for param, val := range mc.cfg.Params </span><span class="cov0" title="0">{
                switch param </span>{
                // Charset
                case "charset":<span class="cov0" title="0">
                        charsets := strings.Split(val, ",")
                        for i := range charsets </span><span class="cov0" title="0">{
                                // ignore errors here - a charset may not exist
                                err = mc.exec("SET NAMES " + charsets[i])
                                if err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                // System Vars
                default:<span class="cov0" title="0">
                        err = mc.exec("SET " + param + "=" + val + "")
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

func (mc *mysqlConn) markBadConn(err error) error <span class="cov8" title="1">{
        if mc == nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err != errBadConnNoWrite </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return driver.ErrBadConn</span>
}

func (mc *mysqlConn) Begin() (driver.Tx, error) <span class="cov0" title="0">{
        return mc.begin(false)
}</span>

func (mc *mysqlConn) begin(readOnly bool) (driver.Tx, error) <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">var q string
        if readOnly </span><span class="cov0" title="0">{
                q = "START TRANSACTION READ ONLY"
        }</span> else<span class="cov8" title="1"> {
                q = "START TRANSACTION"
        }</span>
        <span class="cov8" title="1">err := mc.exec(q)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;mysqlTx{mc}, err
        }</span>
        <span class="cov0" title="0">return nil, mc.markBadConn(err)</span>
}

func (mc *mysqlConn) Close() (err error) <span class="cov8" title="1">{
        // Makes Close idempotent
        if !mc.closed.IsSet() </span><span class="cov8" title="1">{
                err = mc.writeCommandPacket(comQuit)
        }</span>

        <span class="cov8" title="1">mc.cleanup()

        return</span>
}

// Closes the network connection and unsets internal variables. Do not call this
// function after successfully authentication, call Close instead. This function
// is called before auth or on auth failure because MySQL will have already
// closed the network connection.
func (mc *mysqlConn) cleanup() <span class="cov8" title="1">{
        if !mc.closed.TrySet(true) </span><span class="cov0" title="0">{
                return
        }</span>

        // Makes cleanup idempotent
        <span class="cov8" title="1">close(mc.closech)
        if mc.netConn == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err := mc.netConn.Close(); err != nil </span><span class="cov0" title="0">{
                errLog.Print(err)
        }</span>
}

func (mc *mysqlConn) error() error <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                if err := mc.canceled.Value(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return ErrInvalidConn</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (mc *mysqlConn) Prepare(query string) (driver.Stmt, error) <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>
        // Send command
        <span class="cov8" title="1">err := mc.writeCommandPacketStr(comStmtPrepare, query)
        if err != nil </span><span class="cov0" title="0">{
                // STMT_PREPARE is safe to retry.  So we can return ErrBadConn here.
                errLog.Print(err)
                return nil, driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">stmt := &amp;mysqlStmt{
                mc:          mc,
                sqlPrepared: query,
        }

        // Read Result
        columnCount, err := stmt.readPrepareResultPacket()
        if err == nil </span><span class="cov8" title="1">{
                if stmt.paramCount &gt; 0 </span><span class="cov8" title="1">{
                        if err = mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">if columnCount &gt; 0 </span><span class="cov8" title="1">{
                        err = mc.readUntilEOF()
                }</span>
        }

        <span class="cov8" title="1">return stmt, err</span>
}

func (mc *mysqlConn) interpolateParams(query string, args []driver.Value) (string, error) <span class="cov0" title="0">{
        // Number of ? should be same to len(args)
        if strings.Count(query, "?") != len(args) </span><span class="cov0" title="0">{
                return "", driver.ErrSkip
        }</span>

        <span class="cov0" title="0">buf, err := mc.buf.takeCompleteBuffer()
        if err != nil </span><span class="cov0" title="0">{
                // can not take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return "", ErrInvalidConn
        }</span>
        <span class="cov0" title="0">buf = buf[:0]
        argPos := 0

        for i := 0; i &lt; len(query); i++ </span><span class="cov0" title="0">{
                q := strings.IndexByte(query[i:], '?')
                if q == -1 </span><span class="cov0" title="0">{
                        buf = append(buf, query[i:]...)
                        break</span>
                }
                <span class="cov0" title="0">buf = append(buf, query[i:i+q]...)
                i += q

                arg := args[argPos]
                argPos++

                if arg == nil </span><span class="cov0" title="0">{
                        buf = append(buf, "NULL"...)
                        continue</span>
                }

                <span class="cov0" title="0">switch v := arg.(type) </span>{
                case int64:<span class="cov0" title="0">
                        buf = strconv.AppendInt(buf, v, 10)</span>
                case uint64:<span class="cov0" title="0">
                        // Handle uint64 explicitly because our custom ConvertValue emits unsigned values
                        buf = strconv.AppendUint(buf, v, 10)</span>
                case float64:<span class="cov0" title="0">
                        buf = strconv.AppendFloat(buf, v, 'g', -1, 64)</span>
                case bool:<span class="cov0" title="0">
                        if v </span><span class="cov0" title="0">{
                                buf = append(buf, '1')
                        }</span> else<span class="cov0" title="0"> {
                                buf = append(buf, '0')
                        }</span>
                case time.Time:<span class="cov0" title="0">
                        if v.IsZero() </span><span class="cov0" title="0">{
                                buf = append(buf, "'0000-00-00'"...)
                        }</span> else<span class="cov0" title="0"> {
                                v := v.In(mc.cfg.Loc)
                                v = v.Add(time.Nanosecond * 500) // To round under microsecond
                                year := v.Year()
                                year100 := year / 100
                                year1 := year % 100
                                month := v.Month()
                                day := v.Day()
                                hour := v.Hour()
                                minute := v.Minute()
                                second := v.Second()
                                micro := v.Nanosecond() / 1000

                                buf = append(buf, []byte{
                                        '\'',
                                        digits10[year100], digits01[year100],
                                        digits10[year1], digits01[year1],
                                        '-',
                                        digits10[month], digits01[month],
                                        '-',
                                        digits10[day], digits01[day],
                                        ' ',
                                        digits10[hour], digits01[hour],
                                        ':',
                                        digits10[minute], digits01[minute],
                                        ':',
                                        digits10[second], digits01[second],
                                }...)

                                if micro != 0 </span><span class="cov0" title="0">{
                                        micro10000 := micro / 10000
                                        micro100 := micro / 100 % 100
                                        micro1 := micro % 100
                                        buf = append(buf, []byte{
                                                '.',
                                                digits10[micro10000], digits01[micro10000],
                                                digits10[micro100], digits01[micro100],
                                                digits10[micro1], digits01[micro1],
                                        }...)
                                }</span>
                                <span class="cov0" title="0">buf = append(buf, '\'')</span>
                        }
                case json.RawMessage:<span class="cov0" title="0">
                        buf = append(buf, '\'')
                        if mc.status&amp;statusNoBackslashEscapes == 0 </span><span class="cov0" title="0">{
                                buf = escapeBytesBackslash(buf, v)
                        }</span> else<span class="cov0" title="0"> {
                                buf = escapeBytesQuotes(buf, v)
                        }</span>
                        <span class="cov0" title="0">buf = append(buf, '\'')</span>
                case []byte:<span class="cov0" title="0">
                        if v == nil </span><span class="cov0" title="0">{
                                buf = append(buf, "NULL"...)
                        }</span> else<span class="cov0" title="0"> {
                                buf = append(buf, "_binary'"...)
                                if mc.status&amp;statusNoBackslashEscapes == 0 </span><span class="cov0" title="0">{
                                        buf = escapeBytesBackslash(buf, v)
                                }</span> else<span class="cov0" title="0"> {
                                        buf = escapeBytesQuotes(buf, v)
                                }</span>
                                <span class="cov0" title="0">buf = append(buf, '\'')</span>
                        }
                case string:<span class="cov0" title="0">
                        buf = append(buf, '\'')
                        if mc.status&amp;statusNoBackslashEscapes == 0 </span><span class="cov0" title="0">{
                                buf = escapeStringBackslash(buf, v)
                        }</span> else<span class="cov0" title="0"> {
                                buf = escapeStringQuotes(buf, v)
                        }</span>
                        <span class="cov0" title="0">buf = append(buf, '\'')</span>
                default:<span class="cov0" title="0">
                        return "", driver.ErrSkip</span>
                }

                <span class="cov0" title="0">if len(buf)+4 &gt; mc.maxAllowedPacket </span><span class="cov0" title="0">{
                        return "", driver.ErrSkip
                }</span>
        }
        <span class="cov0" title="0">if argPos != len(args) </span><span class="cov0" title="0">{
                return "", driver.ErrSkip
        }</span>
        <span class="cov0" title="0">return string(buf), nil</span>
}

func (mc *mysqlConn) Exec(query string, args []driver.Value) (driver.Result, error) <span class="cov8" title="1">{
        ts := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if mc.connector != nil </span><span class="cov8" title="1">{
                        mc.connector.msk.AfterProcess(ts, query, args)
                }</span>
        }()
        <span class="cov8" title="1">if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">if len(args) != 0 </span><span class="cov8" title="1">{
                if !mc.cfg.InterpolateParams </span><span class="cov8" title="1">{
                        return nil, driver.ErrSkip
                }</span>
                // try to interpolate the parameters to save extra roundtrips for preparing and closing a statement
                <span class="cov0" title="0">prepared, err := mc.interpolateParams(query, args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">query = prepared</span>
        }
        <span class="cov8" title="1">mc.affectedRows = 0
        mc.insertId = 0

        err := mc.exec(query)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;mysqlResult{
                        affectedRows: int64(mc.affectedRows),
                        insertId:     int64(mc.insertId),
                }, err
        }</span>
        <span class="cov0" title="0">return nil, mc.markBadConn(err)</span>
}

// Internal function to execute commands
func (mc *mysqlConn) exec(query string) error <span class="cov8" title="1">{
        // log.Printf("mysqlConn:exec %v", query)
        // Send command
        if err := mc.writeCommandPacketStr(comQuery, query); err != nil </span><span class="cov8" title="1">{
                return mc.markBadConn(err)
        }</span>

        // Read Result
        <span class="cov8" title="1">resLen, err := mc.readResultSetHeaderPacket()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if resLen &gt; 0 </span><span class="cov0" title="0">{
                // columns
                if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // rows
                <span class="cov0" title="0">if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return mc.discardResults()</span>
}

func (mc *mysqlConn) Query(query string, args []driver.Value) (driver.Rows, error, int) <span class="cov0" title="0">{
        return mc.query(query, args)
}</span>

func (mc *mysqlConn) query(query string, args []driver.Value) (*textRows, error, int) <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn, 1
        }</span>
        <span class="cov8" title="1">ts := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if mc.connector != nil </span><span class="cov8" title="1">{
                        mc.connector.msk.AfterProcess(ts, query, args)
                }</span>
        }()
        <span class="cov8" title="1">if len(args) != 0 </span><span class="cov8" title="1">{
                if !mc.cfg.InterpolateParams </span><span class="cov8" title="1">{
                        return nil, driver.ErrSkip, 1
                }</span>
                // try client-side prepare to reduce roundtrip
                <span class="cov0" title="0">prepared, err := mc.interpolateParams(query, args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err, 1
                }</span>
                <span class="cov0" title="0">query = prepared</span>
        }
        // Send command
        <span class="cov8" title="1">err := mc.writeCommandPacketStr(comQuery, query)
        if err == nil </span><span class="cov8" title="1">{
                // Read Result
                var resLen int
                resLen, err = mc.readResultSetHeaderPacket()
                if err == nil </span><span class="cov8" title="1">{
                        rows := new(textRows)
                        rows.mc = mc

                        if resLen == 0 </span><span class="cov0" title="0">{
                                rows.rs.done = true

                                switch err := rows.NextResultSet(); err </span>{
                                case nil, io.EOF:<span class="cov0" title="0">
                                        return rows, nil, 1</span>
                                default:<span class="cov0" title="0">
                                        return nil, err, 1</span>
                                }
                        }

                        // Columns
                        <span class="cov8" title="1">rows.rs.columns, err = mc.readColumns(resLen)
                        return rows, err, 1</span>
                }
        }
        <span class="cov0" title="0">return nil, mc.markBadConn(err), 1</span>
}

// Gets the value of the given MySQL System Variable
// The returned byte slice is only valid until the next read
func (mc *mysqlConn) getSystemVar(name string) ([]byte, error) <span class="cov0" title="0">{
        // Send command
        if err := mc.writeCommandPacketStr(comQuery, "SELECT @@"+name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read Result
        <span class="cov0" title="0">resLen, err := mc.readResultSetHeaderPacket()
        if err == nil </span><span class="cov0" title="0">{
                rows := new(textRows)
                rows.mc = mc
                rows.rs.columns = []mysqlField{{fieldType: fieldTypeVarChar}}

                if resLen &gt; 0 </span><span class="cov0" title="0">{
                        // Columns
                        if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">dest := make([]driver.Value, resLen)
                if err = rows.readRow(dest); err == nil </span><span class="cov0" title="0">{
                        return dest[0].([]byte), mc.readUntilEOF()
                }</span>
        }
        <span class="cov0" title="0">return nil, err</span>
}

// finish is called when the query has canceled.
func (mc *mysqlConn) cancel(err error) <span class="cov0" title="0">{
        mc.canceled.Set(err)
        mc.cleanup()
}</span>

// finish is called when the query has succeeded.
func (mc *mysqlConn) finish() <span class="cov8" title="1">{
        if !mc.watching || mc.finished == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">select </span>{
        case mc.finished &lt;- struct{}{}:<span class="cov8" title="1">
                mc.watching = false</span>
        case &lt;-mc.closech:<span class="cov0" title="0"></span>
        }
}

// Ping implements driver.Pinger interface
func (mc *mysqlConn) Ping(ctx context.Context) (err error) <span class="cov0" title="0">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return driver.ErrBadConn
        }</span>

        <span class="cov0" title="0">if err = mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer mc.finish()

        if err = mc.writeCommandPacket(comPing); err != nil </span><span class="cov0" title="0">{
                return mc.markBadConn(err)
        }</span>

        <span class="cov0" title="0">return mc.readResultOK()</span>
}

// BeginTx implements driver.ConnBeginTx interface
func (mc *mysqlConn) BeginTx(ctx context.Context, opts driver.TxOptions) (driver.Tx, error) <span class="cov8" title="1">{
        if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer mc.finish()

        if sql.IsolationLevel(opts.Isolation) != sql.LevelDefault </span><span class="cov0" title="0">{
                level, err := mapIsolationLevel(opts.Isolation)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = mc.exec("SET TRANSACTION ISOLATION LEVEL " + level)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return mc.begin(opts.ReadOnly)</span>
}

func (mc *mysqlConn) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) <span class="cov8" title="1">{

        dargs, err := namedValueToValue(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err, _ := mc.query(query, dargs)
        if err != nil </span><span class="cov8" title="1">{
                mc.finish()
                return nil, err
        }</span>
        <span class="cov8" title="1">rows.finish = mc.finish

        return rows, err</span>
}

func (mc *mysqlConn) ExecContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) <span class="cov8" title="1">{
        dargs, err := namedValueToValue(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer mc.finish()

        return mc.Exec(query, dargs)</span>
}

func (mc *mysqlConn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) <span class="cov8" title="1">{
        if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stmt, err := mc.Prepare(query)
        mc.finish()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">select </span>{
        default:<span class="cov8" title="1"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                stmt.Close()
                return nil, ctx.Err()</span>
        }
        <span class="cov8" title="1">return stmt, nil</span>
}

func (stmt *mysqlStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) <span class="cov8" title="1">{
        dargs, err := namedValueToValue(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := stmt.mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err := stmt.query(dargs)
        if err != nil </span><span class="cov0" title="0">{
                stmt.mc.finish()
                return nil, err
        }</span>
        <span class="cov8" title="1">rows.finish = stmt.mc.finish
        return rows, err</span>
}

func (stmt *mysqlStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) <span class="cov8" title="1">{
        dargs, err := namedValueToValue(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := stmt.mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer stmt.mc.finish()

        return stmt.Exec(dargs)</span>
}

func (mc *mysqlConn) watchCancel(ctx context.Context) error <span class="cov8" title="1">{
        if mc.watching </span><span class="cov0" title="0">{
                // Reach here if canceled,
                // so the connection is already invalid
                mc.cleanup()
                return nil
        }</span>
        // When ctx is already cancelled, don't watch it.
        <span class="cov8" title="1">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // When ctx is not cancellable, don't watch it.
        <span class="cov8" title="1">if ctx.Done() == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // When watcher is not alive, can't watch it.
        <span class="cov8" title="1">if mc.watcher == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">mc.watching = true
        mc.watcher &lt;- ctx
        return nil</span>
}

func (mc *mysqlConn) startWatcher() <span class="cov8" title="1">{
        watcher := make(chan context.Context, 1)
        mc.watcher = watcher
        finished := make(chan struct{})
        mc.finished = finished
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        var ctx context.Context
                        select </span>{
                        case ctx = &lt;-watcher:<span class="cov8" title="1"></span>
                        case &lt;-mc.closech:<span class="cov8" title="1">
                                return</span>
                        }

                        <span class="cov8" title="1">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                mc.cancel(ctx.Err())</span>
                        case &lt;-finished:<span class="cov8" title="1"></span>
                        case &lt;-mc.closech:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (mc *mysqlConn) CheckNamedValue(nv *driver.NamedValue) (err error) <span class="cov8" title="1">{
        nv.Value, err = converter{}.ConvertValue(nv.Value)
        return
}</span>

// ResetSession implements driver.SessionResetter.
// (From Go 1.10)
func (mc *mysqlConn) ResetSession(ctx context.Context) error <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                return driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">mc.reset = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2018 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "context"
        "database/sql/driver"
        mskdriver "gitlab.papegames.com/fringe/mskeeper/driver"
        "net"
)

type connector struct {
        cfg *Config // immutable private copy.
        msk *mskdriver.MSKeeper
}

// Connect implements driver.Connector interface.
// Connect returns a connection to the database.
func (c *connector) Connect(ctx context.Context) (driver.Conn, error) <span class="cov8" title="1">{
        var err error

        // New mysqlConn
        mc := &amp;mysqlConn{
                connector:        c,
                maxAllowedPacket: maxPacketSize,
                maxWriteSize:     maxPacketSize - 1,
                closech:          make(chan struct{}),
                cfg:              c.cfg,
        }
        mc.parseTime = mc.cfg.ParseTime

        // Connect to Server
        dialsLock.RLock()
        dial, ok := dials[mc.cfg.Net]
        dialsLock.RUnlock()
        if ok </span><span class="cov0" title="0">{
                dctx := ctx
                if mc.cfg.Timeout &gt; 0 </span><span class="cov0" title="0">{
                        var cancel context.CancelFunc
                        dctx, cancel = context.WithTimeout(ctx, c.cfg.Timeout)
                        defer cancel()
                }</span>
                <span class="cov0" title="0">mc.netConn, err = dial(dctx, mc.cfg.Addr)</span>
        } else<span class="cov8" title="1"> {
                nd := net.Dialer{Timeout: mc.cfg.Timeout}
                mc.netConn, err = nd.DialContext(ctx, mc.cfg.Net, mc.cfg.Addr)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Enable TCP Keepalives on TCP connections
        <span class="cov8" title="1">if tc, ok := mc.netConn.(*net.TCPConn); ok </span><span class="cov8" title="1">{
                if err := tc.SetKeepAlive(true); err != nil </span><span class="cov0" title="0">{
                        // Don't send COM_QUIT before handshake.
                        mc.netConn.Close()
                        mc.netConn = nil
                        return nil, err
                }</span>
        }

        // Call startWatcher for context support (From Go 1.8)
        <span class="cov8" title="1">mc.startWatcher()
        if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                mc.cleanup()
                return nil, err
        }</span>
        <span class="cov8" title="1">defer mc.finish()

        mc.buf = newBuffer(mc.netConn)

        // Set I/O timeouts
        mc.buf.timeout = mc.cfg.ReadTimeout
        mc.writeTimeout = mc.cfg.WriteTimeout

        // Reading Handshake Initialization Packet
        authData, plugin, err := mc.readHandshakePacket()
        if err != nil </span><span class="cov0" title="0">{
                mc.cleanup()
                return nil, err
        }</span>

        <span class="cov8" title="1">if plugin == "" </span><span class="cov0" title="0">{
                plugin = defaultAuthPlugin
        }</span>

        // Send Client Authentication Packet
        <span class="cov8" title="1">authResp, err := mc.auth(authData, plugin)
        if err != nil </span><span class="cov0" title="0">{
                // try the default auth plugin, if using the requested plugin failed
                errLog.Print("could not use requested auth plugin '"+plugin+"': ", err.Error())
                plugin = defaultAuthPlugin
                authResp, err = mc.auth(authData, plugin)
                if err != nil </span><span class="cov0" title="0">{
                        mc.cleanup()
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if err = mc.writeHandshakeResponsePacket(authResp, plugin); err != nil </span><span class="cov0" title="0">{
                mc.cleanup()
                return nil, err
        }</span>

        // Handle response to auth packet, switch methods if possible
        <span class="cov8" title="1">if err = mc.handleAuthResult(authData, plugin); err != nil </span><span class="cov0" title="0">{
                // Authentication failed and MySQL has already closed the connection
                // (https://dev.mysql.com/doc/internals/en/authentication-fails.html).
                // Do not send COM_QUIT, just cleanup and return the error.
                mc.cleanup()
                return nil, err
        }</span>

        <span class="cov8" title="1">if mc.cfg.MaxAllowedPacket &gt; 0 </span><span class="cov8" title="1">{
                mc.maxAllowedPacket = mc.cfg.MaxAllowedPacket
        }</span> else<span class="cov0" title="0"> {
                // Get max allowed packet size
                maxap, err := mc.getSystemVar("max_allowed_packet")
                if err != nil </span><span class="cov0" title="0">{
                        mc.Close()
                        return nil, err
                }</span>
                <span class="cov0" title="0">mc.maxAllowedPacket = stringToInt(maxap) - 1</span>
        }
        <span class="cov8" title="1">if mc.maxAllowedPacket &lt; maxPacketSize </span><span class="cov8" title="1">{
                mc.maxWriteSize = mc.maxAllowedPacket
        }</span>

        // Handle DSN Params
        <span class="cov8" title="1">err = mc.handleParams()
        if err != nil </span><span class="cov0" title="0">{
                mc.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">return mc, nil</span>
}

// Driver implements driver.Connector interface.
// Driver returns &amp;MySQLDriver{}.
func (c *connector) Driver() driver.Driver <span class="cov0" title="0">{
        return &amp;MSKeeperDriver{}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2012 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

// Package mysql provides a MySQL driver for Go's database/sql package.
//
// The driver should be used via the database/sql package:
//
//  import "database/sql"
//  import _ "gitlab.papegames.com/fringe/mskeeper"
//
//  db, err := sql.Open("mskeeper", "user:password@/dbname")
//
// See https:gitlab.papegames.com/fringe/mskeeper for details
package mysql

import (
        "context"
        "database/sql"
        "database/sql/driver"
        "errors"
        mskdriver "gitlab.papegames.com/fringe/mskeeper/driver"
        "log"
        "net"
        "reflect"
        "sync"
)

var (
        ErrMSKeeperInstanceNil = errors.New("mskeeper instance no exists")
)

// Global connector array keeps track of all connections to mysql's driver
var mskDriver *MSKeeperDriver = &amp;MSKeeperDriver{}
var mskInstanceMap sync.Map

// MSKeeperDriver is exported to make the driver directly accessible.
// In general the driver is used via the database/sql package.
type MSKeeperDriver struct {
}

// DialFunc is a function which can be used to establish the network connection.
// Custom dial functions must be registered with RegisterDial
//
// Deprecated: users should register a DialContextFunc instead
type DialFunc func(addr string) (net.Conn, error)

// DialContextFunc is a function which can be used to establish the network connection.
// Custom dial functions must be registered with RegisterDialContext
type DialContextFunc func(ctx context.Context, addr string) (net.Conn, error)

var (
        dialsLock sync.RWMutex
        dials     map[string]DialContextFunc
)

// RegisterDialContext registers a custom dial function. It can then be used by the
// network address mynet(addr), where mynet is the registered new network.
// The current context for the connection and its address is passed to the dial function.
func RegisterDialContext(net string, dial DialContextFunc) <span class="cov0" title="0">{
        dialsLock.Lock()
        defer dialsLock.Unlock()
        if dials == nil </span><span class="cov0" title="0">{
                dials = make(map[string]DialContextFunc)
        }</span>
        <span class="cov0" title="0">dials[net] = dial</span>
}

// RegisterDial registers a custom dial function. It can then be used by the
// network address mynet(addr), where mynet is the registered new network.
// addr is passed as a parameter to the dial function.
//
// Deprecated: users should call RegisterDialContext instead
func RegisterDial(network string, dial DialFunc) <span class="cov0" title="0">{
        RegisterDialContext(network, func(_ context.Context, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                return dial(addr)
        }</span>)
}

// Open new Connection.
// See https://github.com/go-sql-driver/mysql#dsn-data-source-name for how
// the DSN string is formatted
func (d MSKeeperDriver) Open(dsn string) (driver.Conn, error) <span class="cov0" title="0">{
        cfg, err := ParseDSN(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c := &amp;connector{
                cfg: cfg,
        }

        formatedDSN := cfg.FormatDSN()
        msk := d.loadMSKeeperInstanceBy(formatedDSN)
        if msk == nil </span><span class="cov0" title="0">{
                msk = mskdriver.NewMSK(c)
                if err := mskDriver.storeMSKeeperInstanceWith(formatedDSN, msk); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">c.msk = msk

        return c.Connect(context.Background())</span>
}

func init() <span class="cov8" title="1">{
        sql.Register("mskeeper", mskDriver)
}</span>

func MSKeeperInstance(dsn string) *mskdriver.MSKeeper <span class="cov8" title="1">{
        cfg, err := ParseDSN(dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("MSKeeperInstance failed to parse dsn %v", dsn)
                return nil
        }</span>

        <span class="cov8" title="1">if msk := mskDriver.loadMSKeeperInstanceBy(cfg.FormatDSN()); msk != nil </span><span class="cov8" title="1">{
                return msk
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewConnector returns new driver.Connector.
func NewConnector(cfg *Config) (driver.Connector, error) <span class="cov0" title="0">{
        cfg = cfg.Clone()
        // normalize the contents of cfg so calls to NewConnector have the same
        // behavior as MSKeeperDriver.OpenConnector
        if err := cfg.normalize(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c := &amp;connector{cfg: cfg}
        formatedDSN := cfg.FormatDSN()
        msk := mskDriver.loadMSKeeperInstanceBy(formatedDSN)
        if msk == nil </span><span class="cov0" title="0">{
                msk = mskdriver.NewMSK(c)
                if err := mskDriver.storeMSKeeperInstanceWith(formatedDSN, msk); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">c.msk = msk
        return c, nil</span>
}

// OpenConnector implements driver.DriverContext.
func (d MSKeeperDriver) OpenConnector(dsn string) (driver.Connector, error) <span class="cov8" title="1">{

        cfg, err := ParseDSN(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c := &amp;connector{
                cfg: cfg,
        }
        formatedDSN := cfg.FormatDSN()
        msk := d.loadMSKeeperInstanceBy(formatedDSN)
        if msk == nil </span><span class="cov8" title="1">{
                msk = mskdriver.NewMSK(c)
                if err := mskDriver.storeMSKeeperInstanceWith(formatedDSN, msk); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">c.msk = msk

        return c, nil</span>
}

// Load the mskeeper instance by formated dsn
func (d MSKeeperDriver) loadMSKeeperInstanceBy(formatedDSN string) *mskdriver.MSKeeper <span class="cov8" title="1">{

        msk, ok := mskInstanceMap.Load(formatedDSN)
        if ok </span><span class="cov8" title="1">{
                formatedMSK, okk := msk.(*mskdriver.MSKeeper)
                if okk </span><span class="cov8" title="1">{
                        return formatedMSK
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Load the mskeeper instance by formated dsn
func (d MSKeeperDriver) storeMSKeeperInstanceWith(formatedDSN string, msk *mskdriver.MSKeeper) error <span class="cov8" title="1">{
        actual, ok := mskInstanceMap.LoadOrStore(formatedDSN, msk)
        if !ok </span><span class="cov8" title="1">{
                if !reflect.DeepEqual(actual, msk) </span><span class="cov0" title="0">{
                        return errors.New("stored sth different with the expected MSKeeper")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2016 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "bytes"
        "crypto/rsa"
        "crypto/tls"
        "errors"
        "fmt"
        "math/big"
        "net"
        "net/url"
        "sort"
        "strconv"
        "strings"
        "time"
)

var (
        errInvalidDSNUnescaped       = errors.New("invalid DSN: did you forget to escape a param value?")
        errInvalidDSNAddr            = errors.New("invalid DSN: network address not terminated (missing closing brace)")
        errInvalidDSNNoSlash         = errors.New("invalid DSN: missing the slash separating the database name")
        errInvalidDSNUnsafeCollation = errors.New("invalid DSN: interpolateParams can not be used with unsafe collations")
)

// Config is a configuration parsed from a DSN string.
// If a new Config is created instead of being parsed from a DSN string,
// the NewConfig function should be used, which sets default values.
type Config struct {
        User             string            // Username
        Passwd           string            // Password (requires User)
        Net              string            // Network type
        Addr             string            // Network address (requires Net)
        DBName           string            // Database name
        Params           map[string]string // Connection parameters
        Collation        string            // Connection collation
        Loc              *time.Location    // Location for time.Time values
        MaxAllowedPacket int               // Max packet size allowed
        ServerPubKey     string            // Server public key name
        pubKey           *rsa.PublicKey    // Server public key
        TLSConfig        string            // TLS configuration name
        tls              *tls.Config       // TLS configuration
        Timeout          time.Duration     // Dial timeout
        ReadTimeout      time.Duration     // I/O read timeout
        WriteTimeout     time.Duration     // I/O write timeout

        AllowAllFiles           bool // Allow all files to be used with LOAD DATA LOCAL INFILE
        AllowCleartextPasswords bool // Allows the cleartext client side plugin
        AllowNativePasswords    bool // Allows the native password authentication method
        AllowOldPasswords       bool // Allows the old insecure password method
        CheckConnLiveness       bool // Check connections for liveness before using them
        ClientFoundRows         bool // Return number of matching rows instead of rows changed
        ColumnsWithAlias        bool // Prepend table alias to column names
        InterpolateParams       bool // Interpolate placeholders into query string
        MultiStatements         bool // Allow multiple statements in one query
        ParseTime               bool // Parse time values to time.Time
        RejectReadOnly          bool // Reject read-only connections
}

// NewConfig creates a new Config and sets default values.
func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Collation:            defaultCollation,
                Loc:                  time.UTC,
                MaxAllowedPacket:     defaultMaxAllowedPacket,
                AllowNativePasswords: true,
                CheckConnLiveness:    true,
        }
}</span>

func (cfg *Config) Clone() *Config <span class="cov0" title="0">{
        cp := *cfg
        if cp.tls != nil </span><span class="cov0" title="0">{
                cp.tls = cfg.tls.Clone()
        }</span>
        <span class="cov0" title="0">if len(cp.Params) &gt; 0 </span><span class="cov0" title="0">{
                cp.Params = make(map[string]string, len(cfg.Params))
                for k, v := range cfg.Params </span><span class="cov0" title="0">{
                        cp.Params[k] = v
                }</span>
        }
        <span class="cov0" title="0">if cfg.pubKey != nil </span><span class="cov0" title="0">{
                cp.pubKey = &amp;rsa.PublicKey{
                        N: new(big.Int).Set(cfg.pubKey.N),
                        E: cfg.pubKey.E,
                }
        }</span>
        <span class="cov0" title="0">return &amp;cp</span>
}

func (cfg *Config) normalize() error <span class="cov8" title="1">{
        if cfg.InterpolateParams &amp;&amp; unsafeCollations[cfg.Collation] </span><span class="cov0" title="0">{
                return errInvalidDSNUnsafeCollation
        }</span>

        // Set default network if empty
        <span class="cov8" title="1">if cfg.Net == "" </span><span class="cov0" title="0">{
                cfg.Net = "tcp"
        }</span>

        // Set default address if empty
        <span class="cov8" title="1">if cfg.Addr == "" </span><span class="cov0" title="0">{
                switch cfg.Net </span>{
                case "tcp":<span class="cov0" title="0">
                        cfg.Addr = "127.0.0.1:3306"</span>
                case "unix":<span class="cov0" title="0">
                        cfg.Addr = "/tmp/mysql.sock"</span>
                default:<span class="cov0" title="0">
                        return errors.New("default addr for network '" + cfg.Net + "' unknown")</span>
                }
        } else<span class="cov8" title="1"> if cfg.Net == "tcp" </span><span class="cov8" title="1">{
                cfg.Addr = ensureHavePort(cfg.Addr)
        }</span>

        <span class="cov8" title="1">switch cfg.TLSConfig </span>{
        case "false", "":<span class="cov8" title="1"></span>
                // don't set anything
        case "true":<span class="cov0" title="0">
                cfg.tls = &amp;tls.Config{}</span>
        case "skip-verify", "preferred":<span class="cov0" title="0">
                cfg.tls = &amp;tls.Config{InsecureSkipVerify: true}</span>
        default:<span class="cov0" title="0">
                cfg.tls = getTLSConfigClone(cfg.TLSConfig)
                if cfg.tls == nil </span><span class="cov0" title="0">{
                        return errors.New("invalid value / unknown config name: " + cfg.TLSConfig)
                }</span>
        }

        <span class="cov8" title="1">if cfg.tls != nil &amp;&amp; cfg.tls.ServerName == "" &amp;&amp; !cfg.tls.InsecureSkipVerify </span><span class="cov0" title="0">{
                host, _, err := net.SplitHostPort(cfg.Addr)
                if err == nil </span><span class="cov0" title="0">{
                        cfg.tls.ServerName = host
                }</span>
        }

        <span class="cov8" title="1">if cfg.ServerPubKey != "" </span><span class="cov0" title="0">{
                cfg.pubKey = getServerPubKey(cfg.ServerPubKey)
                if cfg.pubKey == nil </span><span class="cov0" title="0">{
                        return errors.New("invalid value / unknown server pub key name: " + cfg.ServerPubKey)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func writeDSNParam(buf *bytes.Buffer, hasParam *bool, name, value string) <span class="cov8" title="1">{
        buf.Grow(1 + len(name) + 1 + len(value))
        if !*hasParam </span><span class="cov8" title="1">{
                *hasParam = true
                buf.WriteByte('?')
        }</span> else<span class="cov0" title="0"> {
                buf.WriteByte('&amp;')
        }</span>
        <span class="cov8" title="1">buf.WriteString(name)
        buf.WriteByte('=')
        buf.WriteString(value)</span>
}

// FormatDSN formats the given Config into a DSN string which can be passed to
// the driver.
func (cfg *Config) FormatDSN() string <span class="cov8" title="1">{
        var buf bytes.Buffer

        // [username[:password]@]
        if len(cfg.User) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(cfg.User)
                if len(cfg.Passwd) &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteByte(':')
                        buf.WriteString(cfg.Passwd)
                }</span>
                <span class="cov8" title="1">buf.WriteByte('@')</span>
        }

        // [protocol[(address)]]
        <span class="cov8" title="1">if len(cfg.Net) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(cfg.Net)
                if len(cfg.Addr) &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteByte('(')
                        buf.WriteString(cfg.Addr)
                        buf.WriteByte(')')
                }</span>
        }

        // /dbname
        <span class="cov8" title="1">buf.WriteByte('/')
        buf.WriteString(cfg.DBName)

        // [?param1=value1&amp;...&amp;paramN=valueN]
        hasParam := false

        if cfg.AllowAllFiles </span><span class="cov0" title="0">{
                hasParam = true
                buf.WriteString("?allowAllFiles=true")
        }</span>

        <span class="cov8" title="1">if cfg.AllowCleartextPasswords </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "allowCleartextPasswords", "true")
        }</span>

        <span class="cov8" title="1">if !cfg.AllowNativePasswords </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "allowNativePasswords", "false")
        }</span>

        <span class="cov8" title="1">if cfg.AllowOldPasswords </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "allowOldPasswords", "true")
        }</span>

        <span class="cov8" title="1">if !cfg.CheckConnLiveness </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "checkConnLiveness", "false")
        }</span>

        <span class="cov8" title="1">if cfg.ClientFoundRows </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "clientFoundRows", "true")
        }</span>

        <span class="cov8" title="1">if col := cfg.Collation; col != defaultCollation &amp;&amp; len(col) &gt; 0 </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "collation", col)
        }</span>

        <span class="cov8" title="1">if cfg.ColumnsWithAlias </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "columnsWithAlias", "true")
        }</span>

        <span class="cov8" title="1">if cfg.InterpolateParams </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "interpolateParams", "true")
        }</span>

        <span class="cov8" title="1">if cfg.Loc != time.UTC &amp;&amp; cfg.Loc != nil </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "loc", url.QueryEscape(cfg.Loc.String()))
        }</span>

        <span class="cov8" title="1">if cfg.MultiStatements </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "multiStatements", "true")
        }</span>

        <span class="cov8" title="1">if cfg.ParseTime </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "parseTime", "true")
        }</span>

        <span class="cov8" title="1">if cfg.ReadTimeout &gt; 0 </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "readTimeout", cfg.ReadTimeout.String())
        }</span>

        <span class="cov8" title="1">if cfg.RejectReadOnly </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "rejectReadOnly", "true")
        }</span>

        <span class="cov8" title="1">if len(cfg.ServerPubKey) &gt; 0 </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "serverPubKey", url.QueryEscape(cfg.ServerPubKey))
        }</span>

        <span class="cov8" title="1">if cfg.Timeout &gt; 0 </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "timeout", cfg.Timeout.String())
        }</span>

        <span class="cov8" title="1">if len(cfg.TLSConfig) &gt; 0 </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "tls", url.QueryEscape(cfg.TLSConfig))
        }</span>

        <span class="cov8" title="1">if cfg.WriteTimeout &gt; 0 </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "writeTimeout", cfg.WriteTimeout.String())
        }</span>

        <span class="cov8" title="1">if cfg.MaxAllowedPacket != defaultMaxAllowedPacket </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "maxAllowedPacket", strconv.Itoa(cfg.MaxAllowedPacket))
        }</span>

        // other params
        <span class="cov8" title="1">if cfg.Params != nil </span><span class="cov0" title="0">{
                var params []string
                for param := range cfg.Params </span><span class="cov0" title="0">{
                        params = append(params, param)
                }</span>
                <span class="cov0" title="0">sort.Strings(params)
                for _, param := range params </span><span class="cov0" title="0">{
                        writeDSNParam(&amp;buf, &amp;hasParam, param, url.QueryEscape(cfg.Params[param]))
                }</span>
        }

        <span class="cov8" title="1">return buf.String()</span>
}

// ParseDSN parses the DSN string to a Config
func ParseDSN(dsn string) (cfg *Config, err error) <span class="cov8" title="1">{
        // New config with some default values
        cfg = NewConfig()

        // [user[:password]@][net[(addr)]]/dbname[?param1=value1&amp;paramN=valueN]
        // Find the last '/' (since the password or the net addr might contain a '/')
        foundSlash := false
        for i := len(dsn) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if dsn[i] == '/' </span><span class="cov8" title="1">{
                        foundSlash = true
                        var j, k int

                        // left part is empty if i &lt;= 0
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                // [username[:password]@][protocol[(address)]]
                                // Find the last '@' in dsn[:i]
                                for j = i; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                                        if dsn[j] == '@' </span><span class="cov8" title="1">{
                                                // username[:password]
                                                // Find the first ':' in dsn[:j]
                                                for k = 0; k &lt; j; k++ </span><span class="cov8" title="1">{
                                                        if dsn[k] == ':' </span><span class="cov8" title="1">{
                                                                cfg.Passwd = dsn[k+1 : j]
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">cfg.User = dsn[:k]

                                                break</span>
                                        }
                                }

                                // [protocol[(address)]]
                                // Find the first '(' in dsn[j+1:i]
                                <span class="cov8" title="1">for k = j + 1; k &lt; i; k++ </span><span class="cov8" title="1">{
                                        if dsn[k] == '(' </span><span class="cov8" title="1">{
                                                // dsn[i-1] must be == ')' if an address is specified
                                                if dsn[i-1] != ')' </span><span class="cov0" title="0">{
                                                        if strings.ContainsRune(dsn[k+1:i], ')') </span><span class="cov0" title="0">{
                                                                return nil, errInvalidDSNUnescaped
                                                        }</span>
                                                        <span class="cov0" title="0">return nil, errInvalidDSNAddr</span>
                                                }
                                                <span class="cov8" title="1">cfg.Addr = dsn[k+1 : i-1]
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">cfg.Net = dsn[j+1 : k]</span>
                        }

                        // dbname[?param1=value1&amp;...&amp;paramN=valueN]
                        // Find the first '?' in dsn[i+1:]
                        <span class="cov8" title="1">for j = i + 1; j &lt; len(dsn); j++ </span><span class="cov8" title="1">{
                                if dsn[j] == '?' </span><span class="cov8" title="1">{
                                        if err = parseDSNParams(cfg, dsn[j+1:]); err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">cfg.DBName = dsn[i+1 : j]

                        break</span>
                }
        }

        <span class="cov8" title="1">if !foundSlash &amp;&amp; len(dsn) &gt; 0 </span><span class="cov0" title="0">{
                return nil, errInvalidDSNNoSlash
        }</span>

        <span class="cov8" title="1">if err = cfg.normalize(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return</span>
}

// parseDSNParams parses the DSN "query string"
// Values must be url.QueryEscape'ed
func parseDSNParams(cfg *Config, params string) (err error) <span class="cov8" title="1">{
        for _, v := range strings.Split(params, "&amp;") </span><span class="cov8" title="1">{
                param := strings.SplitN(v, "=", 2)
                if len(param) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // cfg params
                <span class="cov8" title="1">switch value := param[1]; param[0] </span>{
                // Disable INFILE whitelist / enable all files
                case "allowAllFiles":<span class="cov0" title="0">
                        var isBool bool
                        cfg.AllowAllFiles, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Use cleartext authentication mode (MySQL 5.5.10+)
                case "allowCleartextPasswords":<span class="cov0" title="0">
                        var isBool bool
                        cfg.AllowCleartextPasswords, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Use native password authentication
                case "allowNativePasswords":<span class="cov0" title="0">
                        var isBool bool
                        cfg.AllowNativePasswords, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Use old authentication mode (pre MySQL 4.1)
                case "allowOldPasswords":<span class="cov0" title="0">
                        var isBool bool
                        cfg.AllowOldPasswords, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Check connections for Liveness before using them
                case "checkConnLiveness":<span class="cov0" title="0">
                        var isBool bool
                        cfg.CheckConnLiveness, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Switch "rowsAffected" mode
                case "clientFoundRows":<span class="cov0" title="0">
                        var isBool bool
                        cfg.ClientFoundRows, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Collation
                case "collation":<span class="cov0" title="0">
                        cfg.Collation = value</span>

                case "columnsWithAlias":<span class="cov0" title="0">
                        var isBool bool
                        cfg.ColumnsWithAlias, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Compression
                case "compress":<span class="cov0" title="0">
                        return errors.New("compression not implemented yet")</span>

                // Enable client side placeholder substitution
                case "interpolateParams":<span class="cov0" title="0">
                        var isBool bool
                        cfg.InterpolateParams, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Time Location
                case "loc":<span class="cov0" title="0">
                        if value, err = url.QueryUnescape(value); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">cfg.Loc, err = time.LoadLocation(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                // multiple statements in one query
                case "multiStatements":<span class="cov0" title="0">
                        var isBool bool
                        cfg.MultiStatements, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // time.Time parsing
                case "parseTime":<span class="cov0" title="0">
                        var isBool bool
                        cfg.ParseTime, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // I/O read Timeout
                case "readTimeout":<span class="cov0" title="0">
                        cfg.ReadTimeout, err = time.ParseDuration(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                // Reject read-only connections
                case "rejectReadOnly":<span class="cov0" title="0">
                        var isBool bool
                        cfg.RejectReadOnly, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Server public key
                case "serverPubKey":<span class="cov0" title="0">
                        name, err := url.QueryUnescape(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid value for server pub key name: %v", err)
                        }</span>
                        <span class="cov0" title="0">cfg.ServerPubKey = name</span>

                // Strict mode
                case "strict":<span class="cov0" title="0">
                        panic("strict mode has been removed. See https://github.com/go-sql-driver/mysql/wiki/strict-mode")</span>

                // Dial Timeout
                case "timeout":<span class="cov8" title="1">
                        cfg.Timeout, err = time.ParseDuration(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                // TLS-Encryption
                case "tls":<span class="cov0" title="0">
                        boolValue, isBool := readBool(value)
                        if isBool </span><span class="cov0" title="0">{
                                if boolValue </span><span class="cov0" title="0">{
                                        cfg.TLSConfig = "true"
                                }</span> else<span class="cov0" title="0"> {
                                        cfg.TLSConfig = "false"
                                }</span>
                        } else<span class="cov0" title="0"> if vl := strings.ToLower(value); vl == "skip-verify" || vl == "preferred" </span><span class="cov0" title="0">{
                                cfg.TLSConfig = vl
                        }</span> else<span class="cov0" title="0"> {
                                name, err := url.QueryUnescape(value)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid value for TLS config name: %v", err)
                                }</span>
                                <span class="cov0" title="0">cfg.TLSConfig = name</span>
                        }

                // I/O write Timeout
                case "writeTimeout":<span class="cov0" title="0">
                        cfg.WriteTimeout, err = time.ParseDuration(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                case "maxAllowedPacket":<span class="cov0" title="0">
                        cfg.MaxAllowedPacket, err = strconv.Atoi(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                default:<span class="cov0" title="0">
                        // lazy init
                        if cfg.Params == nil </span><span class="cov0" title="0">{
                                cfg.Params = make(map[string]string)
                        }</span>

                        <span class="cov0" title="0">if cfg.Params[param[0]], err = url.QueryUnescape(value); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

func ensureHavePort(addr string) string <span class="cov8" title="1">{
        if _, _, err := net.SplitHostPort(addr); err != nil </span><span class="cov0" title="0">{
                return net.JoinHostPort(addr, "3306")
        }</span>
        <span class="cov8" title="1">return addr</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "errors"
        "fmt"
        "log"
        "os"
)

// Various errors the driver might return. Can change between driver versions.
var (
        ErrInvalidConn       = errors.New("invalid connection")
        ErrMalformPkt        = errors.New("malformed packet")
        ErrNoTLS             = errors.New("TLS requested but server does not support TLS")
        ErrCleartextPassword = errors.New("this user requires clear text authentication. If you still want to use it, please add 'allowCleartextPasswords=1' to your DSN")
        ErrNativePassword    = errors.New("this user requires mysql native password authentication.")
        ErrOldPassword       = errors.New("this user requires old password authentication. If you still want to use it, please add 'allowOldPasswords=1' to your DSN. See also https://github.com/go-sql-driver/mysql/wiki/old_passwords")
        ErrUnknownPlugin     = errors.New("this authentication plugin is not supported")
        ErrOldProtocol       = errors.New("MySQL server does not support required protocol 41+")
        ErrPktSync           = errors.New("commands out of sync. You can't run this command now")
        ErrPktSyncMul        = errors.New("commands out of sync. Did you run multiple statements at once?")
        ErrPktTooLarge       = errors.New("packet for query is too large. Try adjusting the 'max_allowed_packet' variable on the server")
        ErrBusyBuffer        = errors.New("busy buffer")

        // errBadConnNoWrite is used for connection errors where nothing was sent to the database yet.
        // If this happens first in a function starting a database interaction, it should be replaced by driver.ErrBadConn
        // to trigger a resend.
        // See https://github.com/go-sql-driver/mysql/pull/302
        errBadConnNoWrite = errors.New("bad connection")
)

var errLog = Logger(log.New(os.Stderr, "[mysql] ", log.Ldate|log.Ltime|log.Lshortfile))

// Logger is used to log critical error messages.
type Logger interface {
        Print(v ...interface{})
}

// SetLogger is used to set the logger for critical errors.
// The initial logger is os.Stderr.
func SetLogger(logger Logger) error <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                return errors.New("logger is nil")
        }</span>
        <span class="cov0" title="0">errLog = logger
        return nil</span>
}

func GetLogger() Logger <span class="cov0" title="0">{
        return errLog
}</span>

// MySQLError is an error type which represents a single MySQL error
type MySQLError struct {
        Number  uint16
        Message string
}

func (me *MySQLError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error %d: %s", me.Number, me.Message)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2017 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "database/sql"
        "reflect"
)

func (mf *mysqlField) typeDatabaseName() string <span class="cov0" title="0">{
        switch mf.fieldType </span>{
        case fieldTypeBit:<span class="cov0" title="0">
                return "BIT"</span>
        case fieldTypeBLOB:<span class="cov0" title="0">
                if mf.charSet != collations[binaryCollation] </span><span class="cov0" title="0">{
                        return "TEXT"
                }</span>
                <span class="cov0" title="0">return "BLOB"</span>
        case fieldTypeDate:<span class="cov0" title="0">
                return "DATE"</span>
        case fieldTypeDateTime:<span class="cov0" title="0">
                return "DATETIME"</span>
        case fieldTypeDecimal:<span class="cov0" title="0">
                return "DECIMAL"</span>
        case fieldTypeDouble:<span class="cov0" title="0">
                return "DOUBLE"</span>
        case fieldTypeEnum:<span class="cov0" title="0">
                return "ENUM"</span>
        case fieldTypeFloat:<span class="cov0" title="0">
                return "FLOAT"</span>
        case fieldTypeGeometry:<span class="cov0" title="0">
                return "GEOMETRY"</span>
        case fieldTypeInt24:<span class="cov0" title="0">
                return "MEDIUMINT"</span>
        case fieldTypeJSON:<span class="cov0" title="0">
                return "JSON"</span>
        case fieldTypeLong:<span class="cov0" title="0">
                return "INT"</span>
        case fieldTypeLongBLOB:<span class="cov0" title="0">
                if mf.charSet != collations[binaryCollation] </span><span class="cov0" title="0">{
                        return "TEXT"
                }</span>
                <span class="cov0" title="0">return "BLOB"</span>
        case fieldTypeLongLong:<span class="cov0" title="0">
                return "BIGINT"</span>
        case fieldTypeMediumBLOB:<span class="cov0" title="0">
                if mf.charSet != collations[binaryCollation] </span><span class="cov0" title="0">{
                        return "TEXT"
                }</span>
                <span class="cov0" title="0">return "BLOB"</span>
        case fieldTypeNewDate:<span class="cov0" title="0">
                return "DATE"</span>
        case fieldTypeNewDecimal:<span class="cov0" title="0">
                return "DECIMAL"</span>
        case fieldTypeNULL:<span class="cov0" title="0">
                return "NULL"</span>
        case fieldTypeSet:<span class="cov0" title="0">
                return "SET"</span>
        case fieldTypeShort:<span class="cov0" title="0">
                return "SMALLINT"</span>
        case fieldTypeString:<span class="cov0" title="0">
                if mf.charSet == collations[binaryCollation] </span><span class="cov0" title="0">{
                        return "BINARY"
                }</span>
                <span class="cov0" title="0">return "CHAR"</span>
        case fieldTypeTime:<span class="cov0" title="0">
                return "TIME"</span>
        case fieldTypeTimestamp:<span class="cov0" title="0">
                return "TIMESTAMP"</span>
        case fieldTypeTiny:<span class="cov0" title="0">
                return "TINYINT"</span>
        case fieldTypeTinyBLOB:<span class="cov0" title="0">
                if mf.charSet != collations[binaryCollation] </span><span class="cov0" title="0">{
                        return "TEXT"
                }</span>
                <span class="cov0" title="0">return "BLOB"</span>
        case fieldTypeVarChar:<span class="cov0" title="0">
                if mf.charSet == collations[binaryCollation] </span><span class="cov0" title="0">{
                        return "VARBINARY"
                }</span>
                <span class="cov0" title="0">return "VARCHAR"</span>
        case fieldTypeVarString:<span class="cov0" title="0">
                if mf.charSet == collations[binaryCollation] </span><span class="cov0" title="0">{
                        return "VARBINARY"
                }</span>
                <span class="cov0" title="0">return "VARCHAR"</span>
        case fieldTypeYear:<span class="cov0" title="0">
                return "YEAR"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

var (
        scanTypeFloat32   = reflect.TypeOf(float32(0))
        scanTypeFloat64   = reflect.TypeOf(float64(0))
        scanTypeInt8      = reflect.TypeOf(int8(0))
        scanTypeInt16     = reflect.TypeOf(int16(0))
        scanTypeInt32     = reflect.TypeOf(int32(0))
        scanTypeInt64     = reflect.TypeOf(int64(0))
        scanTypeNullFloat = reflect.TypeOf(sql.NullFloat64{})
        scanTypeNullInt   = reflect.TypeOf(sql.NullInt64{})
        scanTypeNullTime  = reflect.TypeOf(NullTime{})
        scanTypeUint8     = reflect.TypeOf(uint8(0))
        scanTypeUint16    = reflect.TypeOf(uint16(0))
        scanTypeUint32    = reflect.TypeOf(uint32(0))
        scanTypeUint64    = reflect.TypeOf(uint64(0))
        scanTypeRawBytes  = reflect.TypeOf(sql.RawBytes{})
        scanTypeUnknown   = reflect.TypeOf(new(interface{}))
)

type mysqlField struct {
        tableName string
        name      string
        length    uint32
        flags     fieldFlag
        fieldType fieldType
        decimals  byte
        charSet   uint8
}

func (mf *mysqlField) scanType() reflect.Type <span class="cov0" title="0">{
        switch mf.fieldType </span>{
        case fieldTypeTiny:<span class="cov0" title="0">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov0" title="0">{
                        if mf.flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                return scanTypeUint8
                        }</span>
                        <span class="cov0" title="0">return scanTypeInt8</span>
                }
                <span class="cov0" title="0">return scanTypeNullInt</span>

        case fieldTypeShort, fieldTypeYear:<span class="cov0" title="0">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov0" title="0">{
                        if mf.flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                return scanTypeUint16
                        }</span>
                        <span class="cov0" title="0">return scanTypeInt16</span>
                }
                <span class="cov0" title="0">return scanTypeNullInt</span>

        case fieldTypeInt24, fieldTypeLong:<span class="cov0" title="0">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov0" title="0">{
                        if mf.flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                return scanTypeUint32
                        }</span>
                        <span class="cov0" title="0">return scanTypeInt32</span>
                }
                <span class="cov0" title="0">return scanTypeNullInt</span>

        case fieldTypeLongLong:<span class="cov0" title="0">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov0" title="0">{
                        if mf.flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                return scanTypeUint64
                        }</span>
                        <span class="cov0" title="0">return scanTypeInt64</span>
                }
                <span class="cov0" title="0">return scanTypeNullInt</span>

        case fieldTypeFloat:<span class="cov0" title="0">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov0" title="0">{
                        return scanTypeFloat32
                }</span>
                <span class="cov0" title="0">return scanTypeNullFloat</span>

        case fieldTypeDouble:<span class="cov0" title="0">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov0" title="0">{
                        return scanTypeFloat64
                }</span>
                <span class="cov0" title="0">return scanTypeNullFloat</span>

        case fieldTypeDecimal, fieldTypeNewDecimal, fieldTypeVarChar,
                fieldTypeBit, fieldTypeEnum, fieldTypeSet, fieldTypeTinyBLOB,
                fieldTypeMediumBLOB, fieldTypeLongBLOB, fieldTypeBLOB,
                fieldTypeVarString, fieldTypeString, fieldTypeGeometry, fieldTypeJSON,
                fieldTypeTime:<span class="cov0" title="0">
                return scanTypeRawBytes</span>

        case fieldTypeDate, fieldTypeNewDate,
                fieldTypeTimestamp, fieldTypeDateTime:<span class="cov0" title="0">
                // NullTime is always returned for more consistent behavior as it can
                // handle both cases of parseTime regardless if the field is nullable.
                return scanTypeNullTime</span>

        default:<span class="cov0" title="0">
                return scanTypeUnknown</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "fmt"
        "io"
        "log"
        "os"
        "strings"
        "sync"
)

var (
        fileRegister       map[string]bool
        fileRegisterLock   sync.RWMutex
        readerRegister     map[string]func() io.Reader
        readerRegisterLock sync.RWMutex
)

// RegisterLocalFile adds the given file to the file whitelist,
// so that it can be used by "LOAD DATA LOCAL INFILE &lt;filepath&gt;".
// Alternatively you can allow the use of all local files with
// the DSN parameter 'allowAllFiles=true'
//
//  filePath := "/home/gopher/data.csv"
//  mysql.RegisterLocalFile(filePath)
//  err := db.Exec("LOAD DATA LOCAL INFILE '" + filePath + "' INTO TABLE foo")
//  if err != nil {
//  ...
//
func RegisterLocalFile(filePath string) <span class="cov0" title="0">{
        fileRegisterLock.Lock()
        // lazy map init
        if fileRegister == nil </span><span class="cov0" title="0">{
                fileRegister = make(map[string]bool)
        }</span>

        <span class="cov0" title="0">fileRegister[strings.Trim(filePath, `"`)] = true
        fileRegisterLock.Unlock()</span>
}

// DeregisterLocalFile removes the given filepath from the whitelist.
func DeregisterLocalFile(filePath string) <span class="cov0" title="0">{
        fileRegisterLock.Lock()
        delete(fileRegister, strings.Trim(filePath, `"`))
        fileRegisterLock.Unlock()
}</span>

// RegisterReaderHandler registers a handler function which is used
// to receive a io.Reader.
// The Reader can be used by "LOAD DATA LOCAL INFILE Reader::&lt;name&gt;".
// If the handler returns a io.ReadCloser Close() is called when the
// request is finished.
//
//  mysql.RegisterReaderHandler("data", func() io.Reader {
//          var csvReader io.Reader // Some Reader that returns CSV data
//          ... // Open Reader here
//          return csvReader
//  })
//  err := db.Exec("LOAD DATA LOCAL INFILE 'Reader::data' INTO TABLE foo")
//  if err != nil {
//  ...
//
func RegisterReaderHandler(name string, handler func() io.Reader) <span class="cov0" title="0">{
        readerRegisterLock.Lock()
        // lazy map init
        if readerRegister == nil </span><span class="cov0" title="0">{
                readerRegister = make(map[string]func() io.Reader)
        }</span>

        <span class="cov0" title="0">readerRegister[name] = handler
        readerRegisterLock.Unlock()</span>
}

// DeregisterReaderHandler removes the ReaderHandler function with
// the given name from the registry.
func DeregisterReaderHandler(name string) <span class="cov0" title="0">{
        readerRegisterLock.Lock()
        delete(readerRegister, name)
        readerRegisterLock.Unlock()
}</span>

func deferredClose(err *error, closer io.Closer) <span class="cov0" title="0">{
        closeErr := closer.Close()
        if *err == nil </span><span class="cov0" title="0">{
                *err = closeErr
        }</span>
}

func (mc *mysqlConn) handleInFileRequest(name string) (err error) <span class="cov0" title="0">{
        var rdr io.Reader
        var data []byte
        packetSize := 16 * 1024 // 16KB is small enough for disk readahead and large enough for TCP
        if mc.maxWriteSize &lt; packetSize </span><span class="cov0" title="0">{
                packetSize = mc.maxWriteSize
        }</span>

        <span class="cov0" title="0">if idx := strings.Index(name, "Reader::"); idx == 0 || (idx &gt; 0 &amp;&amp; name[idx-1] == '/') </span><span class="cov0" title="0">{ // io.Reader
                // The server might return an an absolute path. See issue #355.
                name = name[idx+8:]

                readerRegisterLock.RLock()
                handler, inMap := readerRegister[name]
                readerRegisterLock.RUnlock()

                if inMap </span><span class="cov0" title="0">{
                        rdr = handler()
                        if rdr != nil </span><span class="cov0" title="0">{
                                if cl, ok := rdr.(io.Closer); ok </span><span class="cov0" title="0">{
                                        defer deferredClose(&amp;err, cl)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                err = fmt.Errorf("Reader '%s' is &lt;nil&gt;", name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        err = fmt.Errorf("Reader '%s' is not registered", name)
                }</span>
        } else<span class="cov0" title="0"> { // File
                name = strings.Trim(name, `"`)
                log.Printf("name = %v", name)
                fileRegisterLock.RLock()
                fr := fileRegister[name]
                fileRegisterLock.RUnlock()
                if mc.cfg.AllowAllFiles || fr </span><span class="cov0" title="0">{
                        var file *os.File
                        var fi os.FileInfo

                        if file, err = os.Open(name); err == nil </span><span class="cov0" title="0">{
                                defer deferredClose(&amp;err, file)

                                // get file size
                                if fi, err = file.Stat(); err == nil </span><span class="cov0" title="0">{
                                        rdr = file
                                        if fileSize := int(fi.Size()); fileSize &lt; packetSize </span><span class="cov0" title="0">{
                                                packetSize = fileSize
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        err = fmt.Errorf("local file '%s' is not registered", name)
                }</span>
        }

        // send content packets
        // if packetSize == 0, the Reader contains no data
        <span class="cov0" title="0">if err == nil &amp;&amp; packetSize &gt; 0 </span><span class="cov0" title="0">{
                data := make([]byte, 4+packetSize)
                var n int
                for err == nil </span><span class="cov0" title="0">{
                        n, err = rdr.Read(data[4:])
                        if n &gt; 0 </span><span class="cov0" title="0">{
                                if ioErr := mc.writePacket(data[:4+n]); ioErr != nil </span><span class="cov0" title="0">{
                                        return ioErr
                                }</span>
                        }
                }
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        err = nil
                }</span>
        }

        // send empty packet (termination)
        <span class="cov0" title="0">if data == nil </span><span class="cov0" title="0">{
                data = make([]byte, 4)
        }</span>
        <span class="cov0" title="0">if ioErr := mc.writePacket(data[:4]); ioErr != nil </span><span class="cov0" title="0">{
                return ioErr
        }</span>

        // read OK packet
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                return mc.readResultOK()
        }</span>

        <span class="cov0" title="0">_, _ = mc.readPacket()

        return err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "database/sql/driver"
        "fmt"
        "time"
)

// Scan implements the Scanner interface.
// The value type must be time.Time or string / []byte (formatted time-string),
// otherwise Scan fails.
func (nt *NullTime) Scan(value interface{}) (err error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                nt.Time, nt.Valid = time.Time{}, false
                return
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case time.Time:<span class="cov0" title="0">
                nt.Time, nt.Valid = v, true
                return</span>
        case []byte:<span class="cov0" title="0">
                nt.Time, err = parseDateTime(string(v), time.UTC)
                nt.Valid = (err == nil)
                return</span>
        case string:<span class="cov0" title="0">
                nt.Time, err = parseDateTime(v, time.UTC)
                nt.Valid = (err == nil)
                return</span>
        }

        <span class="cov0" title="0">nt.Valid = false
        return fmt.Errorf("Can't convert %T to time.Time", value)</span>
}

// Value implements the driver Valuer interface.
func (nt NullTime) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !nt.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return nt.Time, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2012 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "bytes"
        "crypto/tls"
        "database/sql/driver"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "time"
)

// Packets documentation:
// http://dev.mysql.com/doc/internals/en/client-server-protocol.html

// Read packet to buffer 'data'
func (mc *mysqlConn) readPacket() ([]byte, error) <span class="cov8" title="1">{
        var prevData []byte
        for </span><span class="cov8" title="1">{
                // read packet header
                data, err := mc.buf.readNext(4)
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := mc.canceled.Value(); cerr != nil </span><span class="cov0" title="0">{
                                return nil, cerr
                        }</span>
                        <span class="cov0" title="0">errLog.Print(err)
                        mc.Close()
                        return nil, ErrInvalidConn</span>
                }

                // packet length [24 bit]
                <span class="cov8" title="1">pktLen := int(uint32(data[0]) | uint32(data[1])&lt;&lt;8 | uint32(data[2])&lt;&lt;16)

                // check packet sync [8 bit]
                if data[3] != mc.sequence </span><span class="cov8" title="1">{
                        if data[3] &gt; mc.sequence </span><span class="cov8" title="1">{
                                return nil, ErrPktSyncMul
                        }</span>
                        <span class="cov0" title="0">return nil, ErrPktSync</span>
                }
                <span class="cov8" title="1">mc.sequence++

                // packets with length 0 terminate a previous packet which is a
                // multiple of (2^24)-1 bytes long
                if pktLen == 0 </span><span class="cov0" title="0">{
                        // there was no previous packet
                        if prevData == nil </span><span class="cov0" title="0">{
                                errLog.Print(ErrMalformPkt)
                                mc.Close()
                                return nil, ErrInvalidConn
                        }</span>

                        <span class="cov0" title="0">return prevData, nil</span>
                }

                // read packet body [pktLen bytes]
                <span class="cov8" title="1">data, err = mc.buf.readNext(pktLen)
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := mc.canceled.Value(); cerr != nil </span><span class="cov0" title="0">{
                                return nil, cerr
                        }</span>
                        <span class="cov0" title="0">errLog.Print(err)
                        mc.Close()
                        return nil, ErrInvalidConn</span>
                }

                // return data if this was the last packet
                <span class="cov8" title="1">if pktLen &lt; maxPacketSize </span><span class="cov8" title="1">{
                        // zero allocations for non-split packets
                        if prevData == nil </span><span class="cov8" title="1">{
                                return data, nil
                        }</span>

                        <span class="cov0" title="0">return append(prevData, data...), nil</span>
                }

                <span class="cov0" title="0">prevData = append(prevData, data...)</span>
        }
}

// Write packet buffer 'data'
func (mc *mysqlConn) writePacket(data []byte) error <span class="cov8" title="1">{
        pktLen := len(data) - 4

        if pktLen &gt; mc.maxAllowedPacket </span><span class="cov0" title="0">{
                return ErrPktTooLarge
        }</span>

        // Perform a stale connection check. We only perform this check for
        // the first query on a connection that has been checked out of the
        // connection pool: a fresh connection from the pool is more likely
        // to be stale, and it has not performed any previous writes that
        // could cause data corruption, so it's safe to return ErrBadConn
        // if the check fails.
        <span class="cov8" title="1">if mc.reset </span><span class="cov8" title="1">{
                mc.reset = false
                conn := mc.netConn
                if mc.rawConn != nil </span><span class="cov0" title="0">{
                        conn = mc.rawConn
                }</span>
                <span class="cov8" title="1">var err error
                // If this connection has a ReadTimeout which we've been setting on
                // reads, reset it to its default value before we attempt a non-blocking
                // read, otherwise the scheduler will just time us out before we can read
                if mc.cfg.ReadTimeout != 0 </span><span class="cov0" title="0">{
                        err = conn.SetReadDeadline(time.Time{})
                }</span>
                <span class="cov8" title="1">if err == nil &amp;&amp; mc.cfg.CheckConnLiveness </span><span class="cov8" title="1">{
                        err = connCheck(conn)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        errLog.Print("closing bad idle connection: ", err)
                        mc.Close()
                        return driver.ErrBadConn
                }</span>
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var size int
                if pktLen &gt;= maxPacketSize </span><span class="cov0" title="0">{
                        data[0] = 0xff
                        data[1] = 0xff
                        data[2] = 0xff
                        size = maxPacketSize
                }</span> else<span class="cov8" title="1"> {
                        data[0] = byte(pktLen)
                        data[1] = byte(pktLen &gt;&gt; 8)
                        data[2] = byte(pktLen &gt;&gt; 16)
                        size = pktLen
                }</span>
                <span class="cov8" title="1">data[3] = mc.sequence

                // Write packet
                if mc.writeTimeout &gt; 0 </span><span class="cov0" title="0">{
                        if err := mc.netConn.SetWriteDeadline(time.Now().Add(mc.writeTimeout)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">n, err := mc.netConn.Write(data[:4+size])
                if err == nil &amp;&amp; n == 4+size </span><span class="cov8" title="1">{
                        mc.sequence++
                        if size != maxPacketSize </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">pktLen -= size
                        data = data[size:]
                        continue</span>
                }

                // Handle error
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{ // n != len(data)
                        mc.cleanup()
                        errLog.Print(ErrMalformPkt)
                }</span> else<span class="cov0" title="0"> {
                        if cerr := mc.canceled.Value(); cerr != nil </span><span class="cov0" title="0">{
                                return cerr
                        }</span>
                        <span class="cov0" title="0">if n == 0 &amp;&amp; pktLen == len(data)-4 </span><span class="cov0" title="0">{
                                // only for the first loop iteration when nothing was written yet
                                return errBadConnNoWrite
                        }</span>
                        <span class="cov0" title="0">mc.cleanup()
                        errLog.Print(err)</span>
                }
                <span class="cov0" title="0">return ErrInvalidConn</span>
        }
}

/******************************************************************************
*                           Initialization Process                            *
******************************************************************************/

// Handshake Initialization Packet
// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake
func (mc *mysqlConn) readHandshakePacket() (data []byte, plugin string, err error) <span class="cov8" title="1">{
        data, err = mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                // for init we can rewrite this to ErrBadConn for sql.Driver to retry, since
                // in connection initialization we don't risk retrying non-idempotent actions.
                if err == ErrInvalidConn </span><span class="cov0" title="0">{
                        return nil, "", driver.ErrBadConn
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">if data[0] == iERR </span><span class="cov0" title="0">{
                return nil, "", mc.handleErrorPacket(data)
        }</span>

        // protocol version [1 byte]
        <span class="cov8" title="1">if data[0] &lt; minProtocolVersion </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf(
                        "unsupported protocol version %d. Version %d or higher is required",
                        data[0],
                        minProtocolVersion,
                )
        }</span>

        // server version [null terminated string]
        // connection id [4 bytes]
        <span class="cov8" title="1">pos := 1 + bytes.IndexByte(data[1:], 0x00) + 1 + 4

        // first part of the password cipher [8 bytes]
        authData := data[pos : pos+8]

        // (filler) always 0x00 [1 byte]
        pos += 8 + 1

        // capability flags (lower 2 bytes) [2 bytes]
        mc.flags = clientFlag(binary.LittleEndian.Uint16(data[pos : pos+2]))
        if mc.flags&amp;clientProtocol41 == 0 </span><span class="cov0" title="0">{
                return nil, "", ErrOldProtocol
        }</span>
        <span class="cov8" title="1">if mc.flags&amp;clientSSL == 0 &amp;&amp; mc.cfg.tls != nil </span><span class="cov0" title="0">{
                if mc.cfg.TLSConfig == "preferred" </span><span class="cov0" title="0">{
                        mc.cfg.tls = nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, "", ErrNoTLS
                }</span>
        }
        <span class="cov8" title="1">pos += 2

        if len(data) &gt; pos </span><span class="cov8" title="1">{
                // character set [1 byte]
                // status flags [2 bytes]
                // capability flags (upper 2 bytes) [2 bytes]
                // length of auth-plugin-data [1 byte]
                // reserved (all [00]) [10 bytes]
                pos += 1 + 2 + 2 + 1 + 10

                // second part of the password cipher [mininum 13 bytes],
                // where len=MAX(13, length of auth-plugin-data - 8)
                //
                // The web documentation is ambiguous about the length. However,
                // according to mysql-5.7/sql/auth/sql_authentication.cc line 538,
                // the 13th byte is "\0 byte, terminating the second part of
                // a scramble". So the second part of the password cipher is
                // a NULL terminated string that's at least 13 bytes with the
                // last byte being NULL.
                //
                // The official Python library uses the fixed length 12
                // which seems to work but technically could have a hidden bug.
                authData = append(authData, data[pos:pos+12]...)
                pos += 13

                // EOF if version (&gt;= 5.5.7 and &lt; 5.5.10) or (&gt;= 5.6.0 and &lt; 5.6.2)
                // \NUL otherwise
                if end := bytes.IndexByte(data[pos:], 0x00); end != -1 </span><span class="cov8" title="1">{
                        plugin = string(data[pos : pos+end])
                }</span> else<span class="cov0" title="0"> {
                        plugin = string(data[pos:])
                }</span>

                // make a memory safe copy of the cipher slice
                <span class="cov8" title="1">var b [20]byte
                copy(b[:], authData)
                return b[:], plugin, nil</span>
        }

        // make a memory safe copy of the cipher slice
        <span class="cov0" title="0">var b [8]byte
        copy(b[:], authData)
        return b[:], plugin, nil</span>
}

// Client Authentication Packet
// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse
func (mc *mysqlConn) writeHandshakeResponsePacket(authResp []byte, plugin string) error <span class="cov8" title="1">{
        // Adjust client flags based on server support
        clientFlags := clientProtocol41 |
                clientSecureConn |
                clientLongPassword |
                clientTransactions |
                clientLocalFiles |
                clientPluginAuth |
                clientMultiResults |
                mc.flags&amp;clientLongFlag

        if mc.cfg.ClientFoundRows </span><span class="cov0" title="0">{
                clientFlags |= clientFoundRows
        }</span>

        // To enable TLS / SSL
        <span class="cov8" title="1">if mc.cfg.tls != nil </span><span class="cov0" title="0">{
                clientFlags |= clientSSL
        }</span>

        <span class="cov8" title="1">if mc.cfg.MultiStatements </span><span class="cov0" title="0">{
                clientFlags |= clientMultiStatements
        }</span>

        // encode length of the auth plugin data
        <span class="cov8" title="1">var authRespLEIBuf [9]byte
        authRespLen := len(authResp)
        authRespLEI := appendLengthEncodedInteger(authRespLEIBuf[:0], uint64(authRespLen))
        if len(authRespLEI) &gt; 1 </span><span class="cov0" title="0">{
                // if the length can not be written in 1 byte, it must be written as a
                // length encoded integer
                clientFlags |= clientPluginAuthLenEncClientData
        }</span>

        <span class="cov8" title="1">pktLen := 4 + 4 + 1 + 23 + len(mc.cfg.User) + 1 + len(authRespLEI) + len(authResp) + 21 + 1

        // To specify a db name
        if n := len(mc.cfg.DBName); n &gt; 0 </span><span class="cov8" title="1">{
                clientFlags |= clientConnectWithDB
                pktLen += n + 1
        }</span>

        // Calculate packet length and get buffer with that size
        <span class="cov8" title="1">data, err := mc.buf.takeSmallBuffer(pktLen + 4)
        if err != nil </span><span class="cov0" title="0">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // ClientFlags [32 bit]
        <span class="cov8" title="1">data[4] = byte(clientFlags)
        data[5] = byte(clientFlags &gt;&gt; 8)
        data[6] = byte(clientFlags &gt;&gt; 16)
        data[7] = byte(clientFlags &gt;&gt; 24)

        // MaxPacketSize [32 bit] (none)
        data[8] = 0x00
        data[9] = 0x00
        data[10] = 0x00
        data[11] = 0x00

        // Charset [1 byte]
        var found bool
        data[12], found = collations[mc.cfg.Collation]
        if !found </span><span class="cov0" title="0">{
                // Note possibility for false negatives:
                // could be triggered  although the collation is valid if the
                // collations map does not contain entries the server supports.
                return errors.New("unknown collation")
        }</span>

        // Filler [23 bytes] (all 0x00)
        <span class="cov8" title="1">pos := 13
        for ; pos &lt; 13+23; pos++ </span><span class="cov8" title="1">{
                data[pos] = 0
        }</span>

        // SSL Connection Request Packet
        // http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::SSLRequest
        <span class="cov8" title="1">if mc.cfg.tls != nil </span><span class="cov0" title="0">{
                // Send TLS / SSL request packet
                if err := mc.writePacket(data[:(4+4+1+23)+4]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Switch to TLS
                <span class="cov0" title="0">tlsConn := tls.Client(mc.netConn, mc.cfg.tls)
                if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">mc.rawConn = mc.netConn
                mc.netConn = tlsConn
                mc.buf.nc = tlsConn</span>
        }

        // User [null terminated string]
        <span class="cov8" title="1">if len(mc.cfg.User) &gt; 0 </span><span class="cov8" title="1">{
                pos += copy(data[pos:], mc.cfg.User)
        }</span>
        <span class="cov8" title="1">data[pos] = 0x00
        pos++

        // Auth Data [length encoded integer]
        pos += copy(data[pos:], authRespLEI)
        pos += copy(data[pos:], authResp)

        // Databasename [null terminated string]
        if len(mc.cfg.DBName) &gt; 0 </span><span class="cov8" title="1">{
                pos += copy(data[pos:], mc.cfg.DBName)
                data[pos] = 0x00
                pos++
        }</span>

        <span class="cov8" title="1">pos += copy(data[pos:], plugin)
        data[pos] = 0x00
        pos++

        // Send Auth packet
        return mc.writePacket(data[:pos])</span>
}

// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchResponse
func (mc *mysqlConn) writeAuthSwitchPacket(authData []byte) error <span class="cov0" title="0">{
        pktLen := 4 + len(authData)
        data, err := mc.buf.takeSmallBuffer(pktLen)
        if err != nil </span><span class="cov0" title="0">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // Add the auth data [EOF]
        <span class="cov0" title="0">copy(data[4:], authData)
        return mc.writePacket(data)</span>
}

/******************************************************************************
*                             Command Packets                                 *
******************************************************************************/

func (mc *mysqlConn) writeCommandPacket(command byte) error <span class="cov8" title="1">{
        // Reset Packet Sequence
        mc.sequence = 0

        data, err := mc.buf.takeSmallBuffer(4 + 1)
        if err != nil </span><span class="cov8" title="1">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // Add command byte
        <span class="cov8" title="1">data[4] = command

        // Send CMD packet
        return mc.writePacket(data)</span>
}

func (mc *mysqlConn) writeCommandPacketStr(command byte, arg string) error <span class="cov8" title="1">{
        // Reset Packet Sequence
        mc.sequence = 0

        pktLen := 1 + len(arg)
        data, err := mc.buf.takeBuffer(pktLen + 4)
        if err != nil </span><span class="cov8" title="1">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // Add command byte
        <span class="cov8" title="1">data[4] = command

        // Add arg
        copy(data[5:], arg)

        // Send CMD packet
        return mc.writePacket(data)</span>
}

func (mc *mysqlConn) writeCommandPacketUint32(command byte, arg uint32) error <span class="cov8" title="1">{
        // Reset Packet Sequence
        mc.sequence = 0

        data, err := mc.buf.takeSmallBuffer(4 + 1 + 4)
        if err != nil </span><span class="cov8" title="1">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // Add command byte
        <span class="cov8" title="1">data[4] = command

        // Add arg [32 bit]
        data[5] = byte(arg)
        data[6] = byte(arg &gt;&gt; 8)
        data[7] = byte(arg &gt;&gt; 16)
        data[8] = byte(arg &gt;&gt; 24)

        // Send CMD packet
        return mc.writePacket(data)</span>
}

/******************************************************************************
*                              Result Packets                                 *
******************************************************************************/

func (mc *mysqlConn) readAuthResult() ([]byte, string, error) <span class="cov8" title="1">{
        data, err := mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        // packet indicator
        <span class="cov8" title="1">switch data[0] </span>{

        case iOK:<span class="cov8" title="1">
                return nil, "", mc.handleOkPacket(data)</span>

        case iAuthMoreData:<span class="cov0" title="0">
                return data[1:], "", err</span>

        case iEOF:<span class="cov0" title="0">
                if len(data) == 1 </span><span class="cov0" title="0">{
                        // https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::OldAuthSwitchRequest
                        return nil, "mysql_old_password", nil
                }</span>
                <span class="cov0" title="0">pluginEndIndex := bytes.IndexByte(data, 0x00)
                if pluginEndIndex &lt; 0 </span><span class="cov0" title="0">{
                        return nil, "", ErrMalformPkt
                }</span>
                <span class="cov0" title="0">plugin := string(data[1:pluginEndIndex])
                authData := data[pluginEndIndex+1:]
                return authData, plugin, nil</span>

        default:<span class="cov0" title="0"> // Error otherwise
                return nil, "", mc.handleErrorPacket(data)</span>
        }
}

// Returns error if Packet is not an 'Result OK'-Packet
func (mc *mysqlConn) readResultOK() error <span class="cov0" title="0">{
        data, err := mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if data[0] == iOK </span><span class="cov0" title="0">{
                return mc.handleOkPacket(data)
        }</span>
        <span class="cov0" title="0">return mc.handleErrorPacket(data)</span>
}

// Result Set Header Packet
// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-ProtocolText::Resultset
func (mc *mysqlConn) readResultSetHeaderPacket() (int, error) <span class="cov8" title="1">{
        data, err := mc.readPacket()
        if err == nil </span><span class="cov8" title="1">{
                switch data[0] </span>{

                case iOK:<span class="cov8" title="1">
                        return 0, mc.handleOkPacket(data)</span>

                case iERR:<span class="cov0" title="0">
                        return 0, mc.handleErrorPacket(data)</span>

                case iLocalInFile:<span class="cov0" title="0">
                        return 0, mc.handleInFileRequest(string(data[1:]))</span>
                }

                // column count
                <span class="cov8" title="1">num, _, n := readLengthEncodedInteger(data)
                if n-len(data) == 0 </span><span class="cov8" title="1">{
                        return int(num), nil
                }</span>

                <span class="cov0" title="0">return 0, ErrMalformPkt</span>
        }
        <span class="cov0" title="0">return 0, err</span>
}

// Error Packet
// http://dev.mysql.com/doc/internals/en/generic-response-packets.html#packet-ERR_Packet
func (mc *mysqlConn) handleErrorPacket(data []byte) error <span class="cov0" title="0">{
        if data[0] != iERR </span><span class="cov0" title="0">{
                return ErrMalformPkt
        }</span>

        // 0xff [1 byte]

        // Error Number [16 bit uint]
        <span class="cov0" title="0">errno := binary.LittleEndian.Uint16(data[1:3])

        // 1792: ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION
        // 1290: ER_OPTION_PREVENTS_STATEMENT (returned by Aurora during failover)
        if (errno == 1792 || errno == 1290) &amp;&amp; mc.cfg.RejectReadOnly </span><span class="cov0" title="0">{
                // Oops; we are connected to a read-only connection, and won't be able
                // to issue any write statements. Since RejectReadOnly is configured,
                // we throw away this connection hoping this one would have write
                // permission. This is specifically for a possible race condition
                // during failover (e.g. on AWS Aurora). See README.md for more.
                //
                // We explicitly close the connection before returning
                // driver.ErrBadConn to ensure that `database/sql` purges this
                // connection and initiates a new one for next statement next time.
                mc.Close()
                return driver.ErrBadConn
        }</span>

        <span class="cov0" title="0">pos := 3

        // SQL State [optional: # + 5bytes string]
        if data[3] == 0x23 </span><span class="cov0" title="0">{
                //sqlstate := string(data[4 : 4+5])
                pos = 9
        }</span>

        // Error Message [string]
        <span class="cov0" title="0">return &amp;MySQLError{
                Number:  errno,
                Message: string(data[pos:]),
        }</span>
}

func readStatus(b []byte) statusFlag <span class="cov8" title="1">{
        return statusFlag(b[0]) | statusFlag(b[1])&lt;&lt;8
}</span>

// Ok Packet
// http://dev.mysql.com/doc/internals/en/generic-response-packets.html#packet-OK_Packet
func (mc *mysqlConn) handleOkPacket(data []byte) error <span class="cov8" title="1">{
        var n, m int

        // 0x00 [1 byte]

        // Affected rows [Length Coded Binary]
        mc.affectedRows, _, n = readLengthEncodedInteger(data[1:])

        // Insert id [Length Coded Binary]
        mc.insertId, _, m = readLengthEncodedInteger(data[1+n:])

        // server_status [2 bytes]
        mc.status = readStatus(data[1+n+m : 1+n+m+2])
        if mc.status&amp;statusMoreResultsExists != 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // warning count [2 bytes]

        <span class="cov8" title="1">return nil</span>
}

// Read Packets as Field Packets until EOF-Packet or an Error appears
// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-Protocol::ColumnDefinition41
func (mc *mysqlConn) readColumns(count int) ([]mysqlField, error) <span class="cov8" title="1">{
        columns := make([]mysqlField, count)

        for i := 0; ; i++ </span><span class="cov8" title="1">{
                data, err := mc.readPacket()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // EOF Packet
                <span class="cov8" title="1">if data[0] == iEOF &amp;&amp; (len(data) == 5 || len(data) == 1) </span><span class="cov8" title="1">{
                        if i == count </span><span class="cov8" title="1">{
                                return columns, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("column count mismatch n:%d len:%d", count, len(columns))</span>
                }

                // Catalog
                <span class="cov8" title="1">pos, err := skipLengthEncodedString(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Database [len coded string]
                <span class="cov8" title="1">n, err := skipLengthEncodedString(data[pos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">pos += n

                // Table [len coded string]
                if mc.cfg.ColumnsWithAlias </span><span class="cov0" title="0">{
                        tableName, _, n, err := readLengthEncodedString(data[pos:])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">pos += n
                        columns[i].tableName = string(tableName)</span>
                } else<span class="cov8" title="1"> {
                        n, err = skipLengthEncodedString(data[pos:])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pos += n</span>
                }

                // Original table [len coded string]
                <span class="cov8" title="1">n, err = skipLengthEncodedString(data[pos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">pos += n

                // Name [len coded string]
                name, _, n, err := readLengthEncodedString(data[pos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">columns[i].name = string(name)
                pos += n

                // Original name [len coded string]
                n, err = skipLengthEncodedString(data[pos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">pos += n

                // Filler [uint8]
                pos++

                // Charset [charset, collation uint8]
                columns[i].charSet = data[pos]
                pos += 2

                // Length [uint32]
                columns[i].length = binary.LittleEndian.Uint32(data[pos : pos+4])
                pos += 4

                // Field type [uint8]
                columns[i].fieldType = fieldType(data[pos])
                pos++

                // Flags [uint16]
                columns[i].flags = fieldFlag(binary.LittleEndian.Uint16(data[pos : pos+2]))
                pos += 2

                // Decimals [uint8]
                columns[i].decimals = data[pos]</span>
                //pos++

                // Default value [len coded binary]
                //if pos &lt; len(data) {
                //        defaultVal, _, err = bytesToLengthCodedBinary(data[pos:])
                //}
        }
}

// Read Packets as Field Packets until EOF-Packet or an Error appears
// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-ProtocolText::ResultsetRow
func (rows *textRows) readRow(dest []driver.Value) error <span class="cov8" title="1">{
        mc := rows.mc

        if rows.rs.done </span><span class="cov0" title="0">{
                return io.EOF
        }</span>

        <span class="cov8" title="1">data, err := mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // EOF Packet
        <span class="cov8" title="1">if data[0] == iEOF &amp;&amp; len(data) == 5 </span><span class="cov8" title="1">{
                // server_status [2 bytes]
                rows.mc.status = readStatus(data[3:])
                rows.rs.done = true
                if !rows.HasNextResultSet() </span><span class="cov8" title="1">{
                        rows.mc = nil
                }</span>
                <span class="cov8" title="1">return io.EOF</span>
        }
        <span class="cov8" title="1">if data[0] == iERR </span><span class="cov0" title="0">{
                rows.mc = nil
                return mc.handleErrorPacket(data)
        }</span>

        // RowSet Packet
        <span class="cov8" title="1">var n int
        var isNull bool
        pos := 0

        for i := range dest </span><span class="cov8" title="1">{
                // Read bytes and convert to string
                dest[i], isNull, n, err = readLengthEncodedString(data[pos:])
                pos += n
                if err == nil </span><span class="cov8" title="1">{
                        if !isNull </span><span class="cov8" title="1">{
                                if !mc.parseTime </span><span class="cov8" title="1">{
                                        continue</span>
                                } else<span class="cov0" title="0"> {
                                        switch rows.rs.columns[i].fieldType </span>{
                                        case fieldTypeTimestamp, fieldTypeDateTime,
                                                fieldTypeDate, fieldTypeNewDate:<span class="cov0" title="0">
                                                dest[i], err = parseDateTime(
                                                        string(dest[i].([]byte)),
                                                        mc.cfg.Loc,
                                                )
                                                if err == nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        default:<span class="cov0" title="0">
                                                continue</span>
                                        }
                                }

                        } else<span class="cov8" title="1"> {
                                dest[i] = nil
                                continue</span>
                        }
                }
                <span class="cov0" title="0">return err</span> // err != nil
        }

        <span class="cov8" title="1">return nil</span>
}

// Reads Packets until EOF-Packet or an Error appears. Returns count of Packets read
func (mc *mysqlConn) readUntilEOF() error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                data, err := mc.readPacket()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">switch data[0] </span>{
                case iERR:<span class="cov0" title="0">
                        return mc.handleErrorPacket(data)</span>
                case iEOF:<span class="cov8" title="1">
                        if len(data) == 5 </span><span class="cov8" title="1">{
                                mc.status = readStatus(data[3:])
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
        }
}

/******************************************************************************
*                           Prepared Statements                               *
******************************************************************************/

// Prepare Result Packets
// http://dev.mysql.com/doc/internals/en/com-stmt-prepare-response.html
func (stmt *mysqlStmt) readPrepareResultPacket() (uint16, error) <span class="cov8" title="1">{
        data, err := stmt.mc.readPacket()
        if err == nil </span><span class="cov8" title="1">{
                // packet indicator [1 byte]
                if data[0] != iOK </span><span class="cov0" title="0">{
                        return 0, stmt.mc.handleErrorPacket(data)
                }</span>

                // statement id [4 bytes]
                <span class="cov8" title="1">stmt.id = binary.LittleEndian.Uint32(data[1:5])

                // Column count [16 bit uint]
                columnCount := binary.LittleEndian.Uint16(data[5:7])

                // Param count [16 bit uint]
                stmt.paramCount = int(binary.LittleEndian.Uint16(data[7:9]))

                // Reserved [8 bit]

                // Warning count [16 bit uint]

                return columnCount, nil</span>
        }
        <span class="cov0" title="0">return 0, err</span>
}

// http://dev.mysql.com/doc/internals/en/com-stmt-send-long-data.html
func (stmt *mysqlStmt) writeCommandLongData(paramID int, arg []byte) error <span class="cov0" title="0">{
        maxLen := stmt.mc.maxAllowedPacket - 1
        pktLen := maxLen

        // After the header (bytes 0-3) follows before the data:
        // 1 byte command
        // 4 bytes stmtID
        // 2 bytes paramID
        const dataOffset = 1 + 4 + 2

        // Cannot use the write buffer since
        // a) the buffer is too small
        // b) it is in use
        data := make([]byte, 4+1+4+2+len(arg))

        copy(data[4+dataOffset:], arg)

        for argLen := len(arg); argLen &gt; 0; argLen -= pktLen - dataOffset </span><span class="cov0" title="0">{
                if dataOffset+argLen &lt; maxLen </span><span class="cov0" title="0">{
                        pktLen = dataOffset + argLen
                }</span>

                <span class="cov0" title="0">stmt.mc.sequence = 0
                // Add command byte [1 byte]
                data[4] = comStmtSendLongData

                // Add stmtID [32 bit]
                data[5] = byte(stmt.id)
                data[6] = byte(stmt.id &gt;&gt; 8)
                data[7] = byte(stmt.id &gt;&gt; 16)
                data[8] = byte(stmt.id &gt;&gt; 24)

                // Add paramID [16 bit]
                data[9] = byte(paramID)
                data[10] = byte(paramID &gt;&gt; 8)

                // Send CMD packet
                err := stmt.mc.writePacket(data[:4+pktLen])
                if err == nil </span><span class="cov0" title="0">{
                        data = data[pktLen-dataOffset:]
                        continue</span>
                }
                <span class="cov0" title="0">return err</span>

        }

        // Reset Packet Sequence
        <span class="cov0" title="0">stmt.mc.sequence = 0
        return nil</span>
}

// Execute Prepared Statement
// http://dev.mysql.com/doc/internals/en/com-stmt-execute.html
func (stmt *mysqlStmt) writeExecutePacket(args []driver.Value) error <span class="cov8" title="1">{
        if len(args) != stmt.paramCount </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "argument count mismatch (got: %d; has: %d)",
                        len(args),
                        stmt.paramCount,
                )
        }</span>

        <span class="cov8" title="1">const minPktLen = 4 + 1 + 4 + 1 + 4
        mc := stmt.mc

        // Determine threshold dynamically to avoid packet size shortage.
        longDataSize := mc.maxAllowedPacket / (stmt.paramCount + 1)
        if longDataSize &lt; 64 </span><span class="cov0" title="0">{
                longDataSize = 64
        }</span>

        // Reset packet-sequence
        <span class="cov8" title="1">mc.sequence = 0

        var data []byte
        var err error

        if len(args) == 0 </span><span class="cov0" title="0">{
                data, err = mc.buf.takeBuffer(minPktLen)
        }</span> else<span class="cov8" title="1"> {
                data, err = mc.buf.takeCompleteBuffer()
                // In this case the len(data) == cap(data) which is used to optimise the flow below.
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // command [1 byte]
        <span class="cov8" title="1">data[4] = comStmtExecute

        // statement_id [4 bytes]
        data[5] = byte(stmt.id)
        data[6] = byte(stmt.id &gt;&gt; 8)
        data[7] = byte(stmt.id &gt;&gt; 16)
        data[8] = byte(stmt.id &gt;&gt; 24)

        // flags (0: CURSOR_TYPE_NO_CURSOR) [1 byte]
        data[9] = 0x00

        // iteration_count (uint32(1)) [4 bytes]
        data[10] = 0x01
        data[11] = 0x00
        data[12] = 0x00
        data[13] = 0x00

        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                pos := minPktLen

                var nullMask []byte
                if maskLen, typesLen := (len(args)+7)/8, 1+2*len(args); pos+maskLen+typesLen &gt;= cap(data) </span><span class="cov0" title="0">{
                        // buffer has to be extended but we don't know by how much so
                        // we depend on append after all data with known sizes fit.
                        // We stop at that because we deal with a lot of columns here
                        // which makes the required allocation size hard to guess.
                        tmp := make([]byte, pos+maskLen+typesLen)
                        copy(tmp[:pos], data[:pos])
                        data = tmp
                        nullMask = data[pos : pos+maskLen]
                        // No need to clean nullMask as make ensures that.
                        pos += maskLen
                }</span> else<span class="cov8" title="1"> {
                        nullMask = data[pos : pos+maskLen]
                        for i := range nullMask </span><span class="cov8" title="1">{
                                nullMask[i] = 0
                        }</span>
                        <span class="cov8" title="1">pos += maskLen</span>
                }

                // newParameterBoundFlag 1 [1 byte]
                <span class="cov8" title="1">data[pos] = 0x01
                pos++

                // type of each parameter [len(args)*2 bytes]
                paramTypes := data[pos:]
                pos += len(args) * 2

                // value of each parameter [n bytes]
                paramValues := data[pos:pos]
                valuesCap := cap(paramValues)

                for i, arg := range args </span><span class="cov8" title="1">{
                        // build NULL-bitmap
                        if arg == nil </span><span class="cov0" title="0">{
                                nullMask[i/8] |= 1 &lt;&lt; (uint(i) &amp; 7)
                                paramTypes[i+i] = byte(fieldTypeNULL)
                                paramTypes[i+i+1] = 0x00
                                continue</span>
                        }

                        <span class="cov8" title="1">if v, ok := arg.(json.RawMessage); ok </span><span class="cov0" title="0">{
                                arg = []byte(v)
                        }</span>
                        // cache types and values
                        <span class="cov8" title="1">switch v := arg.(type) </span>{
                        case int64:<span class="cov0" title="0">
                                paramTypes[i+i] = byte(fieldTypeLongLong)
                                paramTypes[i+i+1] = 0x00

                                if cap(paramValues)-len(paramValues)-8 &gt;= 0 </span><span class="cov0" title="0">{
                                        paramValues = paramValues[:len(paramValues)+8]
                                        binary.LittleEndian.PutUint64(
                                                paramValues[len(paramValues)-8:],
                                                uint64(v),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        paramValues = append(paramValues,
                                                uint64ToBytes(uint64(v))...,
                                        )
                                }</span>

                        case uint64:<span class="cov0" title="0">
                                paramTypes[i+i] = byte(fieldTypeLongLong)
                                paramTypes[i+i+1] = 0x80 // type is unsigned

                                if cap(paramValues)-len(paramValues)-8 &gt;= 0 </span><span class="cov0" title="0">{
                                        paramValues = paramValues[:len(paramValues)+8]
                                        binary.LittleEndian.PutUint64(
                                                paramValues[len(paramValues)-8:],
                                                uint64(v),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        paramValues = append(paramValues,
                                                uint64ToBytes(uint64(v))...,
                                        )
                                }</span>

                        case float64:<span class="cov0" title="0">
                                paramTypes[i+i] = byte(fieldTypeDouble)
                                paramTypes[i+i+1] = 0x00

                                if cap(paramValues)-len(paramValues)-8 &gt;= 0 </span><span class="cov0" title="0">{
                                        paramValues = paramValues[:len(paramValues)+8]
                                        binary.LittleEndian.PutUint64(
                                                paramValues[len(paramValues)-8:],
                                                math.Float64bits(v),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        paramValues = append(paramValues,
                                                uint64ToBytes(math.Float64bits(v))...,
                                        )
                                }</span>

                        case bool:<span class="cov0" title="0">
                                paramTypes[i+i] = byte(fieldTypeTiny)
                                paramTypes[i+i+1] = 0x00

                                if v </span><span class="cov0" title="0">{
                                        paramValues = append(paramValues, 0x01)
                                }</span> else<span class="cov0" title="0"> {
                                        paramValues = append(paramValues, 0x00)
                                }</span>

                        case []byte:<span class="cov0" title="0">
                                // Common case (non-nil value) first
                                if v != nil </span><span class="cov0" title="0">{
                                        paramTypes[i+i] = byte(fieldTypeString)
                                        paramTypes[i+i+1] = 0x00

                                        if len(v) &lt; longDataSize </span><span class="cov0" title="0">{
                                                paramValues = appendLengthEncodedInteger(paramValues,
                                                        uint64(len(v)),
                                                )
                                                paramValues = append(paramValues, v...)
                                        }</span> else<span class="cov0" title="0"> {
                                                if err := stmt.writeCommandLongData(i, v); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                        <span class="cov0" title="0">continue</span>
                                }

                                // Handle []byte(nil) as a NULL value
                                <span class="cov0" title="0">nullMask[i/8] |= 1 &lt;&lt; (uint(i) &amp; 7)
                                paramTypes[i+i] = byte(fieldTypeNULL)
                                paramTypes[i+i+1] = 0x00</span>

                        case string:<span class="cov8" title="1">
                                paramTypes[i+i] = byte(fieldTypeString)
                                paramTypes[i+i+1] = 0x00

                                if len(v) &lt; longDataSize </span><span class="cov8" title="1">{
                                        paramValues = appendLengthEncodedInteger(paramValues,
                                                uint64(len(v)),
                                        )
                                        paramValues = append(paramValues, v...)
                                }</span> else<span class="cov0" title="0"> {
                                        if err := stmt.writeCommandLongData(i, []byte(v)); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }

                        case time.Time:<span class="cov0" title="0">
                                paramTypes[i+i] = byte(fieldTypeString)
                                paramTypes[i+i+1] = 0x00

                                var a [64]byte
                                var b = a[:0]

                                if v.IsZero() </span><span class="cov0" title="0">{
                                        b = append(b, "0000-00-00"...)
                                }</span> else<span class="cov0" title="0"> {
                                        b = v.In(mc.cfg.Loc).AppendFormat(b, timeFormat)
                                }</span>

                                <span class="cov0" title="0">paramValues = appendLengthEncodedInteger(paramValues,
                                        uint64(len(b)),
                                )
                                paramValues = append(paramValues, b...)</span>

                        default:<span class="cov0" title="0">
                                return fmt.Errorf("cannot convert type: %T", arg)</span>
                        }
                }

                // Check if param values exceeded the available buffer
                // In that case we must build the data packet with the new values buffer
                <span class="cov8" title="1">if valuesCap != cap(paramValues) </span><span class="cov0" title="0">{
                        data = append(data[:pos], paramValues...)
                        if err = mc.buf.store(data); err != nil </span><span class="cov0" title="0">{
                                errLog.Print(err)
                                return errBadConnNoWrite
                        }</span>
                }

                <span class="cov8" title="1">pos += len(paramValues)
                data = data[:pos]</span>
        }

        <span class="cov8" title="1">return mc.writePacket(data)</span>
}

func (mc *mysqlConn) discardResults() error <span class="cov8" title="1">{
        for mc.status&amp;statusMoreResultsExists != 0 </span><span class="cov0" title="0">{
                resLen, err := mc.readResultSetHeaderPacket()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if resLen &gt; 0 </span><span class="cov0" title="0">{
                        // columns
                        if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // rows
                        <span class="cov0" title="0">if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// http://dev.mysql.com/doc/internals/en/binary-protocol-resultset-row.html
func (rows *binaryRows) readRow(dest []driver.Value) error <span class="cov8" title="1">{
        data, err := rows.mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // packet indicator [1 byte]
        <span class="cov8" title="1">if data[0] != iOK </span><span class="cov8" title="1">{
                // EOF Packet
                if data[0] == iEOF &amp;&amp; len(data) == 5 </span><span class="cov8" title="1">{
                        rows.mc.status = readStatus(data[3:])
                        rows.rs.done = true
                        if !rows.HasNextResultSet() </span><span class="cov8" title="1">{
                                rows.mc = nil
                        }</span>
                        <span class="cov8" title="1">return io.EOF</span>
                }
                <span class="cov0" title="0">mc := rows.mc
                rows.mc = nil

                // Error otherwise
                return mc.handleErrorPacket(data)</span>
        }

        // NULL-bitmap,  [(column-count + 7 + 2) / 8 bytes]
        <span class="cov8" title="1">pos := 1 + (len(dest)+7+2)&gt;&gt;3
        nullMask := data[1:pos]

        for i := range dest </span><span class="cov8" title="1">{
                // Field is NULL
                // (byte &gt;&gt; bit-pos) % 2 == 1
                if ((nullMask[(i+2)&gt;&gt;3] &gt;&gt; uint((i+2)&amp;7)) &amp; 1) == 1 </span><span class="cov8" title="1">{
                        dest[i] = nil
                        continue</span>
                }

                // Convert to byte-coded string
                <span class="cov8" title="1">switch rows.rs.columns[i].fieldType </span>{
                case fieldTypeNULL:<span class="cov0" title="0">
                        dest[i] = nil
                        continue</span>

                // Numeric Types
                case fieldTypeTiny:<span class="cov0" title="0">
                        if rows.rs.columns[i].flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                dest[i] = int64(data[pos])
                        }</span> else<span class="cov0" title="0"> {
                                dest[i] = int64(int8(data[pos]))
                        }</span>
                        <span class="cov0" title="0">pos++
                        continue</span>

                case fieldTypeShort, fieldTypeYear:<span class="cov0" title="0">
                        if rows.rs.columns[i].flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                dest[i] = int64(binary.LittleEndian.Uint16(data[pos : pos+2]))
                        }</span> else<span class="cov0" title="0"> {
                                dest[i] = int64(int16(binary.LittleEndian.Uint16(data[pos : pos+2])))
                        }</span>
                        <span class="cov0" title="0">pos += 2
                        continue</span>

                case fieldTypeInt24, fieldTypeLong:<span class="cov0" title="0">
                        if rows.rs.columns[i].flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                dest[i] = int64(binary.LittleEndian.Uint32(data[pos : pos+4]))
                        }</span> else<span class="cov0" title="0"> {
                                dest[i] = int64(int32(binary.LittleEndian.Uint32(data[pos : pos+4])))
                        }</span>
                        <span class="cov0" title="0">pos += 4
                        continue</span>

                case fieldTypeLongLong:<span class="cov8" title="1">
                        if rows.rs.columns[i].flags&amp;flagUnsigned != 0 </span><span class="cov8" title="1">{
                                val := binary.LittleEndian.Uint64(data[pos : pos+8])
                                if val &gt; math.MaxInt64 </span><span class="cov0" title="0">{
                                        dest[i] = uint64ToString(val)
                                }</span> else<span class="cov8" title="1"> {
                                        dest[i] = int64(val)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                dest[i] = int64(binary.LittleEndian.Uint64(data[pos : pos+8]))
                        }</span>
                        <span class="cov8" title="1">pos += 8
                        continue</span>

                case fieldTypeFloat:<span class="cov0" title="0">
                        dest[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[pos : pos+4]))
                        pos += 4
                        continue</span>

                case fieldTypeDouble:<span class="cov8" title="1">
                        dest[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[pos : pos+8]))
                        pos += 8
                        continue</span>

                // Length coded Binary Strings
                case fieldTypeDecimal, fieldTypeNewDecimal, fieldTypeVarChar,
                        fieldTypeBit, fieldTypeEnum, fieldTypeSet, fieldTypeTinyBLOB,
                        fieldTypeMediumBLOB, fieldTypeLongBLOB, fieldTypeBLOB,
                        fieldTypeVarString, fieldTypeString, fieldTypeGeometry, fieldTypeJSON:<span class="cov8" title="1">
                        var isNull bool
                        var n int
                        dest[i], isNull, n, err = readLengthEncodedString(data[pos:])
                        pos += n
                        if err == nil </span><span class="cov8" title="1">{
                                if !isNull </span><span class="cov8" title="1">{
                                        continue</span>
                                } else<span class="cov0" title="0"> {
                                        dest[i] = nil
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">return err</span>

                case
                        fieldTypeDate, fieldTypeNewDate, // Date YYYY-MM-DD
                        fieldTypeTime,                         // Time [-][H]HH:MM:SS[.fractal]
                        fieldTypeTimestamp, fieldTypeDateTime:<span class="cov0" title="0"> // Timestamp YYYY-MM-DD HH:MM:SS[.fractal]

                        num, isNull, n := readLengthEncodedInteger(data[pos:])
                        pos += n

                        switch </span>{
                        case isNull:<span class="cov0" title="0">
                                dest[i] = nil
                                continue</span>
                        case rows.rs.columns[i].fieldType == fieldTypeTime:<span class="cov0" title="0">
                                // database/sql does not support an equivalent to TIME, return a string
                                var dstlen uint8
                                switch decimals := rows.rs.columns[i].decimals; decimals </span>{
                                case 0x00, 0x1f:<span class="cov0" title="0">
                                        dstlen = 8</span>
                                case 1, 2, 3, 4, 5, 6:<span class="cov0" title="0">
                                        dstlen = 8 + 1 + decimals</span>
                                default:<span class="cov0" title="0">
                                        return fmt.Errorf(
                                                "protocol error, illegal decimals value %d",
                                                rows.rs.columns[i].decimals,
                                        )</span>
                                }
                                <span class="cov0" title="0">dest[i], err = formatBinaryTime(data[pos:pos+int(num)], dstlen)</span>
                        case rows.mc.parseTime:<span class="cov0" title="0">
                                dest[i], err = parseBinaryDateTime(num, data[pos:], rows.mc.cfg.Loc)</span>
                        default:<span class="cov0" title="0">
                                var dstlen uint8
                                if rows.rs.columns[i].fieldType == fieldTypeDate </span><span class="cov0" title="0">{
                                        dstlen = 10
                                }</span> else<span class="cov0" title="0"> {
                                        switch decimals := rows.rs.columns[i].decimals; decimals </span>{
                                        case 0x00, 0x1f:<span class="cov0" title="0">
                                                dstlen = 19</span>
                                        case 1, 2, 3, 4, 5, 6:<span class="cov0" title="0">
                                                dstlen = 19 + 1 + decimals</span>
                                        default:<span class="cov0" title="0">
                                                return fmt.Errorf(
                                                        "protocol error, illegal decimals value %d",
                                                        rows.rs.columns[i].decimals,
                                                )</span>
                                        }
                                }
                                <span class="cov0" title="0">dest[i], err = formatBinaryDateTime(data[pos:pos+int(num)], dstlen)</span>
                        }

                        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                                pos += int(num)
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                return err
                        }</span>

                // Please report if this happens!
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown field type %d", rows.rs.columns[i].fieldType)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2012 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

type mysqlResult struct {
        affectedRows int64
        insertId     int64
}

func (res *mysqlResult) LastInsertId() (int64, error) <span class="cov0" title="0">{
        return res.insertId, nil
}</span>

func (res *mysqlResult) RowsAffected() (int64, error) <span class="cov8" title="1">{
        return res.affectedRows, nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2012 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "database/sql/driver"
        "io"
        "math"
        "reflect"
)

type resultSet struct {
        columns     []mysqlField
        columnNames []string
        done        bool
}

type mysqlRows struct {
        mc     *mysqlConn
        rs     resultSet
        finish func()
}

type binaryRows struct {
        mysqlRows
}

type textRows struct {
        mysqlRows
}

func (rows *mysqlRows) Columns() []string <span class="cov8" title="1">{
        if rows.rs.columnNames != nil </span><span class="cov8" title="1">{
                return rows.rs.columnNames
        }</span>

        <span class="cov8" title="1">columns := make([]string, len(rows.rs.columns))
        if rows.mc != nil &amp;&amp; rows.mc.cfg.ColumnsWithAlias </span><span class="cov0" title="0">{
                for i := range columns </span><span class="cov0" title="0">{
                        if tableName := rows.rs.columns[i].tableName; len(tableName) &gt; 0 </span><span class="cov0" title="0">{
                                columns[i] = tableName + "." + rows.rs.columns[i].name
                        }</span> else<span class="cov0" title="0"> {
                                columns[i] = rows.rs.columns[i].name
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for i := range columns </span><span class="cov8" title="1">{
                        columns[i] = rows.rs.columns[i].name
                }</span>
        }

        <span class="cov8" title="1">rows.rs.columnNames = columns
        return columns</span>
}

func (rows *mysqlRows) ColumnTypeDatabaseTypeName(i int) string <span class="cov0" title="0">{
        return rows.rs.columns[i].typeDatabaseName()
}</span>

// func (rows *mysqlRows) ColumnTypeLength(i int) (length int64, ok bool) {
//         return int64(rows.rs.columns[i].length), true
// }

func (rows *mysqlRows) ColumnTypeNullable(i int) (nullable, ok bool) <span class="cov0" title="0">{
        return rows.rs.columns[i].flags&amp;flagNotNULL == 0, true
}</span>

func (rows *mysqlRows) ColumnTypePrecisionScale(i int) (int64, int64, bool) <span class="cov0" title="0">{
        column := rows.rs.columns[i]
        decimals := int64(column.decimals)

        switch column.fieldType </span>{
        case fieldTypeDecimal, fieldTypeNewDecimal:<span class="cov0" title="0">
                if decimals &gt; 0 </span><span class="cov0" title="0">{
                        return int64(column.length) - 2, decimals, true
                }</span>
                <span class="cov0" title="0">return int64(column.length) - 1, decimals, true</span>
        case fieldTypeTimestamp, fieldTypeDateTime, fieldTypeTime:<span class="cov0" title="0">
                return decimals, decimals, true</span>
        case fieldTypeFloat, fieldTypeDouble:<span class="cov0" title="0">
                if decimals == 0x1f </span><span class="cov0" title="0">{
                        return math.MaxInt64, math.MaxInt64, true
                }</span>
                <span class="cov0" title="0">return math.MaxInt64, decimals, true</span>
        }

        <span class="cov0" title="0">return 0, 0, false</span>
}

func (rows *mysqlRows) ColumnTypeScanType(i int) reflect.Type <span class="cov0" title="0">{
        return rows.rs.columns[i].scanType()
}</span>

func (rows *mysqlRows) Close() (err error) <span class="cov8" title="1">{
        if f := rows.finish; f != nil </span><span class="cov8" title="1">{
                f()
                rows.finish = nil
        }</span>

        <span class="cov8" title="1">mc := rows.mc
        if mc == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if err := mc.error(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // flip the buffer for this connection if we need to drain it.
        // note that for a successful query (i.e. one where rows.next()
        // has been called until it returns false), `rows.mc` will be nil
        // by the time the user calls `(*Rows).Close`, so we won't reach this
        // see: https://github.com/golang/go/commit/651ddbdb5056ded455f47f9c494c67b389622a47
        <span class="cov8" title="1">mc.buf.flip()

        // Remove unread packets from stream
        if !rows.rs.done </span><span class="cov8" title="1">{
                err = mc.readUntilEOF()
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                if err = mc.discardResults(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">rows.mc = nil
        return err</span>
}

func (rows *mysqlRows) HasNextResultSet() (b bool) <span class="cov8" title="1">{
        if rows.mc == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return rows.mc.status&amp;statusMoreResultsExists != 0</span>
}

func (rows *mysqlRows) nextResultSet() (int, error) <span class="cov0" title="0">{
        if rows.mc == nil </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">if err := rows.mc.error(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Remove unread packets from stream
        <span class="cov0" title="0">if !rows.rs.done </span><span class="cov0" title="0">{
                if err := rows.mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">rows.rs.done = true</span>
        }

        <span class="cov0" title="0">if !rows.HasNextResultSet() </span><span class="cov0" title="0">{
                rows.mc = nil
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">rows.rs = resultSet{}
        return rows.mc.readResultSetHeaderPacket()</span>
}

func (rows *mysqlRows) nextNotEmptyResultSet() (int, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                resLen, err := rows.nextResultSet()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">if resLen &gt; 0 </span><span class="cov0" title="0">{
                        return resLen, nil
                }</span>

                <span class="cov0" title="0">rows.rs.done = true</span>
        }
}

func (rows *binaryRows) NextResultSet() error <span class="cov0" title="0">{
        resLen, err := rows.nextNotEmptyResultSet()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rows.rs.columns, err = rows.mc.readColumns(resLen)
        return err</span>
}

func (rows *binaryRows) Next(dest []driver.Value) error <span class="cov8" title="1">{
        if mc := rows.mc; mc != nil </span><span class="cov8" title="1">{
                if err := mc.error(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Fetch next row from stream
                <span class="cov8" title="1">return rows.readRow(dest)</span>
        }
        <span class="cov0" title="0">return io.EOF</span>
}

func (rows *textRows) NextResultSet() (err error) <span class="cov0" title="0">{
        resLen, err := rows.nextNotEmptyResultSet()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rows.rs.columns, err = rows.mc.readColumns(resLen)
        return err</span>
}

func (rows *textRows) Next(dest []driver.Value) error <span class="cov8" title="1">{
        if mc := rows.mc; mc != nil </span><span class="cov8" title="1">{
                if err := mc.error(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Fetch next row from stream
                <span class="cov8" title="1">return rows.readRow(dest)</span>
        }
        <span class="cov0" title="0">return io.EOF</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "io"
        // syslog "log"
        "reflect"
        "time"
)

type mysqlStmt struct {
        sqlPrepared string
        mc          *mysqlConn
        id          uint32
        paramCount  int
}

func (stmt *mysqlStmt) Close() error <span class="cov8" title="1">{
        if stmt.mc == nil || stmt.mc.closed.IsSet() </span><span class="cov0" title="0">{
                // driver.Stmt.Close can be called more than once, thus this function
                // has to be idempotent.
                // See also Issue #450 and golang/go#16019.
                //errLog.Print(ErrInvalidConn)
                return driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">err := stmt.mc.writeCommandPacketUint32(comStmtClose, stmt.id)
        stmt.mc = nil
        return err</span>
}

func (stmt *mysqlStmt) NumInput() int <span class="cov8" title="1">{
        return stmt.paramCount
}</span>

func (stmt *mysqlStmt) ColumnConverter(idx int) driver.ValueConverter <span class="cov0" title="0">{
        return converter{}
}</span>

func (stmt *mysqlStmt) Exec(args []driver.Value) (driver.Result, error) <span class="cov8" title="1">{

        if stmt.mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">mc := stmt.mc
        ts := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if mc.connector != nil </span><span class="cov8" title="1">{
                        mc.connector.msk.AfterProcess(ts, stmt.sqlPrepared, args)
                }</span>
        }()
        // log.Printf("mysqlStmt:Exec on %v with sql %v", args, stmt.sqlPrepared)
        // Send command
        <span class="cov8" title="1">err := stmt.writeExecutePacket(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, stmt.mc.markBadConn(err)
        }</span>

        <span class="cov8" title="1">mc.affectedRows = 0
        mc.insertId = 0

        // Read Result
        resLen, err := mc.readResultSetHeaderPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resLen &gt; 0 </span><span class="cov8" title="1">{
                // Columns
                if err = mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Rows
                <span class="cov8" title="1">if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if err := mc.discardResults(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;mysqlResult{
                affectedRows: int64(mc.affectedRows),
                insertId:     int64(mc.insertId),
        }, nil</span>
}

func (stmt *mysqlStmt) Query(args []driver.Value) (driver.Rows, error) <span class="cov0" title="0">{
        return stmt.query(args)
}</span>

func (stmt *mysqlStmt) query(args []driver.Value) (*binaryRows, error) <span class="cov8" title="1">{
        if stmt.mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">mc := stmt.mc
        ts := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if mc.connector != nil </span><span class="cov8" title="1">{
                        mc.connector.msk.AfterProcess(ts, stmt.sqlPrepared, args)
                }</span>
        }()
        // Send command
        <span class="cov8" title="1">err := stmt.writeExecutePacket(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, stmt.mc.markBadConn(err)
        }</span>

        // Read Result
        <span class="cov8" title="1">resLen, err := mc.readResultSetHeaderPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows := new(binaryRows)

        if resLen &gt; 0 </span><span class="cov8" title="1">{
                rows.mc = mc
                rows.rs.columns, err = mc.readColumns(resLen)
        }</span> else<span class="cov0" title="0"> {
                rows.rs.done = true

                switch err := rows.NextResultSet(); err </span>{
                case nil, io.EOF:<span class="cov0" title="0">
                        return rows, nil</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }

        <span class="cov8" title="1">return rows, err</span>
}

var jsonType = reflect.TypeOf(json.RawMessage{})

type Converter struct {
        converter
}

type converter struct{}

func (c converter) ConvertValues(args []interface{}) ([]driver.Value, error) <span class="cov0" title="0">{

        nargs := []driver.Value{}
        var err error
        var narg driver.Value
        for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                narg, err = c.ConvertValue(args[i])
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">nargs = append(nargs, narg)</span>
        }
        // syslog.Printf("ConvertValues args %v nargs %v", args, nargs)
        <span class="cov0" title="0">return nargs, err</span>
}

// ConvertValue mirrors the reference/default converter in database/sql/driver
// with _one_ exception.  We support uint64 with their high bit and the default
// implementation does not.  This function should be kept in sync with
// database/sql/driver defaultConverter.ConvertValue() except for that
// deliberate difference.
func (c converter) ConvertValue(v interface{}) (driver.Value, error) <span class="cov8" title="1">{
        if driver.IsValue(v) </span><span class="cov8" title="1">{
                return v, nil
        }</span>

        <span class="cov0" title="0">if vr, ok := v.(driver.Valuer); ok </span><span class="cov0" title="0">{
                sv, err := callValuerValue(vr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !driver.IsValue(sv) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("non-Value type %T returned from Value", sv)
                }</span>
                <span class="cov0" title="0">return sv, nil</span>
        }
        <span class="cov0" title="0">rv := reflect.ValueOf(v)
        switch rv.Kind() </span>{
        case reflect.Ptr:<span class="cov0" title="0">
                // indirect pointers
                if rv.IsNil() </span><span class="cov0" title="0">{
                        return nil, nil
                }</span> else<span class="cov0" title="0"> {
                        return c.ConvertValue(rv.Elem().Interface())
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return rv.Int(), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return rv.Uint(), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return rv.Float(), nil</span>
        case reflect.Bool:<span class="cov0" title="0">
                return rv.Bool(), nil</span>
        case reflect.Slice:<span class="cov0" title="0">
                switch t := rv.Type(); </span>{
                case t == jsonType:<span class="cov0" title="0">
                        return v, nil</span>
                case t.Elem().Kind() == reflect.Uint8:<span class="cov0" title="0">
                        return rv.Bytes(), nil</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unsupported type %T, a slice of %s", v, t.Elem().Kind())</span>
                }
        case reflect.String:<span class="cov0" title="0">
                return rv.String(), nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported type %T, a %s", v, rv.Kind())</span>
}

var valuerReflectType = reflect.TypeOf((*driver.Valuer)(nil)).Elem()

// callValuerValue returns vr.Value(), with one exception:
// If vr.Value is an auto-generated method on a pointer type and the
// pointer is nil, it would panic at runtime in the panicwrap
// method. Treat it like nil instead.
//
// This is so people can implement driver.Value on value types and
// still use nil pointers to those types to mean nil/NULL, just like
// string/*string.
//
// This is an exact copy of the same-named unexported function from the
// database/sql package.
func callValuerValue(vr driver.Valuer) (v driver.Value, err error) <span class="cov0" title="0">{
        if rv := reflect.ValueOf(vr); rv.Kind() == reflect.Ptr &amp;&amp;
                rv.IsNil() &amp;&amp;
                rv.Type().Elem().Implements(valuerReflectType) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return vr.Value()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

type mysqlTx struct {
        mc *mysqlConn
}

func (tx *mysqlTx) Commit() (err error) <span class="cov8" title="1">{
        if tx.mc == nil || tx.mc.closed.IsSet() </span><span class="cov0" title="0">{
                return ErrInvalidConn
        }</span>
        <span class="cov8" title="1">err = tx.mc.exec("COMMIT")
        tx.mc = nil
        return</span>
}

func (tx *mysqlTx) Rollback() (err error) <span class="cov0" title="0">{
        if tx.mc == nil || tx.mc.closed.IsSet() </span><span class="cov0" title="0">{
                return ErrInvalidConn
        }</span>
        <span class="cov0" title="0">err = tx.mc.exec("ROLLBACK")
        tx.mc = nil
        return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "crypto/tls"
        "database/sql"
        "database/sql/driver"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
)

// Registry for custom tls.Configs
var (
        tlsConfigLock     sync.RWMutex
        tlsConfigRegistry map[string]*tls.Config
)

// RegisterTLSConfig registers a custom tls.Config to be used with sql.Open.
// Use the key as a value in the DSN where tls=value.
//
// Note: The provided tls.Config is exclusively owned by the driver after
// registering it.
//
//  rootCertPool := x509.NewCertPool()
//  pem, err := ioutil.ReadFile("/path/ca-cert.pem")
//  if err != nil {
//      log.Fatal(err)
//  }
//  if ok := rootCertPool.AppendCertsFromPEM(pem); !ok {
//      log.Fatal("Failed to append PEM.")
//  }
//  clientCert := make([]tls.Certificate, 0, 1)
//  certs, err := tls.LoadX509KeyPair("/path/client-cert.pem", "/path/client-key.pem")
//  if err != nil {
//      log.Fatal(err)
//  }
//  clientCert = append(clientCert, certs)
//  mysql.RegisterTLSConfig("custom", &amp;tls.Config{
//      RootCAs: rootCertPool,
//      Certificates: clientCert,
//  })
//  db, err := sql.Open("mskeeper", "user@tcp(localhost:3306)/test?tls=custom")
//
func RegisterTLSConfig(key string, config *tls.Config) error <span class="cov0" title="0">{
        if _, isBool := readBool(key); isBool || strings.ToLower(key) == "skip-verify" || strings.ToLower(key) == "preferred" </span><span class="cov0" title="0">{
                return fmt.Errorf("key '%s' is reserved", key)
        }</span>

        <span class="cov0" title="0">tlsConfigLock.Lock()
        if tlsConfigRegistry == nil </span><span class="cov0" title="0">{
                tlsConfigRegistry = make(map[string]*tls.Config)
        }</span>

        <span class="cov0" title="0">tlsConfigRegistry[key] = config
        tlsConfigLock.Unlock()
        return nil</span>
}

// DeregisterTLSConfig removes the tls.Config associated with key.
func DeregisterTLSConfig(key string) <span class="cov0" title="0">{
        tlsConfigLock.Lock()
        if tlsConfigRegistry != nil </span><span class="cov0" title="0">{
                delete(tlsConfigRegistry, key)
        }</span>
        <span class="cov0" title="0">tlsConfigLock.Unlock()</span>
}

func getTLSConfigClone(key string) (config *tls.Config) <span class="cov0" title="0">{
        tlsConfigLock.RLock()
        if v, ok := tlsConfigRegistry[key]; ok </span><span class="cov0" title="0">{
                config = v.Clone()
        }</span>
        <span class="cov0" title="0">tlsConfigLock.RUnlock()
        return</span>
}

// Returns the bool value of the input.
// The 2nd return value indicates if the input was a valid bool value
func readBool(input string) (value bool, valid bool) <span class="cov0" title="0">{
        switch input </span>{
        case "1", "true", "TRUE", "True":<span class="cov0" title="0">
                return true, true</span>
        case "0", "false", "FALSE", "False":<span class="cov0" title="0">
                return false, true</span>
        }

        // Not a valid bool value
        <span class="cov0" title="0">return</span>
}

/******************************************************************************
*                           Time related utils                                *
******************************************************************************/

func parseDateTime(str string, loc *time.Location) (t time.Time, err error) <span class="cov0" title="0">{
        base := "0000-00-00 00:00:00.0000000"
        switch len(str) </span>{
        case 10, 19, 21, 22, 23, 24, 25, 26:<span class="cov0" title="0"> // up to "YYYY-MM-DD HH:MM:SS.MMMMMM"
                if str == base[:len(str)] </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">t, err = time.Parse(timeFormat[:len(str)], str)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("invalid time string: %s", str)
                return</span>
        }

        // Adjust location
        <span class="cov0" title="0">if err == nil &amp;&amp; loc != time.UTC </span><span class="cov0" title="0">{
                y, mo, d := t.Date()
                h, mi, s := t.Clock()
                t, err = time.Date(y, mo, d, h, mi, s, t.Nanosecond(), loc), nil
        }</span>

        <span class="cov0" title="0">return</span>
}

func parseBinaryDateTime(num uint64, data []byte, loc *time.Location) (driver.Value, error) <span class="cov0" title="0">{
        switch num </span>{
        case 0:<span class="cov0" title="0">
                return time.Time{}, nil</span>
        case 4:<span class="cov0" title="0">
                return time.Date(
                        int(binary.LittleEndian.Uint16(data[:2])), // year
                        time.Month(data[2]),                       // month
                        int(data[3]),                              // day
                        0, 0, 0, 0,
                        loc,
                ), nil</span>
        case 7:<span class="cov0" title="0">
                return time.Date(
                        int(binary.LittleEndian.Uint16(data[:2])), // year
                        time.Month(data[2]),                       // month
                        int(data[3]),                              // day
                        int(data[4]),                              // hour
                        int(data[5]),                              // minutes
                        int(data[6]),                              // seconds
                        0,
                        loc,
                ), nil</span>
        case 11:<span class="cov0" title="0">
                return time.Date(
                        int(binary.LittleEndian.Uint16(data[:2])), // year
                        time.Month(data[2]),                       // month
                        int(data[3]),                              // day
                        int(data[4]),                              // hour
                        int(data[5]),                              // minutes
                        int(data[6]),                              // seconds
                        int(binary.LittleEndian.Uint32(data[7:11]))*1000, // nanoseconds
                        loc,
                ), nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("invalid DATETIME packet length %d", num)</span>
}

// zeroDateTime is used in formatBinaryDateTime to avoid an allocation
// if the DATE or DATETIME has the zero value.
// It must never be changed.
// The current behavior depends on database/sql copying the result.
var zeroDateTime = []byte("0000-00-00 00:00:00.000000")

const digits01 = "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
const digits10 = "0000000000111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999"

func appendMicrosecs(dst, src []byte, decimals int) []byte <span class="cov0" title="0">{
        if decimals &lt;= 0 </span><span class="cov0" title="0">{
                return dst
        }</span>
        <span class="cov0" title="0">if len(src) == 0 </span><span class="cov0" title="0">{
                return append(dst, ".000000"[:decimals+1]...)
        }</span>

        <span class="cov0" title="0">microsecs := binary.LittleEndian.Uint32(src[:4])
        p1 := byte(microsecs / 10000)
        microsecs -= 10000 * uint32(p1)
        p2 := byte(microsecs / 100)
        microsecs -= 100 * uint32(p2)
        p3 := byte(microsecs)

        switch decimals </span>{
        default:<span class="cov0" title="0">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                        digits10[p2], digits01[p2],
                        digits10[p3], digits01[p3],
                )</span>
        case 1:<span class="cov0" title="0">
                return append(dst, '.',
                        digits10[p1],
                )</span>
        case 2:<span class="cov0" title="0">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                )</span>
        case 3:<span class="cov0" title="0">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                        digits10[p2],
                )</span>
        case 4:<span class="cov0" title="0">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                        digits10[p2], digits01[p2],
                )</span>
        case 5:<span class="cov0" title="0">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                        digits10[p2], digits01[p2],
                        digits10[p3],
                )</span>
        }
}

func formatBinaryDateTime(src []byte, length uint8) (driver.Value, error) <span class="cov0" title="0">{
        // length expects the deterministic length of the zero value,
        // negative time and 100+ hours are automatically added if needed
        if len(src) == 0 </span><span class="cov0" title="0">{
                return zeroDateTime[:length], nil
        }</span>
        <span class="cov0" title="0">var dst []byte      // return value
        var p1, p2, p3 byte // current digit pair

        switch length </span>{
        case 10, 19, 21, 22, 23, 24, 25, 26:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                t := "DATE"
                if length &gt; 10 </span><span class="cov0" title="0">{
                        t += "TIME"
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("illegal %s length %d", t, length)</span>
        }
        <span class="cov0" title="0">switch len(src) </span>{
        case 4, 7, 11:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                t := "DATE"
                if length &gt; 10 </span><span class="cov0" title="0">{
                        t += "TIME"
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("illegal %s packet length %d", t, len(src))</span>
        }
        <span class="cov0" title="0">dst = make([]byte, 0, length)
        // start with the date
        year := binary.LittleEndian.Uint16(src[:2])
        pt := year / 100
        p1 = byte(year - 100*uint16(pt))
        p2, p3 = src[2], src[3]
        dst = append(dst,
                digits10[pt], digits01[pt],
                digits10[p1], digits01[p1], '-',
                digits10[p2], digits01[p2], '-',
                digits10[p3], digits01[p3],
        )
        if length == 10 </span><span class="cov0" title="0">{
                return dst, nil
        }</span>
        <span class="cov0" title="0">if len(src) == 4 </span><span class="cov0" title="0">{
                return append(dst, zeroDateTime[10:length]...), nil
        }</span>
        <span class="cov0" title="0">dst = append(dst, ' ')
        p1 = src[4] // hour
        src = src[5:]

        // p1 is 2-digit hour, src is after hour
        p2, p3 = src[0], src[1]
        dst = append(dst,
                digits10[p1], digits01[p1], ':',
                digits10[p2], digits01[p2], ':',
                digits10[p3], digits01[p3],
        )
        return appendMicrosecs(dst, src[2:], int(length)-20), nil</span>
}

func formatBinaryTime(src []byte, length uint8) (driver.Value, error) <span class="cov0" title="0">{
        // length expects the deterministic length of the zero value,
        // negative time and 100+ hours are automatically added if needed
        if len(src) == 0 </span><span class="cov0" title="0">{
                return zeroDateTime[11 : 11+length], nil
        }</span>
        <span class="cov0" title="0">var dst []byte // return value

        switch length </span>{
        case
                8,                      // time (can be up to 10 when negative and 100+ hours)
                10, 11, 12, 13, 14, 15:<span class="cov0" title="0"></span> // time with fractional seconds
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("illegal TIME length %d", length)</span>
        }
        <span class="cov0" title="0">switch len(src) </span>{
        case 8, 12:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid TIME packet length %d", len(src))</span>
        }
        // +2 to enable negative time and 100+ hours
        <span class="cov0" title="0">dst = make([]byte, 0, length+2)
        if src[0] == 1 </span><span class="cov0" title="0">{
                dst = append(dst, '-')
        }</span>
        <span class="cov0" title="0">days := binary.LittleEndian.Uint32(src[1:5])
        hours := int64(days)*24 + int64(src[5])

        if hours &gt;= 100 </span><span class="cov0" title="0">{
                dst = strconv.AppendInt(dst, hours, 10)
        }</span> else<span class="cov0" title="0"> {
                dst = append(dst, digits10[hours], digits01[hours])
        }</span>

        <span class="cov0" title="0">min, sec := src[6], src[7]
        dst = append(dst, ':',
                digits10[min], digits01[min], ':',
                digits10[sec], digits01[sec],
        )
        return appendMicrosecs(dst, src[8:], int(length)-9), nil</span>
}

/******************************************************************************
*                       Convert from and to bytes                             *
******************************************************************************/

func uint64ToBytes(n uint64) []byte <span class="cov0" title="0">{
        return []byte{
                byte(n),
                byte(n &gt;&gt; 8),
                byte(n &gt;&gt; 16),
                byte(n &gt;&gt; 24),
                byte(n &gt;&gt; 32),
                byte(n &gt;&gt; 40),
                byte(n &gt;&gt; 48),
                byte(n &gt;&gt; 56),
        }
}</span>

func uint64ToString(n uint64) []byte <span class="cov0" title="0">{
        var a [20]byte
        i := 20

        // U+0030 = 0
        // ...
        // U+0039 = 9

        var q uint64
        for n &gt;= 10 </span><span class="cov0" title="0">{
                i--
                q = n / 10
                a[i] = uint8(n-q*10) + 0x30
                n = q
        }</span>

        <span class="cov0" title="0">i--
        a[i] = uint8(n) + 0x30

        return a[i:]</span>
}

// treats string value as unsigned integer representation
func stringToInt(b []byte) int <span class="cov0" title="0">{
        val := 0
        for i := range b </span><span class="cov0" title="0">{
                val *= 10
                val += int(b[i] - 0x30)
        }</span>
        <span class="cov0" title="0">return val</span>
}

// returns the string read as a bytes slice, wheter the value is NULL,
// the number of bytes read and an error, in case the string is longer than
// the input slice
func readLengthEncodedString(b []byte) ([]byte, bool, int, error) <span class="cov8" title="1">{
        // Get length
        num, isNull, n := readLengthEncodedInteger(b)
        if num &lt; 1 </span><span class="cov8" title="1">{
                return b[n:n], isNull, n, nil
        }</span>

        <span class="cov8" title="1">n += int(num)

        // Check data length
        if len(b) &gt;= n </span><span class="cov8" title="1">{
                return b[n-int(num) : n : n], false, n, nil
        }</span>
        <span class="cov0" title="0">return nil, false, n, io.EOF</span>
}

// returns the number of bytes skipped and an error, in case the string is
// longer than the input slice
func skipLengthEncodedString(b []byte) (int, error) <span class="cov8" title="1">{
        // Get length
        num, _, n := readLengthEncodedInteger(b)
        if num &lt; 1 </span><span class="cov8" title="1">{
                return n, nil
        }</span>

        <span class="cov8" title="1">n += int(num)

        // Check data length
        if len(b) &gt;= n </span><span class="cov8" title="1">{
                return n, nil
        }</span>
        <span class="cov0" title="0">return n, io.EOF</span>
}

// returns the number read, whether the value is NULL and the number of bytes read
func readLengthEncodedInteger(b []byte) (uint64, bool, int) <span class="cov8" title="1">{
        // See issue #349
        if len(b) == 0 </span><span class="cov0" title="0">{
                return 0, true, 1
        }</span>

        <span class="cov8" title="1">switch b[0] </span>{
        // 251: NULL
        case 0xfb:<span class="cov8" title="1">
                return 0, true, 1</span>

        // 252: value of following 2
        case 0xfc:<span class="cov0" title="0">
                return uint64(b[1]) | uint64(b[2])&lt;&lt;8, false, 3</span>

        // 253: value of following 3
        case 0xfd:<span class="cov0" title="0">
                return uint64(b[1]) | uint64(b[2])&lt;&lt;8 | uint64(b[3])&lt;&lt;16, false, 4</span>

        // 254: value of following 8
        case 0xfe:<span class="cov0" title="0">
                return uint64(b[1]) | uint64(b[2])&lt;&lt;8 | uint64(b[3])&lt;&lt;16 |
                                uint64(b[4])&lt;&lt;24 | uint64(b[5])&lt;&lt;32 | uint64(b[6])&lt;&lt;40 |
                                uint64(b[7])&lt;&lt;48 | uint64(b[8])&lt;&lt;56,
                        false, 9</span>
        }

        // 0-250: value of first byte
        <span class="cov8" title="1">return uint64(b[0]), false, 1</span>
}

// encodes a uint64 value and appends it to the given bytes slice
func appendLengthEncodedInteger(b []byte, n uint64) []byte <span class="cov8" title="1">{
        switch </span>{
        case n &lt;= 250:<span class="cov8" title="1">
                return append(b, byte(n))</span>

        case n &lt;= 0xffff:<span class="cov0" title="0">
                return append(b, 0xfc, byte(n), byte(n&gt;&gt;8))</span>

        case n &lt;= 0xffffff:<span class="cov0" title="0">
                return append(b, 0xfd, byte(n), byte(n&gt;&gt;8), byte(n&gt;&gt;16))</span>
        }
        <span class="cov0" title="0">return append(b, 0xfe, byte(n), byte(n&gt;&gt;8), byte(n&gt;&gt;16), byte(n&gt;&gt;24),
                byte(n&gt;&gt;32), byte(n&gt;&gt;40), byte(n&gt;&gt;48), byte(n&gt;&gt;56))</span>
}

// reserveBuffer checks cap(buf) and expand buffer to len(buf) + appendSize.
// If cap(buf) is not enough, reallocate new buffer.
func reserveBuffer(buf []byte, appendSize int) []byte <span class="cov0" title="0">{
        newSize := len(buf) + appendSize
        if cap(buf) &lt; newSize </span><span class="cov0" title="0">{
                // Grow buffer exponentially
                newBuf := make([]byte, len(buf)*2+appendSize)
                copy(newBuf, buf)
                buf = newBuf
        }</span>
        <span class="cov0" title="0">return buf[:newSize]</span>
}

// escapeBytesBackslash escapes []byte with backslashes (\)
// This escapes the contents of a string (provided as []byte) by adding backslashes before special
// characters, and turning others into specific escape sequences, such as
// turning newlines into \n and null bytes into \0.
// https://github.com/mysql/mysql-server/blob/mysql-5.7.5/mysys/charset.c#L823-L932
func escapeBytesBackslash(buf, v []byte) []byte <span class="cov0" title="0">{
        pos := len(buf)
        buf = reserveBuffer(buf, len(v)*2)

        for _, c := range v </span><span class="cov0" title="0">{
                switch c </span>{
                case '\x00':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = '0'
                        pos += 2</span>
                case '\n':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = 'n'
                        pos += 2</span>
                case '\r':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = 'r'
                        pos += 2</span>
                case '\x1a':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = 'Z'
                        pos += 2</span>
                case '\'':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = '\''
                        pos += 2</span>
                case '"':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = '"'
                        pos += 2</span>
                case '\\':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = '\\'
                        pos += 2</span>
                default:<span class="cov0" title="0">
                        buf[pos] = c
                        pos++</span>
                }
        }

        <span class="cov0" title="0">return buf[:pos]</span>
}

// escapeStringBackslash is similar to escapeBytesBackslash but for string.
func escapeStringBackslash(buf []byte, v string) []byte <span class="cov0" title="0">{
        pos := len(buf)
        buf = reserveBuffer(buf, len(v)*2)

        for i := 0; i &lt; len(v); i++ </span><span class="cov0" title="0">{
                c := v[i]
                switch c </span>{
                case '\x00':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = '0'
                        pos += 2</span>
                case '\n':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = 'n'
                        pos += 2</span>
                case '\r':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = 'r'
                        pos += 2</span>
                case '\x1a':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = 'Z'
                        pos += 2</span>
                case '\'':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = '\''
                        pos += 2</span>
                case '"':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = '"'
                        pos += 2</span>
                case '\\':<span class="cov0" title="0">
                        buf[pos] = '\\'
                        buf[pos+1] = '\\'
                        pos += 2</span>
                default:<span class="cov0" title="0">
                        buf[pos] = c
                        pos++</span>
                }
        }

        <span class="cov0" title="0">return buf[:pos]</span>
}

// escapeBytesQuotes escapes apostrophes in []byte by doubling them up.
// This escapes the contents of a string by doubling up any apostrophes that
// it contains. This is used when the NO_BACKSLASH_ESCAPES SQL_MODE is in
// effect on the server.
// https://github.com/mysql/mysql-server/blob/mysql-5.7.5/mysys/charset.c#L963-L1038
func escapeBytesQuotes(buf, v []byte) []byte <span class="cov0" title="0">{
        pos := len(buf)
        buf = reserveBuffer(buf, len(v)*2)

        for _, c := range v </span><span class="cov0" title="0">{
                if c == '\'' </span><span class="cov0" title="0">{
                        buf[pos] = '\''
                        buf[pos+1] = '\''
                        pos += 2
                }</span> else<span class="cov0" title="0"> {
                        buf[pos] = c
                        pos++
                }</span>
        }

        <span class="cov0" title="0">return buf[:pos]</span>
}

// escapeStringQuotes is similar to escapeBytesQuotes but for string.
func escapeStringQuotes(buf []byte, v string) []byte <span class="cov0" title="0">{
        pos := len(buf)
        buf = reserveBuffer(buf, len(v)*2)

        for i := 0; i &lt; len(v); i++ </span><span class="cov0" title="0">{
                c := v[i]
                if c == '\'' </span><span class="cov0" title="0">{
                        buf[pos] = '\''
                        buf[pos+1] = '\''
                        pos += 2
                }</span> else<span class="cov0" title="0"> {
                        buf[pos] = c
                        pos++
                }</span>
        }

        <span class="cov0" title="0">return buf[:pos]</span>
}

/******************************************************************************
*                               Sync utils                                    *
******************************************************************************/

// noCopy may be embedded into structs which must not be copied
// after the first use.
//
// See https://github.com/golang/go/issues/8005#issuecomment-190753527
// for details.
type noCopy struct{}

// Lock is a no-op used by -copylocks checker from `go vet`.
func (*noCopy) Lock() {<span class="cov0" title="0">}</span>

// atomicBool is a wrapper around uint32 for usage as a boolean value with
// atomic access.
type atomicBool struct {
        _noCopy noCopy
        value   uint32
}

// IsSet returns whether the current boolean value is true
func (ab *atomicBool) IsSet() bool <span class="cov8" title="1">{
        return atomic.LoadUint32(&amp;ab.value) &gt; 0
}</span>

// Set sets the value of the bool regardless of the previous value
func (ab *atomicBool) Set(value bool) <span class="cov0" title="0">{
        if value </span><span class="cov0" title="0">{
                atomic.StoreUint32(&amp;ab.value, 1)
        }</span> else<span class="cov0" title="0"> {
                atomic.StoreUint32(&amp;ab.value, 0)
        }</span>
}

// TrySet sets the value of the bool and returns whether the value changed
func (ab *atomicBool) TrySet(value bool) bool <span class="cov8" title="1">{
        if value </span><span class="cov8" title="1">{
                return atomic.SwapUint32(&amp;ab.value, 1) == 0
        }</span>
        <span class="cov0" title="0">return atomic.SwapUint32(&amp;ab.value, 0) &gt; 0</span>
}

// atomicError is a wrapper for atomically accessed error values
type atomicError struct {
        value atomic.Value
}

// Set sets the error value regardless of the previous value.
// The value must not be nil
func (ae *atomicError) Set(value error) <span class="cov0" title="0">{
        ae.value.Store(value)
}</span>

// Value returns the current error value
func (ae *atomicError) Value() error <span class="cov0" title="0">{
        if v := ae.value.Load(); v != nil </span><span class="cov0" title="0">{
                // this will panic if the value doesn't implement the error interface
                return v.(error)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func namedValueToValue(named []driver.NamedValue) ([]driver.Value, error) <span class="cov8" title="1">{
        dargs := make([]driver.Value, len(named))
        for n, param := range named </span><span class="cov8" title="1">{
                if len(param.Name) &gt; 0 </span><span class="cov0" title="0">{
                        // TODO: support the use of Named Parameters #561
                        return nil, errors.New("mysql: driver does not support the use of Named Parameters")
                }</span>
                <span class="cov8" title="1">dargs[n] = param.Value</span>
        }
        <span class="cov8" title="1">return dargs, nil</span>
}

func mapIsolationLevel(level driver.IsolationLevel) (string, error) <span class="cov0" title="0">{
        switch sql.IsolationLevel(level) </span>{
        case sql.LevelRepeatableRead:<span class="cov0" title="0">
                return "REPEATABLE READ", nil</span>
        case sql.LevelReadCommitted:<span class="cov0" title="0">
                return "READ COMMITTED", nil</span>
        case sql.LevelReadUncommitted:<span class="cov0" title="0">
                return "READ UNCOMMITTED", nil</span>
        case sql.LevelSerializable:<span class="cov0" title="0">
                return "SERIALIZABLE", nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("mysql: unsupported isolation level: %v", level)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
