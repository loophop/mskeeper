
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitlab.papegames.com/fringe/mskeeper/addon/addon.go (93.3%)</option>
				
				<option value="file1">gitlab.papegames.com/fringe/mskeeper/addon/conn_msk.go (100.0%)</option>
				
				<option value="file2">gitlab.papegames.com/fringe/mskeeper/addon/connection_msk.go (97.7%)</option>
				
				<option value="file3">gitlab.papegames.com/fringe/mskeeper/addon/statement_msk.go (100.0%)</option>
				
				<option value="file4">gitlab.papegames.com/fringe/mskeeper/addon/tools_from_mysql.go (94.4%)</option>
				
				<option value="file5">gitlab.papegames.com/fringe/mskeeper/addon/transaction_msk.go (100.0%)</option>
				
				<option value="file6">gitlab.papegames.com/fringe/mskeeper/driver/kwfilter.go (100.0%)</option>
				
				<option value="file7">gitlab.papegames.com/fringe/mskeeper/driver/mskeeper.go (98.3%)</option>
				
				<option value="file8">gitlab.papegames.com/fringe/mskeeper/misc/misc.go (100.0%)</option>
				
				<option value="file9">gitlab.papegames.com/fringe/mskeeper/mysql/auth.go (90.6%)</option>
				
				<option value="file10">gitlab.papegames.com/fringe/mskeeper/mysql/buffer.go (85.5%)</option>
				
				<option value="file11">gitlab.papegames.com/fringe/mskeeper/mysql/conncheck.go (73.7%)</option>
				
				<option value="file12">gitlab.papegames.com/fringe/mskeeper/mysql/connection.go (81.6%)</option>
				
				<option value="file13">gitlab.papegames.com/fringe/mskeeper/mysql/connector.go (76.9%)</option>
				
				<option value="file14">gitlab.papegames.com/fringe/mskeeper/mysql/driver.go (93.5%)</option>
				
				<option value="file15">gitlab.papegames.com/fringe/mskeeper/mysql/dsn.go (89.4%)</option>
				
				<option value="file16">gitlab.papegames.com/fringe/mskeeper/mysql/errors.go (100.0%)</option>
				
				<option value="file17">gitlab.papegames.com/fringe/mskeeper/mysql/fields.go (91.9%)</option>
				
				<option value="file18">gitlab.papegames.com/fringe/mskeeper/mysql/infile.go (94.2%)</option>
				
				<option value="file19">gitlab.papegames.com/fringe/mskeeper/mysql/nulltime.go (100.0%)</option>
				
				<option value="file20">gitlab.papegames.com/fringe/mskeeper/mysql/packets.go (83.8%)</option>
				
				<option value="file21">gitlab.papegames.com/fringe/mskeeper/mysql/result.go (100.0%)</option>
				
				<option value="file22">gitlab.papegames.com/fringe/mskeeper/mysql/rows.go (92.9%)</option>
				
				<option value="file23">gitlab.papegames.com/fringe/mskeeper/mysql/statement.go (82.4%)</option>
				
				<option value="file24">gitlab.papegames.com/fringe/mskeeper/mysql/transaction.go (90.0%)</option>
				
				<option value="file25">gitlab.papegames.com/fringe/mskeeper/mysql/utils.go (98.8%)</option>
				
				<option value="file26">gitlab.papegames.com/fringe/mskeeper/options/options.go (100.0%)</option>
				
				<option value="file27">gitlab.papegames.com/fringe/mskeeper/policy/policy_checker.go (90.7%)</option>
				
				<option value="file28">gitlab.papegames.com/fringe/mskeeper/policy/policy_checker_fields_length.go (98.0%)</option>
				
				<option value="file29">gitlab.papegames.com/fringe/mskeeper/policy/policy_checker_fields_type.go (100.0%)</option>
				
				<option value="file30">gitlab.papegames.com/fringe/mskeeper/policy/policy_checker_rows_absolute.go (100.0%)</option>
				
				<option value="file31">gitlab.papegames.com/fringe/mskeeper/policy/policy_checker_rows_involved.go (88.9%)</option>
				
				<option value="file32">gitlab.papegames.com/fringe/mskeeper/server/httpsvr/handlers.go (100.0%)</option>
				
				<option value="file33">gitlab.papegames.com/fringe/mskeeper/server/httpsvr/iprange.go (100.0%)</option>
				
				<option value="file34">gitlab.papegames.com/fringe/mskeeper/server/httpsvr/manager.go (100.0%)</option>
				
				<option value="file35">gitlab.papegames.com/fringe/mskeeper/server/httpsvr/retdata.go (100.0%)</option>
				
				<option value="file36">gitlab.papegames.com/fringe/mskeeper/server/service/i18n.go (100.0%)</option>
				
				<option value="file37">gitlab.papegames.com/fringe/mskeeper/server/service/mysql.go (100.0%)</option>
				
				<option value="file38">gitlab.papegames.com/fringe/mskeeper/server/service/service.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package addon

import (
        "database/sql"
        sqldriver "database/sql/driver"
        "gitlab.papegames.com/fringe/mskeeper/driver"
        "gitlab.papegames.com/fringe/mskeeper/options"
        "gitlab.papegames.com/fringe/mskeeper/policy"
        "time"
)

type Addon struct {
        db  *sql.DB
        msk driver.MSKeeperInter
}

func NewMSKeeperAddon(db *sql.DB, opts ...options.Option) *Addon <span class="cov8" title="1">{

        mska := &amp;Addon{db: db, msk: driver.NewMSKeeperInstance(db, opts...)}
        return mska
}</span>

func (a *Addon) AttachPolicy(policy policy.PolicyChecker) error <span class="cov8" title="1">{
        return a.msk.AttachPolicy(policy)
}</span>

func (a *Addon) RawDB() *sql.DB <span class="cov8" title="1">{
        return a.msk.RawDB()
}</span>

func (a *Addon) ClearPolicies() <span class="cov8" title="1">{
        a.msk.ClearPolicies()
}</span>

func (a *Addon) ResetOptions(opts *options.Options) <span class="cov8" title="1">{
        a.msk.ResetOptions(opts)
}</span>

func (a *Addon) ResyncInfoQueue() <span class="cov8" title="1">{
        a.msk.ResyncInfoQueue()
}</span>

func (a *Addon) SetOption(o options.Option) <span class="cov8" title="1">{
        a.msk.SetOption(o)
}</span>

func (a *Addon) GetOptions() *options.Options <span class="cov8" title="1">{
        return a.msk.GetOptions()
}</span>

func (a *Addon) SetOptions(opts ...options.Option) <span class="cov8" title="1">{
        a.msk.SetOptions(opts...)
}</span>

func (a *Addon) GetErr() []driver.NotifyInfo <span class="cov8" title="1">{
        return a.msk.GetErr()
}</span>

func (a *Addon) Flush() error <span class="cov8" title="1">{
        return a.msk.Flush()
}</span>

func (a *Addon) SyncProcess(t time.Time, query string, args []sqldriver.Value, reterrors *[]error) error <span class="cov0" title="0">{
        return a.msk.SyncProcess(t, query, args, reterrors)
}</span>

func (a *Addon) ClearErr() <span class="cov8" title="1">{
        a.msk.ClearErr()
}</span>

func (a *Addon) HasErr(errCode policy.PolicyCode) bool <span class="cov8" title="1">{
        return a.msk.HasErr(errCode)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package addon

import (
        "context"
        "database/sql"
        "gitlab.papegames.com/fringe/mskeeper/driver"
        "time"
)

/*

// Tx is a transaction.
type Tx interface {
        Commit() error
        Rollback() error
}

*/
type MSKConn struct {
        *sql.Conn
        msk driver.MSKeeperInter
}

func (mskc *MSKConn) BeginTx(ctx context.Context, opts *sql.TxOptions) (*MSKTx, error) <span class="cov8" title="1">{
        tx, err := mskc.Conn.BeginTx(ctx, opts)
        msTx := &amp;MSKTx{msk: mskc.msk}

        msTx.Tx = tx
        return msTx, err
}</span>

func (mskc *MSKConn) PrepareContext(ctx context.Context, query string) (*MSKStmt, error) <span class="cov8" title="1">{
        stmt, err := mskc.Conn.PrepareContext(ctx, query)
        msStmt := &amp;MSKStmt{msk: mskc.msk, querysql: query}

        msStmt.Stmt = stmt
        return msStmt, err
}</span>

func (mskc *MSKConn) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer mskc.msk.AfterProcess(time.Now(), query, nargs)

        return mskc.Conn.QueryRowContext(ctx, query, args...)
}</span>

func (mskc *MSKConn) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer mskc.msk.AfterProcess(time.Now(), query, nargs)

        return mskc.Conn.QueryContext(ctx, query, args...)
}</span>

func (mskc *MSKConn) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer mskc.msk.AfterProcess(time.Now(), query, nargs)

        return mskc.Conn.ExecContext(ctx, query, args...)
}</span>

func (mskc *MSKConn) PingContext(ctx context.Context) error <span class="cov8" title="1">{

        return mskc.Conn.PingContext(ctx)
}</span>

func (mskc *MSKConn) Close() error <span class="cov8" title="1">{
        return mskc.Conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package addon

import (
        "context"
        "database/sql"
        "time"
)

func (mska *Addon) Begin() (*MSKTx, error) <span class="cov8" title="1">{
        tx, err := mska.db.Begin()
        msTx := &amp;MSKTx{msk: mska.msk}

        msTx.Tx = tx
        return msTx, err
}</span>

func (mska *Addon) BeginTx(ctx context.Context, opts *sql.TxOptions) (*MSKTx, error) <span class="cov8" title="1">{
        tx, err := mska.db.BeginTx(ctx, opts)
        msTx := &amp;MSKTx{msk: mska.msk}

        msTx.Tx = tx
        return msTx, err
}</span>

func (mska *Addon) Close() error <span class="cov8" title="1">{

        return mska.db.Close()
}</span>

func (mska *Addon) Conn(ctx context.Context) (*MSKConn, error) <span class="cov8" title="1">{
        con, err := mska.db.Conn(ctx)
        mskconn := &amp;MSKConn{msk: mska.msk}
        mskconn.Conn = con
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return mskconn, nil</span>
}

func (mska *Addon) Ping() error <span class="cov8" title="1">{

        return mska.db.Ping()
}</span>

func (mska *Addon) PingContext(ctx context.Context) error <span class="cov8" title="1">{

        return mska.db.PingContext(ctx)
}</span>

func (mska *Addon) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{

        nargs, _ := converter{}.ConvertValues(args)
        defer mska.msk.AfterProcess(time.Now(), query, nargs)

        return mska.db.ExecContext(ctx, query, args...)
}</span>

func (mska *Addon) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{

        nargs, _ := converter{}.ConvertValues(args)
        defer mska.msk.AfterProcess(time.Now(), query, nargs)

        return mska.db.QueryContext(ctx, query, args...)
}</span>

func (mska *Addon) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{

        nargs, _ := converter{}.ConvertValues(args)
        defer mska.msk.AfterProcess(time.Now(), query, nargs)

        return mska.db.QueryRowContext(ctx, query, args...)
}</span>

func (mska *Addon) PrepareContext(ctx context.Context, query string) (*MSKStmt, error) <span class="cov8" title="1">{
        stmt, err := mska.db.PrepareContext(ctx, query)
        msStmt := &amp;MSKStmt{msk: mska.msk, querysql: query}

        msStmt.Stmt = stmt
        return msStmt, err
}</span>

func (mska *Addon) Prepare(query string) (*MSKStmt, error) <span class="cov8" title="1">{
        stmt, err := mska.db.Prepare(query)
        msStmt := &amp;MSKStmt{msk: mska.msk, querysql: query}

        msStmt.Stmt = stmt
        return msStmt, err
}</span>

func (mska *Addon) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer mska.msk.AfterProcess(time.Now(), query, nargs)

        return mska.db.QueryRow(query, args...)
}</span>

func (mska *Addon) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer mska.msk.AfterProcess(time.Now(), query, nargs)

        return mska.db.Query(query, args...)
}</span>

func (mska *Addon) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer mska.msk.AfterProcess(time.Now(), query, nargs)

        return mska.db.Exec(query, args...)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package addon

import (
        "database/sql"
        "gitlab.papegames.com/fringe/mskeeper/driver"
        "time"
)

type MSKStmt struct {
        *sql.Stmt
        querysql string
        msk      driver.MSKeeperInter
}

func (msks *MSKStmt) Close() error <span class="cov8" title="1">{

        return msks.Stmt.Close()
}</span>

func (msks *MSKStmt) Exec(args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer msks.msk.AfterProcess(time.Now(), msks.querysql, nargs)

        return msks.Stmt.Exec(args...)
}</span>

func (msks *MSKStmt) QueryRow(args ...interface{}) *sql.Row <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer msks.msk.AfterProcess(time.Now(), msks.querysql, nargs)

        return msks.Stmt.QueryRow(args...)
}</span>

func (msks *MSKStmt) Query(args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer msks.msk.AfterProcess(time.Now(), msks.querysql, nargs)

        return msks.Stmt.Query(args...)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package addon

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "reflect"
)

var jsonType = reflect.TypeOf(json.RawMessage{})

type converter struct{}

func (c converter) ConvertValues(args []interface{}) ([]driver.Value, error) <span class="cov8" title="1">{

        nargs := []driver.Value{}
        var err error
        var narg driver.Value
        for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                narg, err = c.ConvertValue(args[i])
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">nargs = append(nargs, narg)</span>
        }
        // syslog.Printf("ConvertValues args %v nargs %v", args, nargs)
        <span class="cov8" title="1">return nargs, err</span>
}

// ConvertValue mirrors the reference/default converter in database/sql/driver
// with _one_ exception.  We support uint64 with their high bit and the default
// implementation does not.  This function should be kept in sync with
// database/sql/driver defaultConverter.ConvertValue() except for that
// deliberate difference.
func (c converter) ConvertValue(v interface{}) (driver.Value, error) <span class="cov8" title="1">{
        if driver.IsValue(v) </span><span class="cov8" title="1">{
                return v, nil
        }</span>

        <span class="cov8" title="1">if vr, ok := v.(driver.Valuer); ok </span><span class="cov8" title="1">{
                sv, err := callValuerValue(vr)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !driver.IsValue(sv) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("non-Value type %T returned from Value", sv)
                }</span>
                <span class="cov8" title="1">return sv, nil</span>
        }
        <span class="cov8" title="1">rv := reflect.ValueOf(v)
        switch rv.Kind() </span>{
        case reflect.Ptr:<span class="cov8" title="1">
                // indirect pointers
                if rv.IsNil() </span><span class="cov0" title="0">{
                        return nil, nil
                }</span> else<span class="cov8" title="1"> {
                        return c.ConvertValue(rv.Elem().Interface())
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return rv.Int(), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                return rv.Uint(), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return rv.Float(), nil</span>
        case reflect.Bool:<span class="cov8" title="1">
                return rv.Bool(), nil</span>
        case reflect.Slice:<span class="cov8" title="1">
                switch t := rv.Type(); </span>{
                case t == jsonType:<span class="cov8" title="1">
                        return v, nil</span>
                case t.Elem().Kind() == reflect.Uint8:<span class="cov8" title="1">
                        return rv.Bytes(), nil</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("unsupported type %T, a slice of %s", v, t.Elem().Kind())</span>
                }
        case reflect.String:<span class="cov8" title="1">
                return rv.String(), nil</span>
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("unsupported type %T, a %s", v, rv.Kind())</span>
}

var valuerReflectType = reflect.TypeOf((*driver.Valuer)(nil)).Elem()

// callValuerValue returns vr.Value(), with one exception:
// If vr.Value is an auto-generated method on a pointer type and the
// pointer is nil, it would panic at runtime in the panicwrap
// method. Treat it like nil instead.
//
// This is so people can implement driver.Value on value types and
// still use nil pointers to those types to mean nil/NULL, just like
// string/*string.
//
// This is an exact copy of the same-named unexported function from the
// database/sql package.
func callValuerValue(vr driver.Valuer) (v driver.Value, err error) <span class="cov8" title="1">{
        if rv := reflect.ValueOf(vr); rv.Kind() == reflect.Ptr &amp;&amp;
                rv.IsNil() &amp;&amp;
                rv.Type().Elem().Implements(valuerReflectType) </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return vr.Value()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package addon

import (
        "context"
        "database/sql"
        "gitlab.papegames.com/fringe/mskeeper/driver"
        "time"
)

/*

// Tx is a transaction.
type Tx interface {
        Commit() error
        Rollback() error
}

*/
type MSKTx struct {
        *sql.Tx
        msk driver.MSKeeperInter
}

func (tx *MSKTx) Commit() (err error) <span class="cov8" title="1">{

        return tx.Tx.Commit()
}</span>

func (tx *MSKTx) Rollback() (err error) <span class="cov8" title="1">{

        return tx.Tx.Rollback()
}</span>

func (tx *MSKTx) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer tx.msk.AfterProcess(time.Now(), query, nargs)

        return tx.Tx.Exec(query, args...)
}</span>

func (tx *MSKTx) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer tx.msk.AfterProcess(time.Now(), query, nargs)

        return tx.Tx.ExecContext(ctx, query, args...)
}</span>

func (tx *MSKTx) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer tx.msk.AfterProcess(time.Now(), query, nargs)

        return tx.Tx.QueryRowContext(ctx, query, args...)
}</span>

func (tx *MSKTx) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer tx.msk.AfterProcess(time.Now(), query, nargs)

        return tx.Tx.QueryContext(ctx, query, args...)
}</span>

func (tx *MSKTx) PrepareContext(ctx context.Context, query string) (*MSKStmt, error) <span class="cov8" title="1">{
        stmt, err := tx.Tx.PrepareContext(ctx, query)
        msStmt := &amp;MSKStmt{msk: tx.msk, querysql: query}

        msStmt.Stmt = stmt
        return msStmt, err
}</span>

func (tx *MSKTx) Prepare(query string) (*MSKStmt, error) <span class="cov8" title="1">{
        stmt, err := tx.Tx.Prepare(query)
        msStmt := &amp;MSKStmt{msk: tx.msk, querysql: query}

        msStmt.Stmt = stmt
        return msStmt, err
}</span>

func (tx *MSKTx) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer tx.msk.AfterProcess(time.Now(), query, nargs)

        return tx.Tx.QueryRow(query, args...)
}</span>

func (tx *MSKTx) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        nargs, _ := converter{}.ConvertValues(args)
        defer tx.msk.AfterProcess(time.Now(), query, nargs)

        return tx.Tx.Query(query, args...)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package driver

import (
        // "gitlab.papegames.com/fringe/mskeeper/log"
        // syslog "log"
        "strings"
)

// 下列关键字打头的SQL语句不做分析
var keywords1 []string = []string{
        "EXPLAIN",
        "SHOW",
}

// 下列关键字打头的SQL语句不进队列
var keywords2 []string = []string{
        "EXPLAIN",
        "DROP",
        "ALTER",
        "CREATE",
        "RENAME",
        "TRUNCATE",
        "LOCK",
        "UNLOCK",
        "CALL",
        "USE",
        "SHOW",
}

func findIn(kw string, keywords []string) bool <span class="cov8" title="1">{
        upkw := strings.ToUpper(kw)
        for i := 0; i &lt; len(keywords); i++ </span><span class="cov8" title="1">{
                if upkw == keywords[i] </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func parseKeyWordFromSQL(sql string) string <span class="cov8" title="1">{
        sql = strings.TrimSpace(sql)

        kws := strings.Split(sql, " ")
        if len(kws) &gt; 1 </span><span class="cov8" title="1">{ // strings.Split至少返回一个原串，且，keywords中的语句至少 len(kws) &gt;= 2
                return kws[0]
        }</span>
        <span class="cov8" title="1">return sql</span>
}

func checkIfSQLExplainLike(sql string) bool <span class="cov8" title="1">{
        kw := parseKeyWordFromSQL(sql)
        // syslog.Printf("checkIfSQLHardcore sql %v", sql)
        return findIn(kw, keywords1)
}</span>

func checkIfSQLHardcore(sql string) bool <span class="cov8" title="1">{
        kw := parseKeyWordFromSQL(sql)
        // syslog.Printf("checkIfSQLHardcore sql %v", sql)
        return findIn(kw, keywords2)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package driver

import (
        "bytes"
        "database/sql"
        sqldriver "database/sql/driver"
        "errors"
        "fmt"

        "gitlab.papegames.com/fringe/mskeeper/log"

        // syslog "log"
        "math"
        "strings"
        "sync"
        "time"

        lru "github.com/hashicorp/golang-lru"
        "gitlab.papegames.com/fringe/mskeeper/misc"
        "gitlab.papegames.com/fringe/mskeeper/notifier"
        "gitlab.papegames.com/fringe/mskeeper/options"
        "gitlab.papegames.com/fringe/mskeeper/policy"
)

var (
        ErrMSKeeperClosed    = errors.New("MSKeeper is not open")
        ErrMSKeeperSQLIgnore = errors.New("sql is ignored")
)

const (
        MaxNumberOfShowWarningInfos      = 10
        NumberOfErrorsCached             = 100
        MaxTimeoutSecondsForFlush        = 5
        MaxTimeoutOfMSKeeperChannelWrite = 10 * time.Second
)

type MSKeeperInter interface {
        AfterProcess(t time.Time, query string, args []sqldriver.Value)
        AttachPolicy(policy policy.PolicyChecker) error
        ResetOptions(opts *options.Options)
        ResyncInfoQueue()
        SetOption(o options.Option)
        GetOptions() *options.Options
        SetOptions(opts ...options.Option)
        GetErr() []NotifyInfo
        Flush() error
        SyncProcess(t time.Time, query string, args []sqldriver.Value, reterrors *[]error) error
        ClearErr()
        HasErr(errCode policy.PolicyCode) bool
        RawDB() *sql.DB
        ClearPolicies()
}

type MSKeeper struct {
        db *sql.DB

        opts       *options.Options
        pcs        []policy.PolicyChecker
        lastestErr []NotifyInfo
        ch         chan *mskeeperInfo
        sigmap     *lru.Cache
        wg         sync.WaitGroup
        lock       sync.RWMutex
}

// type MSKeeperWarnInfo struct {
//         Level   string
//         Code    string
//         Message string
// }

// func NewMSKeeperWarnInfo() *MSKeeperWarnInfo {
//         return &amp;MSKeeperWarnInfo{}
// }

type mskeeperInfo struct {
        // before bool
        cost  time.Duration
        query string
        args  []interface{}
}

type NotifyInfo struct {
        err error
        lvl notifier.Level
}

func NewMSKeeperInstance(db *sql.DB, opts ...options.Option) *MSKeeper <span class="cov8" title="1">{
        return newMSKDB(db, opts...)
}</span>

func newMSKDB(db *sql.DB, opts ...options.Option) *MSKeeper <span class="cov8" title="1">{
        msg := &amp;MSKeeper{
                pcs:  []policy.PolicyChecker{},
                opts: options.NewOptions(opts...),
        }
        msg.ch = make(chan *mskeeperInfo, msg.opts.Capacity)
        if options.FetchSQLCacheSize(msg.opts) &gt; 0 </span><span class="cov8" title="1">{
                msg.sigmap, _ = lru.New(options.FetchSQLCacheSize(msg.opts))
        }</span>
        <span class="cov8" title="1">msg.clearErr()
        msg.db = db

        go msg.process()

        return msg</span>
}

func NewMSK(connector sqldriver.Connector, opts ...options.Option) *MSKeeper <span class="cov8" title="1">{

        // syslog.Printf("newMSK(%v, %v)", connector, opts)
        msg := &amp;MSKeeper{
                pcs:  []policy.PolicyChecker{},
                opts: options.NewOptions(opts...),
        }
        msg.ch = make(chan *mskeeperInfo, msg.opts.Capacity)
        if options.FetchSQLCacheSize(msg.opts) &gt; 0 </span><span class="cov8" title="1">{
                msg.sigmap, _ = lru.New(options.FetchSQLCacheSize(msg.opts))
        }</span>
        <span class="cov8" title="1">msg.clearErr()

        db := sql.OpenDB(connector)
        msg.db = db

        go msg.process()

        return msg</span>
}

func (msk *MSKeeper) closeCh() <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        log.MSKLog().Infof("MSKeeper:closeCh recover failed %v", err)
                }</span>
        }()

        <span class="cov8" title="1">close(msk.ch)</span> // panic if ch is closed
}

func (msk *MSKeeper) ClearStatus() <span class="cov8" title="1">{
        log.MSKLog().Infof("MSKeeper:ClearStauts")

        msk.ResetOptions(options.DefaultOptions())
        msk.ClearErr()
        msk.ClearPolicies()
        msk.ClearSigs()

        msk.ResyncInfoQueue()
}</span>

func (msk *MSKeeper) ResetOptions(opts *options.Options) <span class="cov8" title="1">{
        msk.opts = opts
}</span>

func (msk *MSKeeper) ResyncInfoQueue() <span class="cov8" title="1">{
        msk.closeCh()
        msk.ch = make(chan *mskeeperInfo, msk.opts.Capacity)

        go msk.process()
}</span>

func (msk *MSKeeper) SetOption(o options.Option) <span class="cov8" title="1">{
        o(msk.opts)
}</span>

func (msk *MSKeeper) GetOptions() *options.Options <span class="cov8" title="1">{
        return msk.opts
}</span>

func (msk *MSKeeper) SetOptions(opts ...options.Option) <span class="cov8" title="1">{
        for _, o := range opts </span><span class="cov8" title="1">{
                o(msk.opts)
        }</span>
}
func (msk *MSKeeper) GetErr() []NotifyInfo <span class="cov8" title="1">{
        return msk.lastestErr
}</span>

func (msk *MSKeeper) recordLastestErr(errs []NotifyInfo) <span class="cov8" title="1">{

        msk.lastestErr = append(msk.lastestErr, errs...)
        if len(msk.lastestErr) &gt; 0 </span><span class="cov8" title="1">{
                start := int(math.Max(float64(len(msk.lastestErr)-NumberOfErrorsCached), 0.0))
                msk.lastestErr = msk.lastestErr[start:len(msk.lastestErr)]
        }</span>
}

func (msk *MSKeeper) clearErr() <span class="cov8" title="1">{
        msk.lastestErr = make([]NotifyInfo, 0)
}</span>

func (msk *MSKeeper) ClearErr() <span class="cov8" title="1">{
        msk.clearErr()
}</span>

func (msk *MSKeeper) HasErr(errCode policy.PolicyCode) bool <span class="cov8" title="1">{
        return msk.hasErr(errCode)
}</span>

func (msk *MSKeeper) hasErr(errCode policy.PolicyCode) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(msk.lastestErr); i++ </span><span class="cov8" title="1">{
                err, ok := msk.lastestErr[i].err.(*policy.PolicyError)
                if ok &amp;&amp; err.Code == errCode </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (msqlsg *MSKeeper) RawDB() *sql.DB <span class="cov8" title="1">{
        return msqlsg.db
}</span>

func (msqlsg *MSKeeper) AttachPolicy(policy policy.PolicyChecker) error <span class="cov8" title="1">{
        msqlsg.pcs = append(msqlsg.pcs, policy)
        return nil
}</span>

func (msqlsg *MSKeeper) ClearPolicies() <span class="cov8" title="1">{
        msqlsg.pcs = []policy.PolicyChecker{}
}</span>

func (msqlsg *MSKeeper) ClearSigs() <span class="cov8" title="1">{
        if options.FetchSQLCacheSize(msqlsg.opts) &gt; 0 </span><span class="cov8" title="1">{
                msqlsg.sigmap.Purge()
        }</span>
}

// func (msqlsg *MSKeeper) beforeProcess(query string, args ...interface{}) {
//         if !FetchSwitch(msqlsg.opts) {
//                 return
//         }

//         select {
//         case msqlsg.ch &lt;- &amp;mskeeperInfo{
//                 before: true,
//                 query:  query,
//                 args:   append([]interface{}{}, args...)}:
//         default:
//         }
// }
func (msqlsg *MSKeeper) SyncProcess(t time.Time, query string, args []sqldriver.Value, reterrors *[]error) error <span class="cov8" title="1">{
        defer misc.PrintPanicStack()

        job := msqlsg.precheckOfJob(t, query, args)
        if job == nil </span><span class="cov0" title="0">{
                log.MSKLog().Infof("MSKeeper:SyncProcess(%v, %v, %v) job ignored", t, query, args)
                return ErrMSKeeperSQLIgnore
        }</span>
        <span class="cov8" title="1">*reterrors = msqlsg.policiesCheck(job)

        // syslog.Printf("MSKeeper:SyncProcess(%v, %v, %v)", query, args, reterrors)
        return nil</span>
}

func (msqlsg *MSKeeper) precheckOfJob(t time.Time, query string, args []sqldriver.Value) *mskeeperInfo <span class="cov8" title="1">{

        // syslog.Printf("AfterProcess: %v", query)
        defer misc.PrintPanicStack()

        // 过滤自身或无需记录操作explain型语句
        if hc := checkIfSQLExplainLike(query); hc </span><span class="cov8" title="1">{
                // log.MSKLog().Infof("MSKeeper:AfterProcess skip explain like sql %v", query)
                return nil
        }</span>
        <span class="cov8" title="1">defer log.MSKLog().Infof("MSKeeper:precheckOfJob(%v, %v, %v) started", t, query, args)

        // 去掉连续、前后缀空格（包括\t\n)
        query = misc.TrimConsecutiveSpaces(query)

        // 不带告警的纯SQL签名，不会影响同样SQL的告警触发，只是防止快速同样的SQL导致channel满。
        sqlsig := misc.MD5String(query, args)
        if msqlsg.sigmapUpdate(sqlsig) </span><span class="cov8" title="1">{
                log.MSKLog().Infof("MSKeeper:precheckOfJob skip of query %v args %v since sigmapUpdate %v return true",
                        query, args, sqlsig)
                return nil
        }</span>
        <span class="cov8" title="1">inWhiteList := options.CheckIfInSQLWhiteLists(msqlsg.opts, query)
        if inWhiteList </span><span class="cov8" title="1">{
                log.MSKLog().Infof("MSKeeper:precheckOfJob skip of query %v args %v since whitelist",
                        query, args)
                return nil
        }</span>
        <span class="cov8" title="1">iargs := []interface{}{}
        for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                iargs = append(iargs, args[i])
        }</span>

        // will be done in 1, finished checking; 2, channel queue was full
        <span class="cov8" title="1">msqlsg.wg.Add(1)
        return &amp;mskeeperInfo{
                query: query,
                cost:  time.Since(t),
                args:  iargs}</span>
}

func (msqlsg *MSKeeper) AfterProcess(t time.Time, query string, args []sqldriver.Value) <span class="cov8" title="1">{

        if !options.FetchSwitch(msqlsg.opts) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">job := msqlsg.precheckOfJob(t, query, args)
        if job == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                log.MSKLog().Warnf("MSKeeper:AfterProcess queue closed, when query %v", query)
                                msqlsg.wg.Done()
                        }</span>
                }()
                <span class="cov8" title="1">select </span>{
                case msqlsg.ch &lt;- job:<span class="cov8" title="1"></span>
                default:<span class="cov8" title="1">
                        msqlsg.wg.Done()
                        // 处理队列满，则丢弃
                        log.MSKLog().Warnf("MSKeeper:AfterProcess queue %v was full, query %v check skipped",
                                len(msqlsg.ch), query)</span>
                }
        }()
        // syslog.Printf("+++++++++++++++++++++++AfterProcess %v %v", query, args)
}

// ！！！！ 单元测试或需要hook某一句SQL结果的时候，可以用。！！！！
// 通常情况下不需要调用
func (msqlsg *MSKeeper) Flush() error <span class="cov8" title="1">{
        defer misc.PrintPanicStack()

        start := time.Now()
        time.Sleep(100 * time.Millisecond)
        for len(msqlsg.ch) &gt; 0 </span><span class="cov8" title="1">{
                if time.Since(start) &gt; MaxTimeoutSecondsForFlush*time.Second </span><span class="cov8" title="1">{
                        func() </span><span class="cov8" title="1">{
                                defer misc.PrintPanicStack()
                                close(msqlsg.ch) // 单元发现的问题，如果msqlsg.ch已关闭，则close时候会panic。用闭包抑制panic，从而使得error可以正确返回
                        }</span>()
                        <span class="cov8" title="1">log.MSKLog().Warn("MSKeeper:Flush timed out")
                        // msk.ch = make(chan *mskeeperInfo, msk.opts.Capacity)
                        // go msk.process()
                        return errors.New("MSKeeper:Flush timed out")</span>
                }
                <span class="cov8" title="1">time.Sleep(10 * time.Millisecond)</span>
        }
        <span class="cov8" title="1">msqlsg.wg.Wait()
        log.MSKLog().Infof("MSKeeper:Flush finished time %0.1vs elapesd", time.Since(start).Seconds())
        return nil</span>
}

// return true: if the sql's signature has been updated(out of silent period)
func (msqlsg *MSKeeper) sigmapUpdate(errsig string) bool <span class="cov8" title="1">{
        if msqlsg.sigmap == nil || options.FetchSQLCacheSize(msqlsg.opts) &lt;= 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">msp := options.FetchMaxSilentPeriod(msqlsg.opts)
        s, ok := msqlsg.sigmap.Get(errsig)

        // log.Printf("[DEBUG] msqlsg sigmaplen %v sigmap %v s %v, ok %v msp %v", len(msqlsg.sigmap), msqlsg.sigmap, s, ok, msp)
        if ok </span><span class="cov8" title="1">{
                stime, okk := s.(time.Time)
                if time.Since(stime).Nanoseconds() &lt; msp.Nanoseconds() &amp;&amp; okk </span><span class="cov8" title="1">{ // okk == false 表示时间格式不对，刷新一下
                        // already notified in last period
                        log.MSKLog().Infof("MSKeeper:sigmapUpdate skip of errsig %v, since time.Since(stime).Seconds() %v &lt; MaxSilentPeriod %v",
                                errsig, time.Since(stime).Seconds(), msp.Seconds())
                        return true
                }</span> else<span class="cov8" title="1"> {
                        // period has expired
                        msqlsg.sigmap.Add(errsig, time.Now())
                }</span>
        } else<span class="cov8" title="1"> {
                msqlsg.sigmap.Add(errsig, time.Now())
        }</span>

        // 可以上报
        <span class="cov8" title="1">return false</span>
}

// 周期内（比如1小时），相同SQL query的告警只显示一次
func (msqlsg *MSKeeper) notify(sql string, notifs []NotifyInfo, args ...interface{}) <span class="cov8" title="1">{

        var errcontent string
        for i := 0; i &lt; len(notifs); i++ </span><span class="cov8" title="1">{
                errStrBuf := bytes.NewBufferString("")
                errStrBuf.WriteString(sql)
                errStrBuf.WriteString("|")
                errMSK, _ := notifs[i].err.(*policy.PolicyError)
                errStrBuf.WriteString(errMSK.Code.String() + "|")

                errcontent = errStrBuf.String()
                errsig := misc.MD5String(errcontent, args)

                if !msqlsg.sigmapUpdate(errsig) </span><span class="cov8" title="1">{
                        // 非周期内重复告警，则继续上报。
                        msqlsg.opts.Notifier.Notify(notifs[i].lvl, sql, []error{notifs[i].err}, args)
                }</span>
        }
}

// // Get lastest n(at most) records of mysql warnings
// // REF: Out-of-Range and Overflow Handling
// // https://dev.mysql.com/doc/refman/8.0/en/out-of-range-and-overflow.html
// /*
//         +---------+------+---------------------------------------------+
//         | Level   | Code | Message                                     |
//         +---------+------+---------------------------------------------+
//         | Warning | 1264 | Out of range value for column 'i1' at row 1 |
//         | Warning | 1264 | Out of range value for column 'i2' at row 1 |
//         +---------+------+---------------------------------------------+
// */
// func (msqlsg *MSKeeper) GetLatestWarnings(n int) ([]MSKeeperWarnInfo, error) {
//         if n &lt; 0 || n &gt; MaxNumberOfShowWarningInfos {
//                 n = MaxNumberOfShowWarningInfos
//         }

//         cmd := fmt.Sprintf("SHOW WARNINGS LIMIT %v;", n)

//         records, err := MakeWarningRecords(msqlsg.db, cmd)
//         if err != nil {
//                 log.MSKLog().Warnf("MSKeeper.GetLatestWarnings(%+v) hardcore sql skipped",
//                         n)
//                 return records, err
//         }

//         return records, err
// }

func (msqlsg *MSKeeper) policiesCheck(info *mskeeperInfo) []error <span class="cov8" title="1">{
        msqlsg.lock.Lock()
        defer msqlsg.lock.Unlock()

        notifies := make([]NotifyInfo, 0)
        rawerrors := make([]error, 0)

        var explainRecords []policy.ExplainRecord
        var err error
        var execTime time.Duration

        // 过滤不需要做解析的语句, 例如 DROP TABLE
        if hc := checkIfSQLHardcore(info.query); hc </span><span class="cov8" title="1">{
                log.MSKLog().Infof("MSKeeper:policiesCheck checkIfSQLHardcore skip sql %v", info.query)
                goto SAFE_SQL</span>
        }

        <span class="cov8" title="1">execTime = options.FetchMaxExecTime(msqlsg.opts)
        explainRecords, err = policy.MakeExplainRecords(msqlsg.RawDB(), info.query, policy.MaxTimeoutOfExplain, info.args)
        if err == nil </span><span class="cov8" title="1">{
                for _, pc := range msqlsg.pcs </span><span class="cov8" title="1">{
                        err := pc.Check(msqlsg.RawDB(), explainRecords, info.query, info.args)
                        if err != nil &amp;&amp; !strings.Contains(err.Error(), "1146") </span><span class="cov8" title="1">{ // 1146 table deleted by other routine
                                log.MSKLog().Warnf("MSKeeper.policiesCheck(%+v) pc.Check(%v, %v, %v) error %v",
                                        info.query, explainRecords, info.query, info.args, err)
                                notifies = append(notifies, NotifyInfo{err: err, lvl: getNotifyLevelByPolicyCode(err)})
                                rawerrors = append(rawerrors, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if info.cost &gt; execTime </span><span class="cov8" title="1">{
                err := policy.NewPolicyError(policy.ErrPolicyCodeExeCost,
                        fmt.Sprintf("Too much time spent in execution sql: cost(%0.3vms) &gt; msqlsg.opts.MaxExecTime(%v)",
                                float64(info.cost.Nanoseconds())/float64(1000000), execTime))
                notifies = append(notifies, NotifyInfo{err: err, lvl: getNotifyLevelByPolicyCode(err)})
                rawerrors = append(rawerrors, err)
        }</span>
SAFE_SQL:
        <span class="cov8" title="1">if len(notifies) &lt;= 0 </span><span class="cov8" title="1">{
                maxRows := policy.MaxRowsFromExplainRecords(explainRecords)
                errSuccess := policy.NewPolicyErrorSafe(maxRows, info.cost)
                notifies = append(notifies, NotifyInfo{err: errSuccess, lvl: getNotifyLevelByPolicyCode(errSuccess)})
                rawerrors = append(rawerrors, errSuccess)
        }</span>

        <span class="cov8" title="1">msqlsg.recordLastestErr(notifies)
        msqlsg.notify(info.query, notifies, info.args)

        log.MSKLog().Infof("MSKeeper.policiesCheck(%+v, %v) execution time limit(%v) cost %v with notifies %v",
                info.query, info.args, execTime, info.cost, notifies)
        msqlsg.wg.Done()

        return rawerrors</span>
}

func (msqlsg *MSKeeper) process() <span class="cov8" title="1">{
        log.MSKLog().Infof("MSKeeper:process() started")

        defer misc.PrintPanicStack()
        s := time.Now()
        for info := range msqlsg.ch </span><span class="cov8" title="1">{
                _ = msqlsg.policiesCheck(info)
        }</span>
        <span class="cov8" title="1">log.MSKLog().Infof("MSKeeper.process() ended, took %vs",
                time.Since(s).Seconds())</span>
}

func getNotifyLevelByPolicyCode(err error) notifier.Level <span class="cov8" title="1">{
        var lvl notifier.Level
        perror, ok := err.(*policy.PolicyError)
        if !ok </span><span class="cov8" title="1">{
                lvl = notifier.WarnLevel
        }</span> else<span class="cov8" title="1"> {
                switch perror.Code </span>{
                case policy.ErrPolicyCodeSafe:<span class="cov8" title="1">
                        lvl = notifier.InfoLevel</span>
                case policy.WarnPolicyCodeDataTruncate:<span class="cov8" title="1">
                        lvl = notifier.WarnLevel</span>
                default:<span class="cov8" title="1">
                        lvl = notifier.ErrorLevel</span>
                }
        }
        <span class="cov8" title="1">return lvl</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package misc

import (
        "bytes"
        "crypto/md5"
        // "database/sql/driver"
        "encoding/hex"
        "fmt"
        "log"
        "reflect"
        "runtime"
        "strings"
)

func PrintPanicStack() <span class="cov8" title="1">{
        if x := recover(); x != nil </span><span class="cov8" title="1">{
                panicInfo := fmt.Sprintf("[PANIC] %v\n", x)
                for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                        funcName, file, line, ok := runtime.Caller(i)
                        if ok </span><span class="cov8" title="1">{
                                panicInfo += fmt.Sprintf("[PANIC] frame %v:[func:%v,file:%v,line:%v]\n",
                                        i, runtime.FuncForPC(funcName).Name(), file, line)
                        }</span>
                }
                <span class="cov8" title="1">log.Println(panicInfo)</span>

        }
}

func MD5String(str string, args ...interface{}) string <span class="cov8" title="1">{
        h := md5.New()
        _, _ = h.Write([]byte(str))
        argsStr := ""
        for _, arg := range args </span><span class="cov8" title="1">{
                if arg == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">argsStr += fmt.Sprintf("%v %v", reflect.TypeOf(arg).Name(), arg)</span>
        }
        <span class="cov8" title="1">_, _ = h.Write([]byte(argsStr))

        return hex.EncodeToString(h.Sum(nil))</span>
}

// 去掉sql中的连续空格
func TrimConsecutiveSpaces(sql string) string <span class="cov8" title="1">{
        outputStrBuf := bytes.NewBufferString("")
        spaceFlag := false
        for i := 0; i &lt; len(sql); i++ </span><span class="cov8" title="1">{
                r := sql[i]
                if r == '\n' || r == '\t' </span><span class="cov8" title="1">{
                        r = ' '
                }</span>
                <span class="cov8" title="1">if r == ' ' </span><span class="cov8" title="1">{
                        if !spaceFlag </span><span class="cov8" title="1">{
                                outputStrBuf.WriteByte(r)
                                spaceFlag = true
                        }</span>
                        // skip consecutive spaces
                } else<span class="cov8" title="1"> {
                        outputStrBuf.WriteByte(r)
                        spaceFlag = false
                }</span>
        }

        <span class="cov8" title="1">return strings.TrimSpace(outputStrBuf.String())</span>
}

// https://dev.mysql.com/doc/refman/8.0/en/insert.html
// 由于 mysql 5.5- 不支持 explain insert select形式，这样可能会将其中隐含的 select航母给忽略了
// 这个函数试图抽取select，仅仅限于 insert select。
func FilterInnerSelectFor55Minus(insertQuery string) string <span class="cov8" title="1">{
        resQuery := insertQuery
        uInsertQuery := strings.ToUpper(insertQuery)
        if len(uInsertQuery) &lt; 6 </span><span class="cov8" title="1">{
                return resQuery
        }</span>
        <span class="cov8" title="1">idxInsert := strings.Index(uInsertQuery[0:6], "INSERT")
        idxSelect := strings.Index(uInsertQuery, "SELECT")

        if idxInsert != -1 &amp;&amp; idxSelect != -1 </span><span class="cov8" title="1">{
                if strings.ContainsAny(uInsertQuery[0:idxSelect], "'\"") </span><span class="cov8" title="1">{
                        // != -1, should be pattern insert select,
                        idxSelect = -1
                }</span>
        }
        <span class="cov8" title="1">var begin, end int
        end = len(insertQuery)
        begin = 0
        if idxSelect != -1 </span><span class="cov8" title="1">{
                begin = idxSelect
        }</span>
        <span class="cov8" title="1">idxDup := strings.LastIndex(uInsertQuery, "ON DUPLICATE KEY")
        if idxDup != -1 </span><span class="cov8" title="1">{
                if idxDup &gt; 0 &amp;&amp; uInsertQuery[idxDup-1] == ' ' </span><span class="cov8" title="1">{
                        idxDup -= 1
                }</span>
                <span class="cov8" title="1">end = idxDup</span>
        }

        <span class="cov8" title="1">resQuery = insertQuery[begin:end]
        return resQuery</span>
}

// 统计表达式中，非字符的?个数
func CountQuestionMark(str string) int <span class="cov8" title="1">{

        // in string
        var cnt int
        var instr1 bool = false // stand for '
        var instr2 bool = false // stand for "

        for i := 0; i &lt; len(str); i++ </span><span class="cov8" title="1">{
                if str[i] == '\'' &amp;&amp; !instr2 </span><span class="cov8" title="1">{
                        instr1 = !instr1
                }</span>
                <span class="cov8" title="1">if str[i] == '"' &amp;&amp; !instr1 </span><span class="cov8" title="1">{
                        instr2 = !instr2
                }</span>

                <span class="cov8" title="1">if !instr1 &amp;&amp; !instr2 &amp;&amp; str[i] == '?' </span><span class="cov8" title="1">{
                        cnt++
                }</span>
        }

        <span class="cov8" title="1">return cnt</span>
}

// 统计正规化后表达式中，用?替换:vx
func ReplaceColonMark(str string) string <span class="cov8" title="1">{

        // in string
        var instr1 bool = false // stand for '
        var instr2 bool = false // stand for "

        var result []byte
        for i := 0; i &lt; len(str); i++ </span><span class="cov8" title="1">{
                if str[i] == '\'' &amp;&amp; !instr2 </span><span class="cov8" title="1">{
                        instr1 = !instr1
                }</span>
                <span class="cov8" title="1">if str[i] == '"' &amp;&amp; !instr1 </span><span class="cov8" title="1">{
                        instr2 = !instr2
                }</span>

                <span class="cov8" title="1">if !instr1 &amp;&amp; !instr2 &amp;&amp; str[i] == ':' </span><span class="cov8" title="1">{
                        idxSpace := strings.IndexAny(str[i:], " ,)(")
                        result = append(result, '?')
                        if idxSpace != -1 </span><span class="cov8" title="1">{
                                i = i + idxSpace - 1
                        }</span> else<span class="cov8" title="1"> {
                                i = len(str) - 1
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">result = append(result, str[i])</span>
        }

        <span class="cov8" title="1">return string(result)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2018 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/x509"
        "encoding/pem"
        "sync"
)

// server pub keys registry
var (
        serverPubKeyLock     sync.RWMutex
        serverPubKeyRegistry map[string]*rsa.PublicKey
)

// RegisterServerPubKey registers a server RSA public key which can be used to
// send data in a secure manner to the server without receiving the public key
// in a potentially insecure way from the server first.
// Registered keys can afterwards be used adding serverPubKey=&lt;name&gt; to the DSN.
//
// Note: The provided rsa.PublicKey instance is exclusively owned by the driver
// after registering it and may not be modified.
//
//  data, err := ioutil.ReadFile("mykey.pem")
//  if err != nil {
//          log.Fatal(err)
//  }
//
//  block, _ := pem.Decode(data)
//  if block == nil || block.Type != "PUBLIC KEY" {
//          log.Fatal("failed to decode PEM block containing public key")
//  }
//
//  pub, err := x509.ParsePKIXPublicKey(block.Bytes)
//  if err != nil {
//          log.Fatal(err)
//  }
//
//  if rsaPubKey, ok := pub.(*rsa.PublicKey); ok {
//          mysql.RegisterServerPubKey("mykey", rsaPubKey)
//  } else {
//          log.Fatal("not a RSA public key")
//  }
//
func RegisterServerPubKey(name string, pubKey *rsa.PublicKey) <span class="cov8" title="1">{
        serverPubKeyLock.Lock()
        if serverPubKeyRegistry == nil </span><span class="cov8" title="1">{
                serverPubKeyRegistry = make(map[string]*rsa.PublicKey)
        }</span>

        <span class="cov8" title="1">serverPubKeyRegistry[name] = pubKey
        serverPubKeyLock.Unlock()</span>
}

// DeregisterServerPubKey removes the public key registered with the given name.
func DeregisterServerPubKey(name string) <span class="cov8" title="1">{
        serverPubKeyLock.Lock()
        if serverPubKeyRegistry != nil </span><span class="cov8" title="1">{
                delete(serverPubKeyRegistry, name)
        }</span>
        <span class="cov8" title="1">serverPubKeyLock.Unlock()</span>
}

func getServerPubKey(name string) (pubKey *rsa.PublicKey) <span class="cov8" title="1">{
        serverPubKeyLock.RLock()
        if v, ok := serverPubKeyRegistry[name]; ok </span><span class="cov8" title="1">{
                pubKey = v
        }</span>
        <span class="cov8" title="1">serverPubKeyLock.RUnlock()
        return</span>
}

// Hash password using pre 4.1 (old password) method
// https://github.com/atcurtis/mariadb/blob/master/mysys/my_rnd.c
type myRnd struct {
        seed1, seed2 uint32
}

const myRndMaxVal = 0x3FFFFFFF

// Pseudo random number generator
func newMyRnd(seed1, seed2 uint32) *myRnd <span class="cov8" title="1">{
        return &amp;myRnd{
                seed1: seed1 % myRndMaxVal,
                seed2: seed2 % myRndMaxVal,
        }
}</span>

// Tested to be equivalent to MariaDB's floating point variant
// http://play.golang.org/p/QHvhd4qved
// http://play.golang.org/p/RG0q4ElWDx
func (r *myRnd) NextByte() byte <span class="cov8" title="1">{
        r.seed1 = (r.seed1*3 + r.seed2) % myRndMaxVal
        r.seed2 = (r.seed1 + r.seed2 + 33) % myRndMaxVal

        return byte(uint64(r.seed1) * 31 / myRndMaxVal)
}</span>

// Generate binary hash from byte string using insecure pre 4.1 method
func pwHash(password []byte) (result [2]uint32) <span class="cov8" title="1">{
        var add uint32 = 7
        var tmp uint32

        result[0] = 1345345333
        result[1] = 0x12345671

        for _, c := range password </span><span class="cov8" title="1">{
                // skip spaces and tabs in password
                if c == ' ' || c == '\t' </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">tmp = uint32(c)
                result[0] ^= (((result[0] &amp; 63) + add) * tmp) + (result[0] &lt;&lt; 8)
                result[1] += (result[1] &lt;&lt; 8) ^ result[0]
                add += tmp</span>
        }

        // Remove sign bit (1&lt;&lt;31)-1)
        <span class="cov8" title="1">result[0] &amp;= 0x7FFFFFFF
        result[1] &amp;= 0x7FFFFFFF

        return</span>
}

// Hash password using insecure pre 4.1 method
func scrambleOldPassword(scramble []byte, password string) []byte <span class="cov8" title="1">{
        if len(password) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">scramble = scramble[:8]

        hashPw := pwHash([]byte(password))
        hashSc := pwHash(scramble)

        r := newMyRnd(hashPw[0]^hashSc[0], hashPw[1]^hashSc[1])

        var out [8]byte
        for i := range out </span><span class="cov8" title="1">{
                out[i] = r.NextByte() + 64
        }</span>

        <span class="cov8" title="1">mask := r.NextByte()
        for i := range out </span><span class="cov8" title="1">{
                out[i] ^= mask
        }</span>

        <span class="cov8" title="1">return out[:]</span>
}

// Hash password using 4.1+ method (SHA1)
func scramblePassword(scramble []byte, password string) []byte <span class="cov8" title="1">{
        if len(password) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // stage1Hash = SHA1(password)
        <span class="cov8" title="1">crypt := sha1.New()
        _, _ = crypt.Write([]byte(password))
        stage1 := crypt.Sum(nil)

        // scrambleHash = SHA1(scramble + SHA1(stage1Hash))
        // inner Hash
        crypt.Reset()
        _, _ = crypt.Write(stage1)
        hash := crypt.Sum(nil)

        // outer Hash
        crypt.Reset()
        _, _ = crypt.Write(scramble)
        _, _ = crypt.Write(hash)
        scramble = crypt.Sum(nil)

        // token = scrambleHash XOR stage1Hash
        for i := range scramble </span><span class="cov8" title="1">{
                scramble[i] ^= stage1[i]
        }</span>
        <span class="cov8" title="1">return scramble</span>
}

// Hash password using MySQL 8+ method (SHA256)
func scrambleSHA256Password(scramble []byte, password string) []byte <span class="cov8" title="1">{
        if len(password) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // XOR(SHA256(password), SHA256(SHA256(SHA256(password)), scramble))

        <span class="cov8" title="1">crypt := sha256.New()
        _, _ = crypt.Write([]byte(password))
        message1 := crypt.Sum(nil)

        crypt.Reset()
        _, _ = crypt.Write(message1)
        message1Hash := crypt.Sum(nil)

        crypt.Reset()
        _, _ = crypt.Write(message1Hash)
        _, _ = crypt.Write(scramble)
        message2 := crypt.Sum(nil)

        for i := range message1 </span><span class="cov8" title="1">{
                message1[i] ^= message2[i]
        }</span>

        <span class="cov8" title="1">return message1</span>
}

func encryptPassword(password string, seed []byte, pub *rsa.PublicKey) ([]byte, error) <span class="cov8" title="1">{
        plain := make([]byte, len(password)+1)
        copy(plain, password)
        for i := range plain </span><span class="cov8" title="1">{
                j := i % len(seed)
                plain[i] ^= seed[j]
        }</span>
        <span class="cov8" title="1">sha1 := sha1.New()
        return rsa.EncryptOAEP(sha1, rand.Reader, pub, plain, nil)</span>
}

func (mc *mysqlConn) sendEncryptedPassword(seed []byte, pub *rsa.PublicKey) error <span class="cov8" title="1">{
        enc, err := encryptPassword(mc.cfg.Passwd, seed, pub)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return mc.writeAuthSwitchPacket(enc)</span>
}

func (mc *mysqlConn) auth(authData []byte, plugin string) ([]byte, error) <span class="cov8" title="1">{
        switch plugin </span>{
        case "caching_sha2_password":<span class="cov8" title="1">
                authResp := scrambleSHA256Password(authData, mc.cfg.Passwd)
                return authResp, nil</span>

        case "mysql_old_password":<span class="cov8" title="1">
                if !mc.cfg.AllowOldPasswords </span><span class="cov8" title="1">{
                        return nil, ErrOldPassword
                }</span>
                // Note: there are edge cases where this should work but doesn't;
                // this is currently "wontfix":
                // https://github.com/go-sql-driver/mysql/issues/184
                <span class="cov8" title="1">authResp := append(scrambleOldPassword(authData[:8], mc.cfg.Passwd), 0)
                return authResp, nil</span>

        case "mysql_clear_password":<span class="cov8" title="1">
                if !mc.cfg.AllowCleartextPasswords </span><span class="cov8" title="1">{
                        return nil, ErrCleartextPassword
                }</span>
                // http://dev.mysql.com/doc/refman/5.7/en/cleartext-authentication-plugin.html
                // http://dev.mysql.com/doc/refman/5.7/en/pam-authentication-plugin.html
                <span class="cov8" title="1">return append([]byte(mc.cfg.Passwd), 0), nil</span>

        case "mysql_native_password":<span class="cov8" title="1">
                if !mc.cfg.AllowNativePasswords </span><span class="cov8" title="1">{
                        return nil, ErrNativePassword
                }</span>
                // https://dev.mysql.com/doc/internals/en/secure-password-authentication.html
                // Native password authentication only need and will need 20-byte challenge.
                <span class="cov8" title="1">authResp := scramblePassword(authData[:20], mc.cfg.Passwd)
                return authResp, nil</span>

        case "sha256_password":<span class="cov8" title="1">
                if len(mc.cfg.Passwd) == 0 </span><span class="cov8" title="1">{
                        return []byte{0}, nil
                }</span>
                <span class="cov8" title="1">if mc.cfg.tls != nil || mc.cfg.Net == "unix" </span><span class="cov8" title="1">{
                        // write cleartext auth packet
                        return append([]byte(mc.cfg.Passwd), 0), nil
                }</span>

                <span class="cov8" title="1">pubKey := mc.cfg.pubKey
                if pubKey == nil </span><span class="cov8" title="1">{
                        // request public key from server
                        return []byte{1}, nil
                }</span>

                // encrypted password
                <span class="cov8" title="1">enc, err := encryptPassword(mc.cfg.Passwd, authData, pubKey)
                return enc, err</span>

        default:<span class="cov0" title="0">
                errLog.Print("unknown auth plugin:", plugin)
                return nil, ErrUnknownPlugin</span>
        }
}

func (mc *mysqlConn) handleAuthResult(oldAuthData []byte, plugin string) error <span class="cov8" title="1">{
        // Read Result Packet
        authData, newPlugin, err := mc.readAuthResult()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // handle auth plugin switch, if requested
        <span class="cov8" title="1">if newPlugin != "" </span><span class="cov8" title="1">{
                // If CLIENT_PLUGIN_AUTH capability is not supported, no new cipher is
                // sent and we have to keep using the cipher sent in the init packet.
                if authData == nil </span><span class="cov8" title="1">{
                        authData = oldAuthData
                }</span> else<span class="cov8" title="1"> {
                        // copy data from read buffer to owned slice
                        copy(oldAuthData, authData)
                }</span>

                <span class="cov8" title="1">plugin = newPlugin

                authResp, err := mc.auth(authData, plugin)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err = mc.writeAuthSwitchPacket(authResp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Read Result Packet
                <span class="cov8" title="1">authData, newPlugin, err = mc.readAuthResult()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Do not allow to change the auth plugin more than once
                <span class="cov8" title="1">if newPlugin != "" </span><span class="cov0" title="0">{
                        return ErrMalformPkt
                }</span>
        }

        <span class="cov8" title="1">switch plugin </span>{

        // https://insidemysql.com/preparing-your-community-connector-for-mysql-8-part-2-sha256/
        case "caching_sha2_password":<span class="cov8" title="1">
                switch len(authData) </span>{
                case 0:<span class="cov8" title="1">
                        return nil</span> // auth successful
                case 1:<span class="cov8" title="1">
                        switch authData[0] </span>{
                        case cachingSha2PasswordFastAuthSuccess:<span class="cov8" title="1">
                                if err = mc.readResultOK(); err == nil </span><span class="cov8" title="1">{
                                        return nil // auth successful
                                }</span>

                        case cachingSha2PasswordPerformFullAuthentication:<span class="cov8" title="1">
                                if mc.cfg.tls != nil || mc.cfg.Net == "unix" </span><span class="cov8" title="1">{
                                        // write cleartext auth packet
                                        err = mc.writeAuthSwitchPacket(append([]byte(mc.cfg.Passwd), 0))
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        pubKey := mc.cfg.pubKey
                                        if pubKey == nil </span><span class="cov8" title="1">{
                                                // request public key from server
                                                data, err := mc.buf.takeSmallBuffer(4 + 1)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov8" title="1">data[4] = cachingSha2PasswordRequestPublicKey
                                                _ = mc.writePacket(data)

                                                // parse public key
                                                if data, err = mc.readPacket(); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>

                                                <span class="cov8" title="1">block, _ := pem.Decode(data[1:])
                                                pkix, err := x509.ParsePKIXPublicKey(block.Bytes)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov8" title="1">pubKey = pkix.(*rsa.PublicKey)</span>
                                        }

                                        // send encrypted password
                                        <span class="cov8" title="1">err = mc.sendEncryptedPassword(oldAuthData, pubKey)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                                <span class="cov8" title="1">return mc.readResultOK()</span>

                        default:<span class="cov0" title="0">
                                return ErrMalformPkt</span>
                        }
                default:<span class="cov0" title="0">
                        return ErrMalformPkt</span>
                }

        case "sha256_password":<span class="cov8" title="1">
                switch len(authData) </span>{
                case 0:<span class="cov8" title="1">
                        return nil</span> // auth successful
                default:<span class="cov8" title="1">
                        block, _ := pem.Decode(authData)
                        pub, err := x509.ParsePKIXPublicKey(block.Bytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // send encrypted password
                        <span class="cov8" title="1">err = mc.sendEncryptedPassword(oldAuthData, pub.(*rsa.PublicKey))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return mc.readResultOK()</span>
                }

        default:<span class="cov8" title="1">
                return nil</span> // auth successful
        }

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "io"
        "net"
        "time"
)

const defaultBufSize = 4096
const maxCachedBufSize = 256 * 1024

// A buffer which is used for both reading and writing.
// This is possible since communication on each connection is synchronous.
// In other words, we can't write and read simultaneously on the same connection.
// The buffer is similar to bufio.Reader / Writer but zero-copy-ish
// Also highly optimized for this particular use case.
// This buffer is backed by two byte slices in a double-buffering scheme
type buffer struct {
        buf     []byte // buf is a byte buffer who's length and capacity are equal.
        nc      net.Conn
        idx     int
        length  int
        timeout time.Duration
        dbuf    [2][]byte // dbuf is an array with the two byte slices that back this buffer
        flipcnt uint      // flipccnt is the current buffer counter for double-buffering
}

// newBuffer allocates and returns a new buffer.
func newBuffer(nc net.Conn) buffer <span class="cov8" title="1">{
        fg := make([]byte, defaultBufSize)
        return buffer{
                buf:  fg,
                nc:   nc,
                dbuf: [2][]byte{fg, nil},
        }
}</span>

// flip replaces the active buffer with the background buffer
// this is a delayed flip that simply increases the buffer counter;
// the actual flip will be performed the next time we call `buffer.fill`
func (b *buffer) flip() <span class="cov8" title="1">{
        b.flipcnt += 1
}</span>

// fill reads into the buffer until at least _need_ bytes are in it
func (b *buffer) fill(need int) error <span class="cov8" title="1">{
        n := b.length
        // fill data into its double-buffering target: if we've called
        // flip on this buffer, we'll be copying to the background buffer,
        // and then filling it with network data; otherwise we'll just move
        // the contents of the current buffer to the front before filling it
        dest := b.dbuf[b.flipcnt&amp;1]

        // grow buffer if necessary to fit the whole packet.
        if need &gt; len(dest) </span><span class="cov8" title="1">{
                // Round up to the next multiple of the default size
                dest = make([]byte, ((need/defaultBufSize)+1)*defaultBufSize)

                // if the allocated buffer is not too large, move it to backing storage
                // to prevent extra allocations on applications that perform large reads
                if len(dest) &lt;= maxCachedBufSize </span><span class="cov8" title="1">{
                        b.dbuf[b.flipcnt&amp;1] = dest
                }</span>
        }

        // if we're filling the fg buffer, move the existing data to the start of it.
        // if we're filling the bg buffer, copy over the data
        <span class="cov8" title="1">if n &gt; 0 </span><span class="cov8" title="1">{
                copy(dest[:n], b.buf[b.idx:])
        }</span>

        <span class="cov8" title="1">b.buf = dest
        b.idx = 0

        for </span><span class="cov8" title="1">{
                if b.timeout &gt; 0 </span><span class="cov0" title="0">{
                        if err := b.nc.SetReadDeadline(time.Now().Add(b.timeout)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">nn, err := b.nc.Read(b.buf[n:])
                n += nn

                switch err </span>{
                case nil:<span class="cov8" title="1">
                        if n &lt; need </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">b.length = n
                        return nil</span>

                case io.EOF:<span class="cov0" title="0">
                        if n &gt;= need </span><span class="cov0" title="0">{
                                b.length = n
                                return nil
                        }</span>
                        <span class="cov0" title="0">return io.ErrUnexpectedEOF</span>

                default:<span class="cov8" title="1">
                        return err</span>
                }
        }
}

// returns next N bytes from buffer.
// The returned slice is only guaranteed to be valid until the next read
func (b *buffer) readNext(need int) ([]byte, error) <span class="cov8" title="1">{
        if b.length &lt; need </span><span class="cov8" title="1">{
                // refill
                if err := b.fill(need); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">offset := b.idx
        b.idx += need
        b.length -= need
        return b.buf[offset:b.idx], nil</span>
}

// takeBuffer returns a buffer with the requested size.
// If possible, a slice from the existing buffer is returned.
// Otherwise a bigger buffer is made.
// Only one buffer (total) can be used at a time.
func (b *buffer) takeBuffer(length int) ([]byte, error) <span class="cov8" title="1">{
        if b.length &gt; 0 </span><span class="cov8" title="1">{
                return nil, ErrBusyBuffer
        }</span>

        // test (cheap) general case first
        <span class="cov8" title="1">if length &lt;= cap(b.buf) </span><span class="cov8" title="1">{
                return b.buf[:length], nil
        }</span>

        <span class="cov8" title="1">if length &lt; maxPacketSize </span><span class="cov8" title="1">{
                b.buf = make([]byte, length)
                return b.buf, nil
        }</span>

        // buffer is larger than we want to store.
        <span class="cov8" title="1">return make([]byte, length), nil</span>
}

// takeSmallBuffer is shortcut which can be used if length is
// known to be smaller than defaultBufSize.
// Only one buffer (total) can be used at a time.
func (b *buffer) takeSmallBuffer(length int) ([]byte, error) <span class="cov8" title="1">{
        if b.length &gt; 0 </span><span class="cov8" title="1">{
                return nil, ErrBusyBuffer
        }</span>
        <span class="cov8" title="1">return b.buf[:length], nil</span>
}

// takeCompleteBuffer returns the complete existing buffer.
// This can be used if the necessary buffer size is unknown.
// cap and len of the returned buffer will be equal.
// Only one buffer (total) can be used at a time.
func (b *buffer) takeCompleteBuffer() ([]byte, error) <span class="cov8" title="1">{
        if b.length &gt; 0 </span><span class="cov0" title="0">{
                return nil, ErrBusyBuffer
        }</span>
        <span class="cov8" title="1">return b.buf, nil</span>
}

// store stores buf, an updated buffer, if its suitable to do so.
func (b *buffer) store(buf []byte) error <span class="cov8" title="1">{
        if b.length &gt; 0 </span><span class="cov0" title="0">{
                return ErrBusyBuffer
        }</span> else<span class="cov8" title="1"> if cap(buf) &lt;= maxPacketSize &amp;&amp; cap(buf) &gt; cap(b.buf) </span><span class="cov8" title="1">{
                b.buf = buf[:cap(buf)]
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2019 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

// +build linux darwin dragonfly freebsd netbsd openbsd solaris illumos

package mysql

import (
        "errors"
        "io"
        "net"
        "syscall"
)

var errUnexpectedRead = errors.New("unexpected read from socket")

func connCheck(conn net.Conn) error <span class="cov8" title="1">{
        var sysErr error

        sysConn, ok := conn.(syscall.Conn)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">rawConn, err := sysConn.SyscallConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = rawConn.Read(func(fd uintptr) bool </span><span class="cov8" title="1">{
                var buf [1]byte
                n, err := syscall.Read(int(fd), buf[:])
                switch </span>{
                case n == 0 &amp;&amp; err == nil:<span class="cov8" title="1">
                        sysErr = io.EOF</span>
                case n &gt; 0:<span class="cov0" title="0">
                        sysErr = errUnexpectedRead</span>
                case err == syscall.EAGAIN || err == syscall.EWOULDBLOCK:<span class="cov8" title="1">
                        sysErr = nil</span>
                default:<span class="cov0" title="0">
                        sysErr = err</span>
                }
                <span class="cov8" title="1">return true</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return sysErr</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "context"
        "database/sql"
        "database/sql/driver"
        "encoding/json"
        "io"
        // syslog "log"
        "net"
        "strconv"
        "strings"
        "time"
)

type mysqlConn struct {
        buf              buffer
        netConn          net.Conn
        rawConn          net.Conn // underlying connection when netConn is TLS connection.
        affectedRows     uint64
        insertId         uint64
        cfg              *Config
        maxAllowedPacket int
        maxWriteSize     int
        writeTimeout     time.Duration
        flags            clientFlag
        status           statusFlag
        sequence         uint8
        parseTime        bool
        reset            bool // set when the Go SQL package calls ResetSession

        // for mskeeper
        connector *connector

        // for context support (Go 1.8+)
        watching bool
        watcher  chan&lt;- context.Context
        closech  chan struct{}
        finished chan&lt;- struct{}
        canceled atomicError // set non-nil if conn is canceled
        closed   atomicBool  // set when conn is closed, before closech is closed
}

// Handles parameters set in DSN after the connection is established
func (mc *mysqlConn) handleParams() (err error) <span class="cov8" title="1">{
        for param, val := range mc.cfg.Params </span><span class="cov8" title="1">{
                switch param </span>{
                // Charset
                case "charset":<span class="cov8" title="1">
                        charsets := strings.Split(val, ",")
                        for i := range charsets </span><span class="cov8" title="1">{
                                // ignore errors here - a charset may not exist
                                err = mc.exec("SET NAMES " + charsets[i])
                                if err == nil </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return
                        }</span>

                // System Vars
                default:<span class="cov8" title="1">
                        err = mc.exec("SET " + param + "=" + val + "")
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

func (mc *mysqlConn) markBadConn(err error) error <span class="cov8" title="1">{
        if mc == nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err != errBadConnNoWrite </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return driver.ErrBadConn</span>
}

func (mc *mysqlConn) Begin() (driver.Tx, error) <span class="cov0" title="0">{
        return mc.begin(false)
}</span>

func (mc *mysqlConn) begin(readOnly bool) (driver.Tx, error) <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">var q string
        if readOnly </span><span class="cov8" title="1">{
                q = "START TRANSACTION READ ONLY"
        }</span> else<span class="cov8" title="1"> {
                q = "START TRANSACTION"
        }</span>
        <span class="cov8" title="1">err := mc.exec(q)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;mysqlTx{mc}, err
        }</span>
        <span class="cov8" title="1">return nil, mc.markBadConn(err)</span>
}

func (mc *mysqlConn) Close() (err error) <span class="cov8" title="1">{
        // Makes Close idempotent
        if !mc.closed.IsSet() </span><span class="cov8" title="1">{
                err = mc.writeCommandPacket(comQuit)
        }</span>

        <span class="cov8" title="1">mc.cleanup()

        return</span>
}

// Closes the network connection and unsets internal variables. Do not call this
// function after successfully authentication, call Close instead. This function
// is called before auth or on auth failure because MySQL will have already
// closed the network connection.
func (mc *mysqlConn) cleanup() <span class="cov8" title="1">{
        if !mc.closed.TrySet(true) </span><span class="cov8" title="1">{
                return
        }</span>

        // Makes cleanup idempotent
        <span class="cov8" title="1">close(mc.closech)
        if mc.netConn == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if err := mc.netConn.Close(); err != nil </span><span class="cov0" title="0">{
                errLog.Print(err)
        }</span>
}

func (mc *mysqlConn) error() error <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov8" title="1">{
                if err := mc.canceled.Value(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">return ErrInvalidConn</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (mc *mysqlConn) Prepare(query string) (driver.Stmt, error) <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>
        // Send command
        <span class="cov8" title="1">err := mc.writeCommandPacketStr(comStmtPrepare, query)
        if err != nil </span><span class="cov0" title="0">{
                // STMT_PREPARE is safe to retry.  So we can return ErrBadConn here.
                errLog.Print(err)
                return nil, driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">stmt := &amp;mysqlStmt{
                mc:          mc,
                sqlPrepared: query,
        }

        // Read Result
        columnCount, err := stmt.readPrepareResultPacket()
        if err == nil </span><span class="cov8" title="1">{
                if stmt.paramCount &gt; 0 </span><span class="cov8" title="1">{
                        if err = mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">if columnCount &gt; 0 </span><span class="cov8" title="1">{
                        err = mc.readUntilEOF()
                }</span>
        }

        <span class="cov8" title="1">return stmt, err</span>
}

func (mc *mysqlConn) interpolateParams(query string, args []driver.Value) (string, error) <span class="cov8" title="1">{
        // Number of ? should be same to len(args)
        if strings.Count(query, "?") != len(args) </span><span class="cov8" title="1">{
                return "", driver.ErrSkip
        }</span>

        <span class="cov8" title="1">buf, err := mc.buf.takeCompleteBuffer()
        if err != nil </span><span class="cov0" title="0">{
                // can not take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return "", ErrInvalidConn
        }</span>
        <span class="cov8" title="1">buf = buf[:0]
        argPos := 0

        for i := 0; i &lt; len(query); i++ </span><span class="cov8" title="1">{
                q := strings.IndexByte(query[i:], '?')
                if q == -1 </span><span class="cov8" title="1">{
                        buf = append(buf, query[i:]...)
                        break</span>
                }
                <span class="cov8" title="1">buf = append(buf, query[i:i+q]...)
                i += q

                arg := args[argPos]
                argPos++

                if arg == nil </span><span class="cov8" title="1">{
                        buf = append(buf, "NULL"...)
                        continue</span>
                }

                <span class="cov8" title="1">switch v := arg.(type) </span>{
                case int64:<span class="cov8" title="1">
                        buf = strconv.AppendInt(buf, v, 10)</span>
                case uint64:<span class="cov8" title="1">
                        // Handle uint64 explicitly because our custom ConvertValue emits unsigned values
                        buf = strconv.AppendUint(buf, v, 10)</span>
                case float64:<span class="cov8" title="1">
                        buf = strconv.AppendFloat(buf, v, 'g', -1, 64)</span>
                case bool:<span class="cov8" title="1">
                        if v </span><span class="cov8" title="1">{
                                buf = append(buf, '1')
                        }</span> else<span class="cov8" title="1"> {
                                buf = append(buf, '0')
                        }</span>
                case time.Time:<span class="cov8" title="1">
                        if v.IsZero() </span><span class="cov8" title="1">{
                                buf = append(buf, "'0000-00-00'"...)
                        }</span> else<span class="cov8" title="1"> {
                                v := v.In(mc.cfg.Loc)
                                v = v.Add(time.Nanosecond * 500) // To round under microsecond
                                year := v.Year()
                                year100 := year / 100
                                year1 := year % 100
                                month := v.Month()
                                day := v.Day()
                                hour := v.Hour()
                                minute := v.Minute()
                                second := v.Second()
                                micro := v.Nanosecond() / 1000

                                buf = append(buf, []byte{
                                        '\'',
                                        digits10[year100], digits01[year100],
                                        digits10[year1], digits01[year1],
                                        '-',
                                        digits10[month], digits01[month],
                                        '-',
                                        digits10[day], digits01[day],
                                        ' ',
                                        digits10[hour], digits01[hour],
                                        ':',
                                        digits10[minute], digits01[minute],
                                        ':',
                                        digits10[second], digits01[second],
                                }...)

                                if micro != 0 </span><span class="cov0" title="0">{
                                        micro10000 := micro / 10000
                                        micro100 := micro / 100 % 100
                                        micro1 := micro % 100
                                        buf = append(buf, []byte{
                                                '.',
                                                digits10[micro10000], digits01[micro10000],
                                                digits10[micro100], digits01[micro100],
                                                digits10[micro1], digits01[micro1],
                                        }...)
                                }</span>
                                <span class="cov8" title="1">buf = append(buf, '\'')</span>
                        }
                case json.RawMessage:<span class="cov8" title="1">
                        buf = append(buf, '\'')
                        if mc.status&amp;statusNoBackslashEscapes == 0 </span><span class="cov8" title="1">{
                                buf = escapeBytesBackslash(buf, v)
                        }</span> else<span class="cov0" title="0"> {
                                buf = escapeBytesQuotes(buf, v)
                        }</span>
                        <span class="cov8" title="1">buf = append(buf, '\'')</span>
                case []byte:<span class="cov8" title="1">
                        if v == nil </span><span class="cov8" title="1">{
                                buf = append(buf, "NULL"...)
                        }</span> else<span class="cov8" title="1"> {
                                buf = append(buf, "_binary'"...)
                                if mc.status&amp;statusNoBackslashEscapes == 0 </span><span class="cov8" title="1">{
                                        buf = escapeBytesBackslash(buf, v)
                                }</span> else<span class="cov0" title="0"> {
                                        buf = escapeBytesQuotes(buf, v)
                                }</span>
                                <span class="cov8" title="1">buf = append(buf, '\'')</span>
                        }
                case string:<span class="cov8" title="1">
                        buf = append(buf, '\'')
                        if mc.status&amp;statusNoBackslashEscapes == 0 </span><span class="cov8" title="1">{
                                buf = escapeStringBackslash(buf, v)
                        }</span> else<span class="cov8" title="1"> {
                                buf = escapeStringQuotes(buf, v)
                        }</span>
                        <span class="cov8" title="1">buf = append(buf, '\'')</span>
                default:<span class="cov0" title="0">
                        return "", driver.ErrSkip</span>
                }

                <span class="cov8" title="1">if len(buf)+4 &gt; mc.maxAllowedPacket </span><span class="cov0" title="0">{
                        return "", driver.ErrSkip
                }</span>
        }
        <span class="cov8" title="1">if argPos != len(args) </span><span class="cov0" title="0">{
                return "", driver.ErrSkip
        }</span>
        <span class="cov8" title="1">return string(buf), nil</span>
}

func (mc *mysqlConn) Exec(query string, args []driver.Value) (driver.Result, error) <span class="cov8" title="1">{
        ts := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if mc.connector != nil </span><span class="cov8" title="1">{
                        mc.connector.msk.AfterProcess(ts, query, args)
                }</span>
        }()
        <span class="cov8" title="1">if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">if len(args) != 0 </span><span class="cov8" title="1">{
                if !mc.cfg.InterpolateParams </span><span class="cov8" title="1">{
                        return nil, driver.ErrSkip
                }</span>
                // try to interpolate the parameters to save extra roundtrips for preparing and closing a statement
                <span class="cov8" title="1">prepared, err := mc.interpolateParams(query, args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">query = prepared</span>
        }
        <span class="cov8" title="1">mc.affectedRows = 0
        mc.insertId = 0

        err := mc.exec(query)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;mysqlResult{
                        affectedRows: int64(mc.affectedRows),
                        insertId:     int64(mc.insertId),
                }, err
        }</span>
        <span class="cov8" title="1">return nil, mc.markBadConn(err)</span>
}

// Internal function to execute commands
func (mc *mysqlConn) exec(query string) error <span class="cov8" title="1">{
        // log.Printf("mysqlConn:exec %v", query)
        // Send command
        if err := mc.writeCommandPacketStr(comQuery, query); err != nil </span><span class="cov8" title="1">{
                return mc.markBadConn(err)
        }</span>

        // Read Result
        <span class="cov8" title="1">resLen, err := mc.readResultSetHeaderPacket()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if resLen &gt; 0 </span><span class="cov0" title="0">{
                // columns
                if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // rows
                <span class="cov0" title="0">if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return mc.discardResults()</span>
}

func (mc *mysqlConn) Query(query string, args []driver.Value) (driver.Rows, error, int) <span class="cov0" title="0">{
        return mc.query(query, args)
}</span>

func (mc *mysqlConn) query(query string, args []driver.Value) (*textRows, error, int) <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn, 1
        }</span>
        <span class="cov8" title="1">ts := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if mc.connector != nil </span><span class="cov8" title="1">{
                        mc.connector.msk.AfterProcess(ts, query, args)
                }</span>
        }()
        <span class="cov8" title="1">if len(args) != 0 </span><span class="cov8" title="1">{
                if !mc.cfg.InterpolateParams </span><span class="cov8" title="1">{
                        return nil, driver.ErrSkip, 1
                }</span>
                // try client-side prepare to reduce roundtrip
                <span class="cov8" title="1">prepared, err := mc.interpolateParams(query, args)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err, 1
                }</span>
                <span class="cov8" title="1">query = prepared</span>
        }
        // Send command
        <span class="cov8" title="1">err := mc.writeCommandPacketStr(comQuery, query)
        if err == nil </span><span class="cov8" title="1">{
                // Read Result
                var resLen int
                resLen, err = mc.readResultSetHeaderPacket()
                if err == nil </span><span class="cov8" title="1">{
                        rows := new(textRows)
                        rows.mc = mc

                        if resLen == 0 </span><span class="cov8" title="1">{
                                rows.rs.done = true

                                switch err := rows.NextResultSet(); err </span>{
                                case nil, io.EOF:<span class="cov8" title="1">
                                        return rows, nil, 1</span>
                                default:<span class="cov0" title="0">
                                        return nil, err, 1</span>
                                }
                        }

                        // Columns
                        <span class="cov8" title="1">rows.rs.columns, err = mc.readColumns(resLen)
                        return rows, err, 1</span>
                }
        }
        <span class="cov8" title="1">return nil, mc.markBadConn(err), 1</span>
}

// Gets the value of the given MySQL System Variable
// The returned byte slice is only valid until the next read
func (mc *mysqlConn) getSystemVar(name string) ([]byte, error) <span class="cov8" title="1">{
        // Send command
        if err := mc.writeCommandPacketStr(comQuery, "SELECT @@"+name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read Result
        <span class="cov8" title="1">resLen, err := mc.readResultSetHeaderPacket()
        if err == nil </span><span class="cov8" title="1">{
                rows := new(textRows)
                rows.mc = mc
                rows.rs.columns = []mysqlField{{fieldType: fieldTypeVarChar}}

                if resLen &gt; 0 </span><span class="cov8" title="1">{
                        // Columns
                        if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">dest := make([]driver.Value, resLen)
                if err = rows.readRow(dest); err == nil </span><span class="cov8" title="1">{
                        return dest[0].([]byte), mc.readUntilEOF()
                }</span>
        }
        <span class="cov0" title="0">return nil, err</span>
}

// finish is called when the query has canceled.
func (mc *mysqlConn) cancel(err error) <span class="cov8" title="1">{
        mc.canceled.Set(err)
        mc.cleanup()
}</span>

// finish is called when the query has succeeded.
func (mc *mysqlConn) finish() <span class="cov8" title="1">{
        if !mc.watching || mc.finished == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">select </span>{
        case mc.finished &lt;- struct{}{}:<span class="cov8" title="1">
                mc.watching = false</span>
        case &lt;-mc.closech:<span class="cov8" title="1"></span>
        }
}

// Ping implements driver.Pinger interface
func (mc *mysqlConn) Ping(ctx context.Context) (err error) <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">if err = mc.watchCancel(ctx); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">defer mc.finish()

        if err = mc.writeCommandPacket(comPing); err != nil </span><span class="cov8" title="1">{
                return mc.markBadConn(err)
        }</span>

        <span class="cov8" title="1">return mc.readResultOK()</span>
}

// BeginTx implements driver.ConnBeginTx interface
func (mc *mysqlConn) BeginTx(ctx context.Context, opts driver.TxOptions) (driver.Tx, error) <span class="cov8" title="1">{
        if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer mc.finish()

        if sql.IsolationLevel(opts.Isolation) != sql.LevelDefault </span><span class="cov8" title="1">{
                level, err := mapIsolationLevel(opts.Isolation)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">err = mc.exec("SET TRANSACTION ISOLATION LEVEL " + level)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return mc.begin(opts.ReadOnly)</span>
}

func (mc *mysqlConn) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) <span class="cov8" title="1">{

        dargs, err := namedValueToValue(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err, _ := mc.query(query, dargs)
        if err != nil </span><span class="cov8" title="1">{
                mc.finish()
                return nil, err
        }</span>
        <span class="cov8" title="1">rows.finish = mc.finish

        return rows, err</span>
}

func (mc *mysqlConn) ExecContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) <span class="cov8" title="1">{
        dargs, err := namedValueToValue(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer mc.finish()

        return mc.Exec(query, dargs)</span>
}

func (mc *mysqlConn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) <span class="cov8" title="1">{
        if err := mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stmt, err := mc.Prepare(query)
        mc.finish()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">select </span>{
        default:<span class="cov8" title="1"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                stmt.Close()
                return nil, ctx.Err()</span>
        }
        <span class="cov8" title="1">return stmt, nil</span>
}

func (stmt *mysqlStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) <span class="cov8" title="1">{
        dargs, err := namedValueToValue(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := stmt.mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err := stmt.query(dargs)
        if err != nil </span><span class="cov8" title="1">{
                stmt.mc.finish()
                return nil, err
        }</span>
        <span class="cov8" title="1">rows.finish = stmt.mc.finish
        return rows, err</span>
}

func (stmt *mysqlStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) <span class="cov8" title="1">{
        dargs, err := namedValueToValue(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := stmt.mc.watchCancel(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer stmt.mc.finish()

        return stmt.Exec(dargs)</span>
}

func (mc *mysqlConn) watchCancel(ctx context.Context) error <span class="cov8" title="1">{
        if mc.watching </span><span class="cov0" title="0">{
                // Reach here if canceled,
                // so the connection is already invalid
                mc.cleanup()
                return nil
        }</span>
        // When ctx is already cancelled, don't watch it.
        <span class="cov8" title="1">if err := ctx.Err(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // When ctx is not cancellable, don't watch it.
        <span class="cov8" title="1">if ctx.Done() == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // When watcher is not alive, can't watch it.
        <span class="cov8" title="1">if mc.watcher == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">mc.watching = true
        mc.watcher &lt;- ctx
        return nil</span>
}

func (mc *mysqlConn) startWatcher() <span class="cov8" title="1">{
        watcher := make(chan context.Context, 1)
        mc.watcher = watcher
        finished := make(chan struct{})
        mc.finished = finished
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        var ctx context.Context
                        select </span>{
                        case ctx = &lt;-watcher:<span class="cov8" title="1"></span>
                        case &lt;-mc.closech:<span class="cov8" title="1">
                                return</span>
                        }

                        <span class="cov8" title="1">select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                mc.cancel(ctx.Err())</span>
                        case &lt;-finished:<span class="cov8" title="1"></span>
                        case &lt;-mc.closech:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (mc *mysqlConn) CheckNamedValue(nv *driver.NamedValue) (err error) <span class="cov8" title="1">{
        nv.Value, err = converter{}.ConvertValue(nv.Value)
        return
}</span>

// ResetSession implements driver.SessionResetter.
// (From Go 1.10)
func (mc *mysqlConn) ResetSession(ctx context.Context) error <span class="cov8" title="1">{
        if mc.closed.IsSet() </span><span class="cov8" title="1">{
                return driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">mc.reset = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2018 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "context"
        "database/sql/driver"
        mskdriver "gitlab.papegames.com/fringe/mskeeper/driver"
        "net"
)

type connector struct {
        cfg *Config // immutable private copy.
        msk *mskdriver.MSKeeper
}

// Connect implements driver.Connector interface.
// Connect returns a connection to the database.
func (c *connector) Connect(ctx context.Context) (driver.Conn, error) <span class="cov8" title="1">{
        var err error

        // New mysqlConn
        mc := &amp;mysqlConn{
                connector:        c,
                maxAllowedPacket: maxPacketSize,
                maxWriteSize:     maxPacketSize - 1,
                closech:          make(chan struct{}),
                cfg:              c.cfg,
        }
        mc.parseTime = mc.cfg.ParseTime

        // Connect to Server
        dialsLock.RLock()
        dial, ok := dials[mc.cfg.Net]
        dialsLock.RUnlock()
        if ok </span><span class="cov8" title="1">{
                dctx := ctx
                if mc.cfg.Timeout &gt; 0 </span><span class="cov8" title="1">{
                        var cancel context.CancelFunc
                        dctx, cancel = context.WithTimeout(ctx, c.cfg.Timeout)
                        defer cancel()
                }</span>
                <span class="cov8" title="1">mc.netConn, err = dial(dctx, mc.cfg.Addr)</span>
        } else<span class="cov8" title="1"> {
                nd := net.Dialer{Timeout: mc.cfg.Timeout}
                mc.netConn, err = nd.DialContext(ctx, mc.cfg.Net, mc.cfg.Addr)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Enable TCP Keepalives on TCP connections
        <span class="cov8" title="1">if tc, ok := mc.netConn.(*net.TCPConn); ok </span><span class="cov8" title="1">{
                if err := tc.SetKeepAlive(true); err != nil </span><span class="cov0" title="0">{
                        // Don't send COM_QUIT before handshake.
                        mc.netConn.Close()
                        mc.netConn = nil
                        return nil, err
                }</span>
        }

        // Call startWatcher for context support (From Go 1.8)
        <span class="cov8" title="1">mc.startWatcher()
        if err := mc.watchCancel(ctx); err != nil </span><span class="cov8" title="1">{
                mc.cleanup()
                return nil, err
        }</span>
        <span class="cov8" title="1">defer mc.finish()

        mc.buf = newBuffer(mc.netConn)

        // Set I/O timeouts
        mc.buf.timeout = mc.cfg.ReadTimeout
        mc.writeTimeout = mc.cfg.WriteTimeout

        // Reading Handshake Initialization Packet
        authData, plugin, err := mc.readHandshakePacket()
        if err != nil </span><span class="cov8" title="1">{
                mc.cleanup()
                return nil, err
        }</span>

        <span class="cov8" title="1">if plugin == "" </span><span class="cov0" title="0">{
                plugin = defaultAuthPlugin
        }</span>

        // Send Client Authentication Packet
        <span class="cov8" title="1">authResp, err := mc.auth(authData, plugin)
        if err != nil </span><span class="cov0" title="0">{
                // try the default auth plugin, if using the requested plugin failed
                errLog.Print("could not use requested auth plugin '"+plugin+"': ", err.Error())
                plugin = defaultAuthPlugin
                authResp, err = mc.auth(authData, plugin)
                if err != nil </span><span class="cov0" title="0">{
                        mc.cleanup()
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if err = mc.writeHandshakeResponsePacket(authResp, plugin); err != nil </span><span class="cov0" title="0">{
                mc.cleanup()
                return nil, err
        }</span>

        // Handle response to auth packet, switch methods if possible
        <span class="cov8" title="1">if err = mc.handleAuthResult(authData, plugin); err != nil </span><span class="cov8" title="1">{
                // Authentication failed and MySQL has already closed the connection
                // (https://dev.mysql.com/doc/internals/en/authentication-fails.html).
                // Do not send COM_QUIT, just cleanup and return the error.
                mc.cleanup()
                return nil, err
        }</span>

        <span class="cov8" title="1">if mc.cfg.MaxAllowedPacket &gt; 0 </span><span class="cov8" title="1">{
                mc.maxAllowedPacket = mc.cfg.MaxAllowedPacket
        }</span> else<span class="cov8" title="1"> {
                // Get max allowed packet size
                maxap, err := mc.getSystemVar("max_allowed_packet")
                if err != nil </span><span class="cov0" title="0">{
                        mc.Close()
                        return nil, err
                }</span>
                <span class="cov8" title="1">mc.maxAllowedPacket = stringToInt(maxap) - 1</span>
        }
        <span class="cov8" title="1">if mc.maxAllowedPacket &lt; maxPacketSize </span><span class="cov8" title="1">{
                mc.maxWriteSize = mc.maxAllowedPacket
        }</span>

        // Handle DSN Params
        <span class="cov8" title="1">err = mc.handleParams()
        if err != nil </span><span class="cov8" title="1">{
                mc.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">return mc, nil</span>
}

// Driver implements driver.Connector interface.
// Driver returns &amp;MySQLDriver{}.
func (c *connector) Driver() driver.Driver <span class="cov0" title="0">{
        return &amp;MSKeeperDriver{}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2012 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

// Package mysql provides a MySQL driver for Go's database/sql package.
//
// The driver should be used via the database/sql package:
//
//  import "database/sql"
//  import _ "gitlab.papegames.com/fringe/mskeeper"
//
//  db, err := sql.Open("mskeeper", "user:password@/dbname")
//
// See https:gitlab.papegames.com/fringe/mskeeper for details
package mysql

import (
        "context"
        "database/sql"
        "database/sql/driver"
        "errors"
        mskdriver "gitlab.papegames.com/fringe/mskeeper/driver"
        "log"
        "net"
        "reflect"
        "sync"
)

var (
        ErrMSKeeperInstanceNil = errors.New("mskeeper instance no exists")
)

// Global connector array keeps track of all connections to mysql's driver
var mskDriver *MSKeeperDriver = &amp;MSKeeperDriver{}
var mskInstanceMap sync.Map

// MSKeeperDriver is exported to make the driver directly accessible.
// In general the driver is used via the database/sql package.
type MSKeeperDriver struct {
}

// DialFunc is a function which can be used to establish the network connection.
// Custom dial functions must be registered with RegisterDial
//
// Deprecated: users should register a DialContextFunc instead
type DialFunc func(addr string) (net.Conn, error)

// DialContextFunc is a function which can be used to establish the network connection.
// Custom dial functions must be registered with RegisterDialContext
type DialContextFunc func(ctx context.Context, addr string) (net.Conn, error)

var (
        dialsLock sync.RWMutex
        dials     map[string]DialContextFunc
)

// RegisterDialContext registers a custom dial function. It can then be used by the
// network address mynet(addr), where mynet is the registered new network.
// The current context for the connection and its address is passed to the dial function.
func RegisterDialContext(net string, dial DialContextFunc) <span class="cov8" title="1">{
        dialsLock.Lock()
        defer dialsLock.Unlock()
        if dials == nil </span><span class="cov8" title="1">{
                dials = make(map[string]DialContextFunc)
        }</span>
        <span class="cov8" title="1">dials[net] = dial</span>
}

// RegisterDial registers a custom dial function. It can then be used by the
// network address mynet(addr), where mynet is the registered new network.
// addr is passed as a parameter to the dial function.
//
// Deprecated: users should call RegisterDialContext instead
func RegisterDial(network string, dial DialFunc) <span class="cov8" title="1">{
        RegisterDialContext(network, func(_ context.Context, addr string) (net.Conn, error) </span><span class="cov8" title="1">{
                return dial(addr)
        }</span>)
}

// Open new Connection.
// See https://github.com/go-sql-driver/mysql#dsn-data-source-name for how
// the DSN string is formatted
func (d MSKeeperDriver) Open(dsn string) (driver.Conn, error) <span class="cov8" title="1">{
        cfg, err := ParseDSN(dsn)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c := &amp;connector{
                cfg: cfg,
        }

        formatedDSN := cfg.FormatDSN()
        msk := d.loadMSKeeperInstanceBy(formatedDSN)
        if msk == nil </span><span class="cov8" title="1">{
                msk = mskdriver.NewMSK(c)
                if err := mskDriver.storeMSKeeperInstanceWith(formatedDSN, msk); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">c.msk = msk

        return c.Connect(context.Background())</span>
}

func init() <span class="cov8" title="1">{
        sql.Register("mskeeper", mskDriver)
}</span>

func MSKeeperInstance(dsn string) *mskdriver.MSKeeper <span class="cov8" title="1">{
        cfg, err := ParseDSN(dsn)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("MSKeeperInstance failed to parse dsn %v", dsn)
                return nil
        }</span>

        <span class="cov8" title="1">if msk := mskDriver.loadMSKeeperInstanceBy(cfg.FormatDSN()); msk != nil </span><span class="cov8" title="1">{
                return msk
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewConnector returns new driver.Connector.
func NewConnector(cfg *Config) (driver.Connector, error) <span class="cov8" title="1">{
        cfg = cfg.Clone()
        // normalize the contents of cfg so calls to NewConnector have the same
        // behavior as MSKeeperDriver.OpenConnector
        if err := cfg.normalize(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c := &amp;connector{cfg: cfg}
        formatedDSN := cfg.FormatDSN()
        msk := mskDriver.loadMSKeeperInstanceBy(formatedDSN)
        if msk == nil </span><span class="cov8" title="1">{
                msk = mskdriver.NewMSK(c)
                if err := mskDriver.storeMSKeeperInstanceWith(formatedDSN, msk); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">c.msk = msk
        return c, nil</span>
}

// OpenConnector implements driver.DriverContext.
func (d MSKeeperDriver) OpenConnector(dsn string) (driver.Connector, error) <span class="cov8" title="1">{

        cfg, err := ParseDSN(dsn)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c := &amp;connector{
                cfg: cfg,
        }
        formatedDSN := cfg.FormatDSN()
        msk := d.loadMSKeeperInstanceBy(formatedDSN)
        if msk == nil </span><span class="cov8" title="1">{
                msk = mskdriver.NewMSK(c)
                if err := mskDriver.storeMSKeeperInstanceWith(formatedDSN, msk); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">c.msk = msk

        return c, nil</span>
}

// Load the mskeeper instance by formated dsn
func (d MSKeeperDriver) loadMSKeeperInstanceBy(formatedDSN string) *mskdriver.MSKeeper <span class="cov8" title="1">{

        msk, ok := mskInstanceMap.Load(formatedDSN)
        if ok </span><span class="cov8" title="1">{
                formatedMSK, okk := msk.(*mskdriver.MSKeeper)
                if okk </span><span class="cov8" title="1">{
                        return formatedMSK
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Load the mskeeper instance by formated dsn
func (d MSKeeperDriver) storeMSKeeperInstanceWith(formatedDSN string, msk *mskdriver.MSKeeper) error <span class="cov8" title="1">{
        actual, ok := mskInstanceMap.LoadOrStore(formatedDSN, msk)
        if !ok </span><span class="cov8" title="1">{
                if !reflect.DeepEqual(actual, msk) </span><span class="cov0" title="0">{
                        return errors.New("stored sth different with the expected MSKeeper")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2016 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "bytes"
        "crypto/rsa"
        "crypto/tls"
        "errors"
        "fmt"
        "math/big"
        "net"
        "net/url"
        "sort"
        "strconv"
        "strings"
        "time"
)

var (
        errInvalidDSNUnescaped       = errors.New("invalid DSN: did you forget to escape a param value?")
        errInvalidDSNAddr            = errors.New("invalid DSN: network address not terminated (missing closing brace)")
        errInvalidDSNNoSlash         = errors.New("invalid DSN: missing the slash separating the database name")
        errInvalidDSNUnsafeCollation = errors.New("invalid DSN: interpolateParams can not be used with unsafe collations")
)

// Config is a configuration parsed from a DSN string.
// If a new Config is created instead of being parsed from a DSN string,
// the NewConfig function should be used, which sets default values.
type Config struct {
        User             string            // Username
        Passwd           string            // Password (requires User)
        Net              string            // Network type
        Addr             string            // Network address (requires Net)
        DBName           string            // Database name
        Params           map[string]string // Connection parameters
        Collation        string            // Connection collation
        Loc              *time.Location    // Location for time.Time values
        MaxAllowedPacket int               // Max packet size allowed
        ServerPubKey     string            // Server public key name
        pubKey           *rsa.PublicKey    // Server public key
        TLSConfig        string            // TLS configuration name
        tls              *tls.Config       // TLS configuration
        Timeout          time.Duration     // Dial timeout
        ReadTimeout      time.Duration     // I/O read timeout
        WriteTimeout     time.Duration     // I/O write timeout

        AllowAllFiles           bool // Allow all files to be used with LOAD DATA LOCAL INFILE
        AllowCleartextPasswords bool // Allows the cleartext client side plugin
        AllowNativePasswords    bool // Allows the native password authentication method
        AllowOldPasswords       bool // Allows the old insecure password method
        CheckConnLiveness       bool // Check connections for liveness before using them
        ClientFoundRows         bool // Return number of matching rows instead of rows changed
        ColumnsWithAlias        bool // Prepend table alias to column names
        InterpolateParams       bool // Interpolate placeholders into query string
        MultiStatements         bool // Allow multiple statements in one query
        ParseTime               bool // Parse time values to time.Time
        RejectReadOnly          bool // Reject read-only connections
}

// NewConfig creates a new Config and sets default values.
func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Collation:            defaultCollation,
                Loc:                  time.UTC,
                MaxAllowedPacket:     defaultMaxAllowedPacket,
                AllowNativePasswords: true,
                CheckConnLiveness:    true,
        }
}</span>

func (cfg *Config) Clone() *Config <span class="cov8" title="1">{
        cp := *cfg
        if cp.tls != nil </span><span class="cov8" title="1">{
                cp.tls = cfg.tls.Clone()
        }</span>
        <span class="cov8" title="1">if len(cp.Params) &gt; 0 </span><span class="cov8" title="1">{
                cp.Params = make(map[string]string, len(cfg.Params))
                for k, v := range cfg.Params </span><span class="cov8" title="1">{
                        cp.Params[k] = v
                }</span>
        }
        <span class="cov8" title="1">if cfg.pubKey != nil </span><span class="cov8" title="1">{
                cp.pubKey = &amp;rsa.PublicKey{
                        N: new(big.Int).Set(cfg.pubKey.N),
                        E: cfg.pubKey.E,
                }
        }</span>
        <span class="cov8" title="1">return &amp;cp</span>
}

func (cfg *Config) normalize() error <span class="cov8" title="1">{
        if cfg.InterpolateParams &amp;&amp; unsafeCollations[cfg.Collation] </span><span class="cov8" title="1">{
                return errInvalidDSNUnsafeCollation
        }</span>

        // Set default network if empty
        <span class="cov8" title="1">if cfg.Net == "" </span><span class="cov8" title="1">{
                cfg.Net = "tcp"
        }</span>

        // Set default address if empty
        <span class="cov8" title="1">if cfg.Addr == "" </span><span class="cov8" title="1">{
                switch cfg.Net </span>{
                case "tcp":<span class="cov8" title="1">
                        cfg.Addr = "127.0.0.1:3306"</span>
                case "unix":<span class="cov8" title="1">
                        cfg.Addr = "/tmp/mysql.sock"</span>
                default:<span class="cov8" title="1">
                        return errors.New("default addr for network '" + cfg.Net + "' unknown")</span>
                }
        } else<span class="cov8" title="1"> if cfg.Net == "tcp" </span><span class="cov8" title="1">{
                cfg.Addr = ensureHavePort(cfg.Addr)
        }</span>

        <span class="cov8" title="1">switch cfg.TLSConfig </span>{
        case "false", "":<span class="cov8" title="1"></span>
                // don't set anything
        case "true":<span class="cov8" title="1">
                cfg.tls = &amp;tls.Config{}</span>
        case "skip-verify", "preferred":<span class="cov8" title="1">
                cfg.tls = &amp;tls.Config{InsecureSkipVerify: true}</span>
        default:<span class="cov8" title="1">
                cfg.tls = getTLSConfigClone(cfg.TLSConfig)
                if cfg.tls == nil </span><span class="cov8" title="1">{
                        return errors.New("invalid value / unknown config name: " + cfg.TLSConfig)
                }</span>
        }

        <span class="cov8" title="1">if cfg.tls != nil &amp;&amp; cfg.tls.ServerName == "" &amp;&amp; !cfg.tls.InsecureSkipVerify </span><span class="cov8" title="1">{
                host, _, err := net.SplitHostPort(cfg.Addr)
                if err == nil </span><span class="cov8" title="1">{
                        cfg.tls.ServerName = host
                }</span>
        }

        <span class="cov8" title="1">if cfg.ServerPubKey != "" </span><span class="cov8" title="1">{
                cfg.pubKey = getServerPubKey(cfg.ServerPubKey)
                if cfg.pubKey == nil </span><span class="cov8" title="1">{
                        return errors.New("invalid value / unknown server pub key name: " + cfg.ServerPubKey)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func writeDSNParam(buf *bytes.Buffer, hasParam *bool, name, value string) <span class="cov8" title="1">{
        buf.Grow(1 + len(name) + 1 + len(value))
        if !*hasParam </span><span class="cov8" title="1">{
                *hasParam = true
                buf.WriteByte('?')
        }</span> else<span class="cov8" title="1"> {
                buf.WriteByte('&amp;')
        }</span>
        <span class="cov8" title="1">buf.WriteString(name)
        buf.WriteByte('=')
        buf.WriteString(value)</span>
}

// FormatDSN formats the given Config into a DSN string which can be passed to
// the driver.
func (cfg *Config) FormatDSN() string <span class="cov8" title="1">{
        var buf bytes.Buffer

        // [username[:password]@]
        if len(cfg.User) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(cfg.User)
                if len(cfg.Passwd) &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteByte(':')
                        buf.WriteString(cfg.Passwd)
                }</span>
                <span class="cov8" title="1">buf.WriteByte('@')</span>
        }

        // [protocol[(address)]]
        <span class="cov8" title="1">if len(cfg.Net) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(cfg.Net)
                if len(cfg.Addr) &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteByte('(')
                        buf.WriteString(cfg.Addr)
                        buf.WriteByte(')')
                }</span>
        }

        // /dbname
        <span class="cov8" title="1">buf.WriteByte('/')
        buf.WriteString(cfg.DBName)

        // [?param1=value1&amp;...&amp;paramN=valueN]
        hasParam := false

        if cfg.AllowAllFiles </span><span class="cov8" title="1">{
                hasParam = true
                buf.WriteString("?allowAllFiles=true")
        }</span>

        <span class="cov8" title="1">if cfg.AllowCleartextPasswords </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "allowCleartextPasswords", "true")
        }</span>

        <span class="cov8" title="1">if !cfg.AllowNativePasswords </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "allowNativePasswords", "false")
        }</span>

        <span class="cov8" title="1">if cfg.AllowOldPasswords </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "allowOldPasswords", "true")
        }</span>

        <span class="cov8" title="1">if !cfg.CheckConnLiveness </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "checkConnLiveness", "false")
        }</span>

        <span class="cov8" title="1">if cfg.ClientFoundRows </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "clientFoundRows", "true")
        }</span>

        <span class="cov8" title="1">if col := cfg.Collation; col != defaultCollation &amp;&amp; len(col) &gt; 0 </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "collation", col)
        }</span>

        <span class="cov8" title="1">if cfg.ColumnsWithAlias </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "columnsWithAlias", "true")
        }</span>

        <span class="cov8" title="1">if cfg.InterpolateParams </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "interpolateParams", "true")
        }</span>

        <span class="cov8" title="1">if cfg.Loc != time.UTC &amp;&amp; cfg.Loc != nil </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "loc", url.QueryEscape(cfg.Loc.String()))
        }</span>

        <span class="cov8" title="1">if cfg.MultiStatements </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "multiStatements", "true")
        }</span>

        <span class="cov8" title="1">if cfg.ParseTime </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "parseTime", "true")
        }</span>

        <span class="cov8" title="1">if cfg.ReadTimeout &gt; 0 </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "readTimeout", cfg.ReadTimeout.String())
        }</span>

        <span class="cov8" title="1">if cfg.RejectReadOnly </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "rejectReadOnly", "true")
        }</span>

        <span class="cov8" title="1">if len(cfg.ServerPubKey) &gt; 0 </span><span class="cov0" title="0">{
                writeDSNParam(&amp;buf, &amp;hasParam, "serverPubKey", url.QueryEscape(cfg.ServerPubKey))
        }</span>

        <span class="cov8" title="1">if cfg.Timeout &gt; 0 </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "timeout", cfg.Timeout.String())
        }</span>

        <span class="cov8" title="1">if len(cfg.TLSConfig) &gt; 0 </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "tls", url.QueryEscape(cfg.TLSConfig))
        }</span>

        <span class="cov8" title="1">if cfg.WriteTimeout &gt; 0 </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "writeTimeout", cfg.WriteTimeout.String())
        }</span>

        <span class="cov8" title="1">if cfg.MaxAllowedPacket != defaultMaxAllowedPacket </span><span class="cov8" title="1">{
                writeDSNParam(&amp;buf, &amp;hasParam, "maxAllowedPacket", strconv.Itoa(cfg.MaxAllowedPacket))
        }</span>

        // other params
        <span class="cov8" title="1">if cfg.Params != nil </span><span class="cov8" title="1">{
                var params []string
                for param := range cfg.Params </span><span class="cov8" title="1">{
                        params = append(params, param)
                }</span>
                <span class="cov8" title="1">sort.Strings(params)
                for _, param := range params </span><span class="cov8" title="1">{
                        writeDSNParam(&amp;buf, &amp;hasParam, param, url.QueryEscape(cfg.Params[param]))
                }</span>
        }

        <span class="cov8" title="1">return buf.String()</span>
}

// ParseDSN parses the DSN string to a Config
func ParseDSN(dsn string) (cfg *Config, err error) <span class="cov8" title="1">{
        // New config with some default values
        cfg = NewConfig()

        // [user[:password]@][net[(addr)]]/dbname[?param1=value1&amp;paramN=valueN]
        // Find the last '/' (since the password or the net addr might contain a '/')
        foundSlash := false
        for i := len(dsn) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if dsn[i] == '/' </span><span class="cov8" title="1">{
                        foundSlash = true
                        var j, k int

                        // left part is empty if i &lt;= 0
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                // [username[:password]@][protocol[(address)]]
                                // Find the last '@' in dsn[:i]
                                for j = i; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                                        if dsn[j] == '@' </span><span class="cov8" title="1">{
                                                // username[:password]
                                                // Find the first ':' in dsn[:j]
                                                for k = 0; k &lt; j; k++ </span><span class="cov8" title="1">{
                                                        if dsn[k] == ':' </span><span class="cov8" title="1">{
                                                                cfg.Passwd = dsn[k+1 : j]
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">cfg.User = dsn[:k]

                                                break</span>
                                        }
                                }

                                // [protocol[(address)]]
                                // Find the first '(' in dsn[j+1:i]
                                <span class="cov8" title="1">for k = j + 1; k &lt; i; k++ </span><span class="cov8" title="1">{
                                        if dsn[k] == '(' </span><span class="cov8" title="1">{
                                                // dsn[i-1] must be == ')' if an address is specified
                                                if dsn[i-1] != ')' </span><span class="cov8" title="1">{
                                                        if strings.ContainsRune(dsn[k+1:i], ')') </span><span class="cov8" title="1">{
                                                                return nil, errInvalidDSNUnescaped
                                                        }</span>
                                                        <span class="cov8" title="1">return nil, errInvalidDSNAddr</span>
                                                }
                                                <span class="cov8" title="1">cfg.Addr = dsn[k+1 : i-1]
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">cfg.Net = dsn[j+1 : k]</span>
                        }

                        // dbname[?param1=value1&amp;...&amp;paramN=valueN]
                        // Find the first '?' in dsn[i+1:]
                        <span class="cov8" title="1">for j = i + 1; j &lt; len(dsn); j++ </span><span class="cov8" title="1">{
                                if dsn[j] == '?' </span><span class="cov8" title="1">{
                                        if err = parseDSNParams(cfg, dsn[j+1:]); err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">cfg.DBName = dsn[i+1 : j]

                        break</span>
                }
        }

        <span class="cov8" title="1">if !foundSlash &amp;&amp; len(dsn) &gt; 0 </span><span class="cov8" title="1">{
                return nil, errInvalidDSNNoSlash
        }</span>

        <span class="cov8" title="1">if err = cfg.normalize(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return</span>
}

// parseDSNParams parses the DSN "query string"
// Values must be url.QueryEscape'ed
func parseDSNParams(cfg *Config, params string) (err error) <span class="cov8" title="1">{
        for _, v := range strings.Split(params, "&amp;") </span><span class="cov8" title="1">{
                param := strings.SplitN(v, "=", 2)
                if len(param) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // cfg params
                <span class="cov8" title="1">switch value := param[1]; param[0] </span>{
                // Disable INFILE whitelist / enable all files
                case "allowAllFiles":<span class="cov8" title="1">
                        var isBool bool
                        cfg.AllowAllFiles, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Use cleartext authentication mode (MySQL 5.5.10+)
                case "allowCleartextPasswords":<span class="cov8" title="1">
                        var isBool bool
                        cfg.AllowCleartextPasswords, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Use native password authentication
                case "allowNativePasswords":<span class="cov8" title="1">
                        var isBool bool
                        cfg.AllowNativePasswords, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Use old authentication mode (pre MySQL 4.1)
                case "allowOldPasswords":<span class="cov8" title="1">
                        var isBool bool
                        cfg.AllowOldPasswords, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Check connections for Liveness before using them
                case "checkConnLiveness":<span class="cov8" title="1">
                        var isBool bool
                        cfg.CheckConnLiveness, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Switch "rowsAffected" mode
                case "clientFoundRows":<span class="cov8" title="1">
                        var isBool bool
                        cfg.ClientFoundRows, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Collation
                case "collation":<span class="cov8" title="1">
                        cfg.Collation = value</span>

                case "columnsWithAlias":<span class="cov8" title="1">
                        var isBool bool
                        cfg.ColumnsWithAlias, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Compression
                case "compress":<span class="cov0" title="0">
                        return errors.New("compression not implemented yet")</span>

                // Enable client side placeholder substitution
                case "interpolateParams":<span class="cov8" title="1">
                        var isBool bool
                        cfg.InterpolateParams, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Time Location
                case "loc":<span class="cov8" title="1">
                        if value, err = url.QueryUnescape(value); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">cfg.Loc, err = time.LoadLocation(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                // multiple statements in one query
                case "multiStatements":<span class="cov8" title="1">
                        var isBool bool
                        cfg.MultiStatements, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // time.Time parsing
                case "parseTime":<span class="cov8" title="1">
                        var isBool bool
                        cfg.ParseTime, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // I/O read Timeout
                case "readTimeout":<span class="cov8" title="1">
                        cfg.ReadTimeout, err = time.ParseDuration(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                // Reject read-only connections
                case "rejectReadOnly":<span class="cov8" title="1">
                        var isBool bool
                        cfg.RejectReadOnly, isBool = readBool(value)
                        if !isBool </span><span class="cov0" title="0">{
                                return errors.New("invalid bool value: " + value)
                        }</span>

                // Server public key
                case "serverPubKey":<span class="cov8" title="1">
                        name, err := url.QueryUnescape(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid value for server pub key name: %v", err)
                        }</span>
                        <span class="cov8" title="1">cfg.ServerPubKey = name</span>

                // Strict mode
                case "strict":<span class="cov0" title="0">
                        panic("strict mode has been removed. See https://github.com/go-sql-driver/mysql/wiki/strict-mode")</span>

                // Dial Timeout
                case "timeout":<span class="cov8" title="1">
                        cfg.Timeout, err = time.ParseDuration(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                // TLS-Encryption
                case "tls":<span class="cov8" title="1">
                        boolValue, isBool := readBool(value)
                        if isBool </span><span class="cov8" title="1">{
                                if boolValue </span><span class="cov8" title="1">{
                                        cfg.TLSConfig = "true"
                                }</span> else<span class="cov8" title="1"> {
                                        cfg.TLSConfig = "false"
                                }</span>
                        } else<span class="cov8" title="1"> if vl := strings.ToLower(value); vl == "skip-verify" || vl == "preferred" </span><span class="cov8" title="1">{
                                cfg.TLSConfig = vl
                        }</span> else<span class="cov8" title="1"> {
                                name, err := url.QueryUnescape(value)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid value for TLS config name: %v", err)
                                }</span>
                                <span class="cov8" title="1">cfg.TLSConfig = name</span>
                        }

                // I/O write Timeout
                case "writeTimeout":<span class="cov8" title="1">
                        cfg.WriteTimeout, err = time.ParseDuration(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                case "maxAllowedPacket":<span class="cov8" title="1">
                        cfg.MaxAllowedPacket, err = strconv.Atoi(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                default:<span class="cov8" title="1">
                        // lazy init
                        if cfg.Params == nil </span><span class="cov8" title="1">{
                                cfg.Params = make(map[string]string)
                        }</span>

                        <span class="cov8" title="1">if cfg.Params[param[0]], err = url.QueryUnescape(value); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

func ensureHavePort(addr string) string <span class="cov8" title="1">{
        if _, _, err := net.SplitHostPort(addr); err != nil </span><span class="cov8" title="1">{
                return net.JoinHostPort(addr, "3306")
        }</span>
        <span class="cov8" title="1">return addr</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "errors"
        "fmt"
        "log"
        "os"
)

// Various errors the driver might return. Can change between driver versions.
var (
        ErrInvalidConn       = errors.New("invalid connection")
        ErrMalformPkt        = errors.New("malformed packet")
        ErrNoTLS             = errors.New("TLS requested but server does not support TLS")
        ErrCleartextPassword = errors.New("this user requires clear text authentication. If you still want to use it, please add 'allowCleartextPasswords=1' to your DSN")
        ErrNativePassword    = errors.New("this user requires mysql native password authentication.")
        ErrOldPassword       = errors.New("this user requires old password authentication. If you still want to use it, please add 'allowOldPasswords=1' to your DSN. See also https://github.com/go-sql-driver/mysql/wiki/old_passwords")
        ErrUnknownPlugin     = errors.New("this authentication plugin is not supported")
        ErrOldProtocol       = errors.New("MySQL server does not support required protocol 41+")
        ErrPktSync           = errors.New("commands out of sync. You can't run this command now")
        ErrPktSyncMul        = errors.New("commands out of sync. Did you run multiple statements at once?")
        ErrPktTooLarge       = errors.New("packet for query is too large. Try adjusting the 'max_allowed_packet' variable on the server")
        ErrBusyBuffer        = errors.New("busy buffer")

        // errBadConnNoWrite is used for connection errors where nothing was sent to the database yet.
        // If this happens first in a function starting a database interaction, it should be replaced by driver.ErrBadConn
        // to trigger a resend.
        // See https://github.com/go-sql-driver/mysql/pull/302
        errBadConnNoWrite = errors.New("bad connection")
)

var errLog = Logger(log.New(os.Stderr, "[mysql] ", log.Ldate|log.Ltime|log.Lshortfile))

// Logger is used to log critical error messages.
type Logger interface {
        Print(v ...interface{})
}

// SetLogger is used to set the logger for critical errors.
// The initial logger is os.Stderr.
func SetLogger(logger Logger) error <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                return errors.New("logger is nil")
        }</span>
        <span class="cov8" title="1">errLog = logger
        return nil</span>
}

func GetLogger() Logger <span class="cov8" title="1">{
        return errLog
}</span>

// MySQLError is an error type which represents a single MySQL error
type MySQLError struct {
        Number  uint16
        Message string
}

func (me *MySQLError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Error %d: %s", me.Number, me.Message)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2017 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "database/sql"
        "reflect"
)

func (mf *mysqlField) typeDatabaseName() string <span class="cov8" title="1">{
        switch mf.fieldType </span>{
        case fieldTypeBit:<span class="cov8" title="1">
                return "BIT"</span>
        case fieldTypeBLOB:<span class="cov8" title="1">
                if mf.charSet != collations[binaryCollation] </span><span class="cov8" title="1">{
                        return "TEXT"
                }</span>
                <span class="cov8" title="1">return "BLOB"</span>
        case fieldTypeDate:<span class="cov8" title="1">
                return "DATE"</span>
        case fieldTypeDateTime:<span class="cov8" title="1">
                return "DATETIME"</span>
        case fieldTypeDecimal:<span class="cov8" title="1">
                return "DECIMAL"</span>
        case fieldTypeDouble:<span class="cov8" title="1">
                return "DOUBLE"</span>
        case fieldTypeEnum:<span class="cov0" title="0">
                return "ENUM"</span>
        case fieldTypeFloat:<span class="cov8" title="1">
                return "FLOAT"</span>
        case fieldTypeGeometry:<span class="cov8" title="1">
                return "GEOMETRY"</span>
        case fieldTypeInt24:<span class="cov8" title="1">
                return "MEDIUMINT"</span>
        case fieldTypeJSON:<span class="cov0" title="0">
                return "JSON"</span>
        case fieldTypeLong:<span class="cov8" title="1">
                return "INT"</span>
        case fieldTypeLongBLOB:<span class="cov8" title="1">
                if mf.charSet != collations[binaryCollation] </span><span class="cov8" title="1">{
                        return "TEXT"
                }</span>
                <span class="cov8" title="1">return "BLOB"</span>
        case fieldTypeLongLong:<span class="cov8" title="1">
                return "BIGINT"</span>
        case fieldTypeMediumBLOB:<span class="cov8" title="1">
                if mf.charSet != collations[binaryCollation] </span><span class="cov8" title="1">{
                        return "TEXT"
                }</span>
                <span class="cov8" title="1">return "BLOB"</span>
        case fieldTypeNewDate:<span class="cov8" title="1">
                return "DATE"</span>
        case fieldTypeNewDecimal:<span class="cov8" title="1">
                return "DECIMAL"</span>
        case fieldTypeNULL:<span class="cov0" title="0">
                return "NULL"</span>
        case fieldTypeSet:<span class="cov0" title="0">
                return "SET"</span>
        case fieldTypeShort:<span class="cov8" title="1">
                return "SMALLINT"</span>
        case fieldTypeString:<span class="cov8" title="1">
                if mf.charSet == collations[binaryCollation] </span><span class="cov8" title="1">{
                        return "BINARY"
                }</span>
                <span class="cov8" title="1">return "CHAR"</span>
        case fieldTypeTime:<span class="cov8" title="1">
                return "TIME"</span>
        case fieldTypeTimestamp:<span class="cov8" title="1">
                return "TIMESTAMP"</span>
        case fieldTypeTiny:<span class="cov8" title="1">
                return "TINYINT"</span>
        case fieldTypeTinyBLOB:<span class="cov8" title="1">
                if mf.charSet != collations[binaryCollation] </span><span class="cov8" title="1">{
                        return "TEXT"
                }</span>
                <span class="cov8" title="1">return "BLOB"</span>
        case fieldTypeVarChar:<span class="cov8" title="1">
                if mf.charSet == collations[binaryCollation] </span><span class="cov8" title="1">{
                        return "VARBINARY"
                }</span>
                <span class="cov8" title="1">return "VARCHAR"</span>
        case fieldTypeVarString:<span class="cov8" title="1">
                if mf.charSet == collations[binaryCollation] </span><span class="cov8" title="1">{
                        return "VARBINARY"
                }</span>
                <span class="cov8" title="1">return "VARCHAR"</span>
        case fieldTypeYear:<span class="cov8" title="1">
                return "YEAR"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

var (
        scanTypeFloat32   = reflect.TypeOf(float32(0))
        scanTypeFloat64   = reflect.TypeOf(float64(0))
        scanTypeInt8      = reflect.TypeOf(int8(0))
        scanTypeInt16     = reflect.TypeOf(int16(0))
        scanTypeInt32     = reflect.TypeOf(int32(0))
        scanTypeInt64     = reflect.TypeOf(int64(0))
        scanTypeNullFloat = reflect.TypeOf(sql.NullFloat64{})
        scanTypeNullInt   = reflect.TypeOf(sql.NullInt64{})
        scanTypeNullTime  = reflect.TypeOf(NullTime{})
        scanTypeUint8     = reflect.TypeOf(uint8(0))
        scanTypeUint16    = reflect.TypeOf(uint16(0))
        scanTypeUint32    = reflect.TypeOf(uint32(0))
        scanTypeUint64    = reflect.TypeOf(uint64(0))
        scanTypeRawBytes  = reflect.TypeOf(sql.RawBytes{})
        scanTypeUnknown   = reflect.TypeOf(new(interface{}))
)

type mysqlField struct {
        tableName string
        name      string
        length    uint32
        flags     fieldFlag
        fieldType fieldType
        decimals  byte
        charSet   uint8
}

func (mf *mysqlField) scanType() reflect.Type <span class="cov8" title="1">{
        switch mf.fieldType </span>{
        case fieldTypeTiny:<span class="cov8" title="1">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov8" title="1">{
                        if mf.flags&amp;flagUnsigned != 0 </span><span class="cov8" title="1">{
                                return scanTypeUint8
                        }</span>
                        <span class="cov8" title="1">return scanTypeInt8</span>
                }
                <span class="cov8" title="1">return scanTypeNullInt</span>

        case fieldTypeShort, fieldTypeYear:<span class="cov8" title="1">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov8" title="1">{
                        if mf.flags&amp;flagUnsigned != 0 </span><span class="cov8" title="1">{
                                return scanTypeUint16
                        }</span>
                        <span class="cov8" title="1">return scanTypeInt16</span>
                }
                <span class="cov8" title="1">return scanTypeNullInt</span>

        case fieldTypeInt24, fieldTypeLong:<span class="cov8" title="1">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov8" title="1">{
                        if mf.flags&amp;flagUnsigned != 0 </span><span class="cov8" title="1">{
                                return scanTypeUint32
                        }</span>
                        <span class="cov8" title="1">return scanTypeInt32</span>
                }
                <span class="cov8" title="1">return scanTypeNullInt</span>

        case fieldTypeLongLong:<span class="cov8" title="1">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov8" title="1">{
                        if mf.flags&amp;flagUnsigned != 0 </span><span class="cov8" title="1">{
                                return scanTypeUint64
                        }</span>
                        <span class="cov8" title="1">return scanTypeInt64</span>
                }
                <span class="cov8" title="1">return scanTypeNullInt</span>

        case fieldTypeFloat:<span class="cov8" title="1">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov8" title="1">{
                        return scanTypeFloat32
                }</span>
                <span class="cov8" title="1">return scanTypeNullFloat</span>

        case fieldTypeDouble:<span class="cov8" title="1">
                if mf.flags&amp;flagNotNULL != 0 </span><span class="cov8" title="1">{
                        return scanTypeFloat64
                }</span>
                <span class="cov8" title="1">return scanTypeNullFloat</span>

        case fieldTypeDecimal, fieldTypeNewDecimal, fieldTypeVarChar,
                fieldTypeBit, fieldTypeEnum, fieldTypeSet, fieldTypeTinyBLOB,
                fieldTypeMediumBLOB, fieldTypeLongBLOB, fieldTypeBLOB,
                fieldTypeVarString, fieldTypeString, fieldTypeGeometry, fieldTypeJSON,
                fieldTypeTime:<span class="cov8" title="1">
                return scanTypeRawBytes</span>

        case fieldTypeDate, fieldTypeNewDate,
                fieldTypeTimestamp, fieldTypeDateTime:<span class="cov8" title="1">
                // NullTime is always returned for more consistent behavior as it can
                // handle both cases of parseTime regardless if the field is nullable.
                return scanTypeNullTime</span>

        default:<span class="cov0" title="0">
                return scanTypeUnknown</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "fmt"
        "io"
        "log"
        "os"
        "strings"
        "sync"
)

var (
        fileRegister       map[string]bool
        fileRegisterLock   sync.RWMutex
        readerRegister     map[string]func() io.Reader
        readerRegisterLock sync.RWMutex
)

// RegisterLocalFile adds the given file to the file whitelist,
// so that it can be used by "LOAD DATA LOCAL INFILE &lt;filepath&gt;".
// Alternatively you can allow the use of all local files with
// the DSN parameter 'allowAllFiles=true'
//
//  filePath := "/home/gopher/data.csv"
//  mysql.RegisterLocalFile(filePath)
//  err := db.Exec("LOAD DATA LOCAL INFILE '" + filePath + "' INTO TABLE foo")
//  if err != nil {
//  ...
//
func RegisterLocalFile(filePath string) <span class="cov8" title="1">{
        fileRegisterLock.Lock()
        // lazy map init
        if fileRegister == nil </span><span class="cov8" title="1">{
                fileRegister = make(map[string]bool)
        }</span>

        <span class="cov8" title="1">fileRegister[strings.Trim(filePath, `"`)] = true
        fileRegisterLock.Unlock()</span>
}

// DeregisterLocalFile removes the given filepath from the whitelist.
func DeregisterLocalFile(filePath string) <span class="cov8" title="1">{
        fileRegisterLock.Lock()
        delete(fileRegister, strings.Trim(filePath, `"`))
        fileRegisterLock.Unlock()
}</span>

// RegisterReaderHandler registers a handler function which is used
// to receive a io.Reader.
// The Reader can be used by "LOAD DATA LOCAL INFILE Reader::&lt;name&gt;".
// If the handler returns a io.ReadCloser Close() is called when the
// request is finished.
//
//  mysql.RegisterReaderHandler("data", func() io.Reader {
//          var csvReader io.Reader // Some Reader that returns CSV data
//          ... // Open Reader here
//          return csvReader
//  })
//  err := db.Exec("LOAD DATA LOCAL INFILE 'Reader::data' INTO TABLE foo")
//  if err != nil {
//  ...
//
func RegisterReaderHandler(name string, handler func() io.Reader) <span class="cov8" title="1">{
        readerRegisterLock.Lock()
        // lazy map init
        if readerRegister == nil </span><span class="cov8" title="1">{
                readerRegister = make(map[string]func() io.Reader)
        }</span>

        <span class="cov8" title="1">readerRegister[name] = handler
        readerRegisterLock.Unlock()</span>
}

// DeregisterReaderHandler removes the ReaderHandler function with
// the given name from the registry.
func DeregisterReaderHandler(name string) <span class="cov8" title="1">{
        readerRegisterLock.Lock()
        delete(readerRegister, name)
        readerRegisterLock.Unlock()
}</span>

func deferredClose(err *error, closer io.Closer) <span class="cov8" title="1">{
        closeErr := closer.Close()
        if *err == nil </span><span class="cov8" title="1">{
                *err = closeErr
        }</span>
}

func (mc *mysqlConn) handleInFileRequest(name string) (err error) <span class="cov8" title="1">{
        var rdr io.Reader
        var data []byte
        packetSize := 16 * 1024 // 16KB is small enough for disk readahead and large enough for TCP
        if mc.maxWriteSize &lt; packetSize </span><span class="cov0" title="0">{
                packetSize = mc.maxWriteSize
        }</span>

        <span class="cov8" title="1">if idx := strings.Index(name, "Reader::"); idx == 0 || (idx &gt; 0 &amp;&amp; name[idx-1] == '/') </span><span class="cov8" title="1">{ // io.Reader
                // The server might return an an absolute path. See issue #355.
                name = name[idx+8:]

                readerRegisterLock.RLock()
                handler, inMap := readerRegister[name]
                readerRegisterLock.RUnlock()

                if inMap </span><span class="cov8" title="1">{
                        rdr = handler()
                        if rdr != nil </span><span class="cov8" title="1">{
                                if cl, ok := rdr.(io.Closer); ok </span><span class="cov8" title="1">{
                                        defer deferredClose(&amp;err, cl)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                err = fmt.Errorf("Reader '%s' is &lt;nil&gt;", name)
                        }</span>
                } else<span class="cov8" title="1"> {
                        err = fmt.Errorf("Reader '%s' is not registered", name)
                }</span>
        } else<span class="cov8" title="1"> { // File
                name = strings.Trim(name, `"`)
                log.Printf("name = %v", name)
                fileRegisterLock.RLock()
                fr := fileRegister[name]
                fileRegisterLock.RUnlock()
                if mc.cfg.AllowAllFiles || fr </span><span class="cov8" title="1">{
                        var file *os.File
                        var fi os.FileInfo

                        if file, err = os.Open(name); err == nil </span><span class="cov8" title="1">{
                                defer deferredClose(&amp;err, file)

                                // get file size
                                if fi, err = file.Stat(); err == nil </span><span class="cov8" title="1">{
                                        rdr = file
                                        if fileSize := int(fi.Size()); fileSize &lt; packetSize </span><span class="cov8" title="1">{
                                                packetSize = fileSize
                                        }</span>
                                }
                        }
                } else<span class="cov8" title="1"> {
                        err = fmt.Errorf("local file '%s' is not registered", name)
                }</span>
        }

        // send content packets
        // if packetSize == 0, the Reader contains no data
        <span class="cov8" title="1">if err == nil &amp;&amp; packetSize &gt; 0 </span><span class="cov8" title="1">{
                data := make([]byte, 4+packetSize)
                var n int
                for err == nil </span><span class="cov8" title="1">{
                        n, err = rdr.Read(data[4:])
                        if n &gt; 0 </span><span class="cov8" title="1">{
                                if ioErr := mc.writePacket(data[:4+n]); ioErr != nil </span><span class="cov0" title="0">{
                                        return ioErr
                                }</span>
                        }
                }
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        err = nil
                }</span>
        }

        // send empty packet (termination)
        <span class="cov8" title="1">if data == nil </span><span class="cov8" title="1">{
                data = make([]byte, 4)
        }</span>
        <span class="cov8" title="1">if ioErr := mc.writePacket(data[:4]); ioErr != nil </span><span class="cov0" title="0">{
                return ioErr
        }</span>

        // read OK packet
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return mc.readResultOK()
        }</span>

        <span class="cov8" title="1">_, _ = mc.readPacket()

        return err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2013 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "database/sql/driver"
        "fmt"
        "time"
)

// Scan implements the Scanner interface.
// The value type must be time.Time or string / []byte (formatted time-string),
// otherwise Scan fails.
func (nt *NullTime) Scan(value interface{}) (err error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                nt.Time, nt.Valid = time.Time{}, false
                return
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case time.Time:<span class="cov8" title="1">
                nt.Time, nt.Valid = v, true
                return</span>
        case []byte:<span class="cov8" title="1">
                nt.Time, err = parseDateTime(string(v), time.UTC)
                nt.Valid = (err == nil)
                return</span>
        case string:<span class="cov8" title="1">
                nt.Time, err = parseDateTime(v, time.UTC)
                nt.Valid = (err == nil)
                return</span>
        }

        <span class="cov8" title="1">nt.Valid = false
        return fmt.Errorf("Can't convert %T to time.Time", value)</span>
}

// Value implements the driver Valuer interface.
func (nt NullTime) Value() (driver.Value, error) <span class="cov8" title="1">{
        if !nt.Valid </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return nt.Time, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2012 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "bytes"
        "crypto/tls"
        "database/sql/driver"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "time"
)

// Packets documentation:
// http://dev.mysql.com/doc/internals/en/client-server-protocol.html

// Read packet to buffer 'data'
func (mc *mysqlConn) readPacket() ([]byte, error) <span class="cov8" title="1">{
        var prevData []byte
        for </span><span class="cov8" title="1">{
                // read packet header
                data, err := mc.buf.readNext(4)
                if err != nil </span><span class="cov8" title="1">{
                        if cerr := mc.canceled.Value(); cerr != nil </span><span class="cov8" title="1">{
                                return nil, cerr
                        }</span>
                        <span class="cov8" title="1">errLog.Print(err)
                        mc.Close()
                        return nil, ErrInvalidConn</span>
                }

                // packet length [24 bit]
                <span class="cov8" title="1">pktLen := int(uint32(data[0]) | uint32(data[1])&lt;&lt;8 | uint32(data[2])&lt;&lt;16)

                // check packet sync [8 bit]
                if data[3] != mc.sequence </span><span class="cov8" title="1">{
                        if data[3] &gt; mc.sequence </span><span class="cov8" title="1">{
                                return nil, ErrPktSyncMul
                        }</span>
                        <span class="cov8" title="1">return nil, ErrPktSync</span>
                }
                <span class="cov8" title="1">mc.sequence++

                // packets with length 0 terminate a previous packet which is a
                // multiple of (2^24)-1 bytes long
                if pktLen == 0 </span><span class="cov8" title="1">{
                        // there was no previous packet
                        if prevData == nil </span><span class="cov8" title="1">{
                                errLog.Print(ErrMalformPkt)
                                mc.Close()
                                return nil, ErrInvalidConn
                        }</span>

                        <span class="cov8" title="1">return prevData, nil</span>
                }

                // read packet body [pktLen bytes]
                <span class="cov8" title="1">data, err = mc.buf.readNext(pktLen)
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := mc.canceled.Value(); cerr != nil </span><span class="cov0" title="0">{
                                return nil, cerr
                        }</span>
                        <span class="cov0" title="0">errLog.Print(err)
                        mc.Close()
                        return nil, ErrInvalidConn</span>
                }

                // return data if this was the last packet
                <span class="cov8" title="1">if pktLen &lt; maxPacketSize </span><span class="cov8" title="1">{
                        // zero allocations for non-split packets
                        if prevData == nil </span><span class="cov8" title="1">{
                                return data, nil
                        }</span>

                        <span class="cov8" title="1">return append(prevData, data...), nil</span>
                }

                <span class="cov8" title="1">prevData = append(prevData, data...)</span>
        }
}

// Write packet buffer 'data'
func (mc *mysqlConn) writePacket(data []byte) error <span class="cov8" title="1">{
        pktLen := len(data) - 4

        if pktLen &gt; mc.maxAllowedPacket </span><span class="cov8" title="1">{
                return ErrPktTooLarge
        }</span>

        // Perform a stale connection check. We only perform this check for
        // the first query on a connection that has been checked out of the
        // connection pool: a fresh connection from the pool is more likely
        // to be stale, and it has not performed any previous writes that
        // could cause data corruption, so it's safe to return ErrBadConn
        // if the check fails.
        <span class="cov8" title="1">if mc.reset </span><span class="cov8" title="1">{
                mc.reset = false
                conn := mc.netConn
                if mc.rawConn != nil </span><span class="cov8" title="1">{
                        conn = mc.rawConn
                }</span>
                <span class="cov8" title="1">var err error
                // If this connection has a ReadTimeout which we've been setting on
                // reads, reset it to its default value before we attempt a non-blocking
                // read, otherwise the scheduler will just time us out before we can read
                if mc.cfg.ReadTimeout != 0 </span><span class="cov0" title="0">{
                        err = conn.SetReadDeadline(time.Time{})
                }</span>
                <span class="cov8" title="1">if err == nil &amp;&amp; mc.cfg.CheckConnLiveness </span><span class="cov8" title="1">{
                        err = connCheck(conn)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        errLog.Print("closing bad idle connection: ", err)
                        mc.Close()
                        return driver.ErrBadConn
                }</span>
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var size int
                if pktLen &gt;= maxPacketSize </span><span class="cov8" title="1">{
                        data[0] = 0xff
                        data[1] = 0xff
                        data[2] = 0xff
                        size = maxPacketSize
                }</span> else<span class="cov8" title="1"> {
                        data[0] = byte(pktLen)
                        data[1] = byte(pktLen &gt;&gt; 8)
                        data[2] = byte(pktLen &gt;&gt; 16)
                        size = pktLen
                }</span>
                <span class="cov8" title="1">data[3] = mc.sequence

                // Write packet
                if mc.writeTimeout &gt; 0 </span><span class="cov0" title="0">{
                        if err := mc.netConn.SetWriteDeadline(time.Now().Add(mc.writeTimeout)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">n, err := mc.netConn.Write(data[:4+size])
                if err == nil &amp;&amp; n == 4+size </span><span class="cov8" title="1">{
                        mc.sequence++
                        if size != maxPacketSize </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">pktLen -= size
                        data = data[size:]
                        continue</span>
                }

                // Handle error
                <span class="cov8" title="1">if err == nil </span><span class="cov0" title="0">{ // n != len(data)
                        mc.cleanup()
                        errLog.Print(ErrMalformPkt)
                }</span> else<span class="cov8" title="1"> {
                        if cerr := mc.canceled.Value(); cerr != nil </span><span class="cov0" title="0">{
                                return cerr
                        }</span>
                        <span class="cov8" title="1">if n == 0 &amp;&amp; pktLen == len(data)-4 </span><span class="cov8" title="1">{
                                // only for the first loop iteration when nothing was written yet
                                return errBadConnNoWrite
                        }</span>
                        <span class="cov8" title="1">mc.cleanup()
                        errLog.Print(err)</span>
                }
                <span class="cov8" title="1">return ErrInvalidConn</span>
        }
}

/******************************************************************************
*                           Initialization Process                            *
******************************************************************************/

// Handshake Initialization Packet
// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake
func (mc *mysqlConn) readHandshakePacket() (data []byte, plugin string, err error) <span class="cov8" title="1">{
        data, err = mc.readPacket()
        if err != nil </span><span class="cov8" title="1">{
                // for init we can rewrite this to ErrBadConn for sql.Driver to retry, since
                // in connection initialization we don't risk retrying non-idempotent actions.
                if err == ErrInvalidConn </span><span class="cov0" title="0">{
                        return nil, "", driver.ErrBadConn
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if data[0] == iERR </span><span class="cov0" title="0">{
                return nil, "", mc.handleErrorPacket(data)
        }</span>

        // protocol version [1 byte]
        <span class="cov8" title="1">if data[0] &lt; minProtocolVersion </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf(
                        "unsupported protocol version %d. Version %d or higher is required",
                        data[0],
                        minProtocolVersion,
                )
        }</span>

        // server version [null terminated string]
        // connection id [4 bytes]
        <span class="cov8" title="1">pos := 1 + bytes.IndexByte(data[1:], 0x00) + 1 + 4

        // first part of the password cipher [8 bytes]
        authData := data[pos : pos+8]

        // (filler) always 0x00 [1 byte]
        pos += 8 + 1

        // capability flags (lower 2 bytes) [2 bytes]
        mc.flags = clientFlag(binary.LittleEndian.Uint16(data[pos : pos+2]))
        if mc.flags&amp;clientProtocol41 == 0 </span><span class="cov0" title="0">{
                return nil, "", ErrOldProtocol
        }</span>
        <span class="cov8" title="1">if mc.flags&amp;clientSSL == 0 &amp;&amp; mc.cfg.tls != nil </span><span class="cov0" title="0">{
                if mc.cfg.TLSConfig == "preferred" </span><span class="cov0" title="0">{
                        mc.cfg.tls = nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, "", ErrNoTLS
                }</span>
        }
        <span class="cov8" title="1">pos += 2

        if len(data) &gt; pos </span><span class="cov8" title="1">{
                // character set [1 byte]
                // status flags [2 bytes]
                // capability flags (upper 2 bytes) [2 bytes]
                // length of auth-plugin-data [1 byte]
                // reserved (all [00]) [10 bytes]
                pos += 1 + 2 + 2 + 1 + 10

                // second part of the password cipher [mininum 13 bytes],
                // where len=MAX(13, length of auth-plugin-data - 8)
                //
                // The web documentation is ambiguous about the length. However,
                // according to mysql-5.7/sql/auth/sql_authentication.cc line 538,
                // the 13th byte is "\0 byte, terminating the second part of
                // a scramble". So the second part of the password cipher is
                // a NULL terminated string that's at least 13 bytes with the
                // last byte being NULL.
                //
                // The official Python library uses the fixed length 12
                // which seems to work but technically could have a hidden bug.
                authData = append(authData, data[pos:pos+12]...)
                pos += 13

                // EOF if version (&gt;= 5.5.7 and &lt; 5.5.10) or (&gt;= 5.6.0 and &lt; 5.6.2)
                // \NUL otherwise
                if end := bytes.IndexByte(data[pos:], 0x00); end != -1 </span><span class="cov8" title="1">{
                        plugin = string(data[pos : pos+end])
                }</span> else<span class="cov8" title="1"> {
                        plugin = string(data[pos:])
                }</span>

                // make a memory safe copy of the cipher slice
                <span class="cov8" title="1">var b [20]byte
                copy(b[:], authData)
                return b[:], plugin, nil</span>
        }

        // make a memory safe copy of the cipher slice
        <span class="cov0" title="0">var b [8]byte
        copy(b[:], authData)
        return b[:], plugin, nil</span>
}

// Client Authentication Packet
// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse
func (mc *mysqlConn) writeHandshakeResponsePacket(authResp []byte, plugin string) error <span class="cov8" title="1">{
        // Adjust client flags based on server support
        clientFlags := clientProtocol41 |
                clientSecureConn |
                clientLongPassword |
                clientTransactions |
                clientLocalFiles |
                clientPluginAuth |
                clientMultiResults |
                mc.flags&amp;clientLongFlag

        if mc.cfg.ClientFoundRows </span><span class="cov8" title="1">{
                clientFlags |= clientFoundRows
        }</span>

        // To enable TLS / SSL
        <span class="cov8" title="1">if mc.cfg.tls != nil </span><span class="cov8" title="1">{
                clientFlags |= clientSSL
        }</span>

        <span class="cov8" title="1">if mc.cfg.MultiStatements </span><span class="cov8" title="1">{
                clientFlags |= clientMultiStatements
        }</span>

        // encode length of the auth plugin data
        <span class="cov8" title="1">var authRespLEIBuf [9]byte
        authRespLen := len(authResp)
        authRespLEI := appendLengthEncodedInteger(authRespLEIBuf[:0], uint64(authRespLen))
        if len(authRespLEI) &gt; 1 </span><span class="cov8" title="1">{
                // if the length can not be written in 1 byte, it must be written as a
                // length encoded integer
                clientFlags |= clientPluginAuthLenEncClientData
        }</span>

        <span class="cov8" title="1">pktLen := 4 + 4 + 1 + 23 + len(mc.cfg.User) + 1 + len(authRespLEI) + len(authResp) + 21 + 1

        // To specify a db name
        if n := len(mc.cfg.DBName); n &gt; 0 </span><span class="cov8" title="1">{
                clientFlags |= clientConnectWithDB
                pktLen += n + 1
        }</span>

        // Calculate packet length and get buffer with that size
        <span class="cov8" title="1">data, err := mc.buf.takeSmallBuffer(pktLen + 4)
        if err != nil </span><span class="cov0" title="0">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // ClientFlags [32 bit]
        <span class="cov8" title="1">data[4] = byte(clientFlags)
        data[5] = byte(clientFlags &gt;&gt; 8)
        data[6] = byte(clientFlags &gt;&gt; 16)
        data[7] = byte(clientFlags &gt;&gt; 24)

        // MaxPacketSize [32 bit] (none)
        data[8] = 0x00
        data[9] = 0x00
        data[10] = 0x00
        data[11] = 0x00

        // Charset [1 byte]
        var found bool
        data[12], found = collations[mc.cfg.Collation]
        if !found </span><span class="cov0" title="0">{
                // Note possibility for false negatives:
                // could be triggered  although the collation is valid if the
                // collations map does not contain entries the server supports.
                return errors.New("unknown collation")
        }</span>

        // Filler [23 bytes] (all 0x00)
        <span class="cov8" title="1">pos := 13
        for ; pos &lt; 13+23; pos++ </span><span class="cov8" title="1">{
                data[pos] = 0
        }</span>

        // SSL Connection Request Packet
        // http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::SSLRequest
        <span class="cov8" title="1">if mc.cfg.tls != nil </span><span class="cov8" title="1">{
                // Send TLS / SSL request packet
                if err := mc.writePacket(data[:(4+4+1+23)+4]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Switch to TLS
                <span class="cov8" title="1">tlsConn := tls.Client(mc.netConn, mc.cfg.tls)
                if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">mc.rawConn = mc.netConn
                mc.netConn = tlsConn
                mc.buf.nc = tlsConn</span>
        }

        // User [null terminated string]
        <span class="cov8" title="1">if len(mc.cfg.User) &gt; 0 </span><span class="cov8" title="1">{
                pos += copy(data[pos:], mc.cfg.User)
        }</span>
        <span class="cov8" title="1">data[pos] = 0x00
        pos++

        // Auth Data [length encoded integer]
        pos += copy(data[pos:], authRespLEI)
        pos += copy(data[pos:], authResp)

        // Databasename [null terminated string]
        if len(mc.cfg.DBName) &gt; 0 </span><span class="cov8" title="1">{
                pos += copy(data[pos:], mc.cfg.DBName)
                data[pos] = 0x00
                pos++
        }</span>

        <span class="cov8" title="1">pos += copy(data[pos:], plugin)
        data[pos] = 0x00
        pos++

        // Send Auth packet
        return mc.writePacket(data[:pos])</span>
}

// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchResponse
func (mc *mysqlConn) writeAuthSwitchPacket(authData []byte) error <span class="cov8" title="1">{
        pktLen := 4 + len(authData)
        data, err := mc.buf.takeSmallBuffer(pktLen)
        if err != nil </span><span class="cov0" title="0">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // Add the auth data [EOF]
        <span class="cov8" title="1">copy(data[4:], authData)
        return mc.writePacket(data)</span>
}

/******************************************************************************
*                             Command Packets                                 *
******************************************************************************/

func (mc *mysqlConn) writeCommandPacket(command byte) error <span class="cov8" title="1">{
        // Reset Packet Sequence
        mc.sequence = 0

        data, err := mc.buf.takeSmallBuffer(4 + 1)
        if err != nil </span><span class="cov8" title="1">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // Add command byte
        <span class="cov8" title="1">data[4] = command

        // Send CMD packet
        return mc.writePacket(data)</span>
}

func (mc *mysqlConn) writeCommandPacketStr(command byte, arg string) error <span class="cov8" title="1">{
        // Reset Packet Sequence
        mc.sequence = 0

        pktLen := 1 + len(arg)
        data, err := mc.buf.takeBuffer(pktLen + 4)
        if err != nil </span><span class="cov8" title="1">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // Add command byte
        <span class="cov8" title="1">data[4] = command

        // Add arg
        copy(data[5:], arg)

        // Send CMD packet
        return mc.writePacket(data)</span>
}

func (mc *mysqlConn) writeCommandPacketUint32(command byte, arg uint32) error <span class="cov8" title="1">{
        // Reset Packet Sequence
        mc.sequence = 0

        data, err := mc.buf.takeSmallBuffer(4 + 1 + 4)
        if err != nil </span><span class="cov8" title="1">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // Add command byte
        <span class="cov8" title="1">data[4] = command

        // Add arg [32 bit]
        data[5] = byte(arg)
        data[6] = byte(arg &gt;&gt; 8)
        data[7] = byte(arg &gt;&gt; 16)
        data[8] = byte(arg &gt;&gt; 24)

        // Send CMD packet
        return mc.writePacket(data)</span>
}

/******************************************************************************
*                              Result Packets                                 *
******************************************************************************/

func (mc *mysqlConn) readAuthResult() ([]byte, string, error) <span class="cov8" title="1">{
        data, err := mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        // packet indicator
        <span class="cov8" title="1">switch data[0] </span>{

        case iOK:<span class="cov8" title="1">
                return nil, "", mc.handleOkPacket(data)</span>

        case iAuthMoreData:<span class="cov8" title="1">
                return data[1:], "", err</span>

        case iEOF:<span class="cov8" title="1">
                if len(data) == 1 </span><span class="cov8" title="1">{
                        // https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::OldAuthSwitchRequest
                        return nil, "mysql_old_password", nil
                }</span>
                <span class="cov8" title="1">pluginEndIndex := bytes.IndexByte(data, 0x00)
                if pluginEndIndex &lt; 0 </span><span class="cov0" title="0">{
                        return nil, "", ErrMalformPkt
                }</span>
                <span class="cov8" title="1">plugin := string(data[1:pluginEndIndex])
                authData := data[pluginEndIndex+1:]
                return authData, plugin, nil</span>

        default:<span class="cov8" title="1"> // Error otherwise
                return nil, "", mc.handleErrorPacket(data)</span>
        }
}

// Returns error if Packet is not an 'Result OK'-Packet
func (mc *mysqlConn) readResultOK() error <span class="cov8" title="1">{
        data, err := mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if data[0] == iOK </span><span class="cov8" title="1">{
                return mc.handleOkPacket(data)
        }</span>
        <span class="cov0" title="0">return mc.handleErrorPacket(data)</span>
}

// Result Set Header Packet
// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-ProtocolText::Resultset
func (mc *mysqlConn) readResultSetHeaderPacket() (int, error) <span class="cov8" title="1">{
        data, err := mc.readPacket()
        if err == nil </span><span class="cov8" title="1">{
                switch data[0] </span>{

                case iOK:<span class="cov8" title="1">
                        return 0, mc.handleOkPacket(data)</span>

                case iERR:<span class="cov8" title="1">
                        return 0, mc.handleErrorPacket(data)</span>

                case iLocalInFile:<span class="cov8" title="1">
                        return 0, mc.handleInFileRequest(string(data[1:]))</span>
                }

                // column count
                <span class="cov8" title="1">num, _, n := readLengthEncodedInteger(data)
                if n-len(data) == 0 </span><span class="cov8" title="1">{
                        return int(num), nil
                }</span>

                <span class="cov0" title="0">return 0, ErrMalformPkt</span>
        }
        <span class="cov8" title="1">return 0, err</span>
}

// Error Packet
// http://dev.mysql.com/doc/internals/en/generic-response-packets.html#packet-ERR_Packet
func (mc *mysqlConn) handleErrorPacket(data []byte) error <span class="cov8" title="1">{
        if data[0] != iERR </span><span class="cov0" title="0">{
                return ErrMalformPkt
        }</span>

        // 0xff [1 byte]

        // Error Number [16 bit uint]
        <span class="cov8" title="1">errno := binary.LittleEndian.Uint16(data[1:3])

        // 1792: ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION
        // 1290: ER_OPTION_PREVENTS_STATEMENT (returned by Aurora during failover)
        if (errno == 1792 || errno == 1290) &amp;&amp; mc.cfg.RejectReadOnly </span><span class="cov8" title="1">{
                // Oops; we are connected to a read-only connection, and won't be able
                // to issue any write statements. Since RejectReadOnly is configured,
                // we throw away this connection hoping this one would have write
                // permission. This is specifically for a possible race condition
                // during failover (e.g. on AWS Aurora). See README.md for more.
                //
                // We explicitly close the connection before returning
                // driver.ErrBadConn to ensure that `database/sql` purges this
                // connection and initiates a new one for next statement next time.
                mc.Close()
                return driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">pos := 3

        // SQL State [optional: # + 5bytes string]
        if data[3] == 0x23 </span><span class="cov8" title="1">{
                //sqlstate := string(data[4 : 4+5])
                pos = 9
        }</span>

        // Error Message [string]
        <span class="cov8" title="1">return &amp;MySQLError{
                Number:  errno,
                Message: string(data[pos:]),
        }</span>
}

func readStatus(b []byte) statusFlag <span class="cov8" title="1">{
        return statusFlag(b[0]) | statusFlag(b[1])&lt;&lt;8
}</span>

// Ok Packet
// http://dev.mysql.com/doc/internals/en/generic-response-packets.html#packet-OK_Packet
func (mc *mysqlConn) handleOkPacket(data []byte) error <span class="cov8" title="1">{
        var n, m int

        // 0x00 [1 byte]

        // Affected rows [Length Coded Binary]
        mc.affectedRows, _, n = readLengthEncodedInteger(data[1:])

        // Insert id [Length Coded Binary]
        mc.insertId, _, m = readLengthEncodedInteger(data[1+n:])

        // server_status [2 bytes]
        mc.status = readStatus(data[1+n+m : 1+n+m+2])
        if mc.status&amp;statusMoreResultsExists != 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // warning count [2 bytes]

        <span class="cov8" title="1">return nil</span>
}

// Read Packets as Field Packets until EOF-Packet or an Error appears
// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-Protocol::ColumnDefinition41
func (mc *mysqlConn) readColumns(count int) ([]mysqlField, error) <span class="cov8" title="1">{
        columns := make([]mysqlField, count)

        for i := 0; ; i++ </span><span class="cov8" title="1">{
                data, err := mc.readPacket()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // EOF Packet
                <span class="cov8" title="1">if data[0] == iEOF &amp;&amp; (len(data) == 5 || len(data) == 1) </span><span class="cov8" title="1">{
                        if i == count </span><span class="cov8" title="1">{
                                return columns, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("column count mismatch n:%d len:%d", count, len(columns))</span>
                }

                // Catalog
                <span class="cov8" title="1">pos, err := skipLengthEncodedString(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Database [len coded string]
                <span class="cov8" title="1">n, err := skipLengthEncodedString(data[pos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">pos += n

                // Table [len coded string]
                if mc.cfg.ColumnsWithAlias </span><span class="cov8" title="1">{
                        tableName, _, n, err := readLengthEncodedString(data[pos:])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pos += n
                        columns[i].tableName = string(tableName)</span>
                } else<span class="cov8" title="1"> {
                        n, err = skipLengthEncodedString(data[pos:])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pos += n</span>
                }

                // Original table [len coded string]
                <span class="cov8" title="1">n, err = skipLengthEncodedString(data[pos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">pos += n

                // Name [len coded string]
                name, _, n, err := readLengthEncodedString(data[pos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">columns[i].name = string(name)
                pos += n

                // Original name [len coded string]
                n, err = skipLengthEncodedString(data[pos:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">pos += n

                // Filler [uint8]
                pos++

                // Charset [charset, collation uint8]
                columns[i].charSet = data[pos]
                pos += 2

                // Length [uint32]
                columns[i].length = binary.LittleEndian.Uint32(data[pos : pos+4])
                pos += 4

                // Field type [uint8]
                columns[i].fieldType = fieldType(data[pos])
                pos++

                // Flags [uint16]
                columns[i].flags = fieldFlag(binary.LittleEndian.Uint16(data[pos : pos+2]))
                pos += 2

                // Decimals [uint8]
                columns[i].decimals = data[pos]</span>
                //pos++

                // Default value [len coded binary]
                //if pos &lt; len(data) {
                //        defaultVal, _, err = bytesToLengthCodedBinary(data[pos:])
                //}
        }
}

// Read Packets as Field Packets until EOF-Packet or an Error appears
// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-ProtocolText::ResultsetRow
func (rows *textRows) readRow(dest []driver.Value) error <span class="cov8" title="1">{
        mc := rows.mc

        if rows.rs.done </span><span class="cov0" title="0">{
                return io.EOF
        }</span>

        <span class="cov8" title="1">data, err := mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // EOF Packet
        <span class="cov8" title="1">if data[0] == iEOF &amp;&amp; len(data) == 5 </span><span class="cov8" title="1">{
                // server_status [2 bytes]
                rows.mc.status = readStatus(data[3:])
                rows.rs.done = true
                if !rows.HasNextResultSet() </span><span class="cov8" title="1">{
                        rows.mc = nil
                }</span>
                <span class="cov8" title="1">return io.EOF</span>
        }
        <span class="cov8" title="1">if data[0] == iERR </span><span class="cov0" title="0">{
                rows.mc = nil
                return mc.handleErrorPacket(data)
        }</span>

        // RowSet Packet
        <span class="cov8" title="1">var n int
        var isNull bool
        pos := 0

        for i := range dest </span><span class="cov8" title="1">{
                // Read bytes and convert to string
                dest[i], isNull, n, err = readLengthEncodedString(data[pos:])
                pos += n
                if err == nil </span><span class="cov8" title="1">{
                        if !isNull </span><span class="cov8" title="1">{
                                if !mc.parseTime </span><span class="cov8" title="1">{
                                        continue</span>
                                } else<span class="cov8" title="1"> {
                                        switch rows.rs.columns[i].fieldType </span>{
                                        case fieldTypeTimestamp, fieldTypeDateTime,
                                                fieldTypeDate, fieldTypeNewDate:<span class="cov8" title="1">
                                                dest[i], err = parseDateTime(
                                                        string(dest[i].([]byte)),
                                                        mc.cfg.Loc,
                                                )
                                                if err == nil </span><span class="cov8" title="1">{
                                                        continue</span>
                                                }
                                        default:<span class="cov8" title="1">
                                                continue</span>
                                        }
                                }

                        } else<span class="cov8" title="1"> {
                                dest[i] = nil
                                continue</span>
                        }
                }
                <span class="cov0" title="0">return err</span> // err != nil
        }

        <span class="cov8" title="1">return nil</span>
}

// Reads Packets until EOF-Packet or an Error appears. Returns count of Packets read
func (mc *mysqlConn) readUntilEOF() error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                data, err := mc.readPacket()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">switch data[0] </span>{
                case iERR:<span class="cov0" title="0">
                        return mc.handleErrorPacket(data)</span>
                case iEOF:<span class="cov8" title="1">
                        if len(data) == 5 </span><span class="cov8" title="1">{
                                mc.status = readStatus(data[3:])
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
        }
}

/******************************************************************************
*                           Prepared Statements                               *
******************************************************************************/

// Prepare Result Packets
// http://dev.mysql.com/doc/internals/en/com-stmt-prepare-response.html
func (stmt *mysqlStmt) readPrepareResultPacket() (uint16, error) <span class="cov8" title="1">{
        data, err := stmt.mc.readPacket()
        if err == nil </span><span class="cov8" title="1">{
                // packet indicator [1 byte]
                if data[0] != iOK </span><span class="cov8" title="1">{
                        return 0, stmt.mc.handleErrorPacket(data)
                }</span>

                // statement id [4 bytes]
                <span class="cov8" title="1">stmt.id = binary.LittleEndian.Uint32(data[1:5])

                // Column count [16 bit uint]
                columnCount := binary.LittleEndian.Uint16(data[5:7])

                // Param count [16 bit uint]
                stmt.paramCount = int(binary.LittleEndian.Uint16(data[7:9]))

                // Reserved [8 bit]

                // Warning count [16 bit uint]

                return columnCount, nil</span>
        }
        <span class="cov0" title="0">return 0, err</span>
}

// http://dev.mysql.com/doc/internals/en/com-stmt-send-long-data.html
func (stmt *mysqlStmt) writeCommandLongData(paramID int, arg []byte) error <span class="cov8" title="1">{
        maxLen := stmt.mc.maxAllowedPacket - 1
        pktLen := maxLen

        // After the header (bytes 0-3) follows before the data:
        // 1 byte command
        // 4 bytes stmtID
        // 2 bytes paramID
        const dataOffset = 1 + 4 + 2

        // Cannot use the write buffer since
        // a) the buffer is too small
        // b) it is in use
        data := make([]byte, 4+1+4+2+len(arg))

        copy(data[4+dataOffset:], arg)

        for argLen := len(arg); argLen &gt; 0; argLen -= pktLen - dataOffset </span><span class="cov8" title="1">{
                if dataOffset+argLen &lt; maxLen </span><span class="cov8" title="1">{
                        pktLen = dataOffset + argLen
                }</span>

                <span class="cov8" title="1">stmt.mc.sequence = 0
                // Add command byte [1 byte]
                data[4] = comStmtSendLongData

                // Add stmtID [32 bit]
                data[5] = byte(stmt.id)
                data[6] = byte(stmt.id &gt;&gt; 8)
                data[7] = byte(stmt.id &gt;&gt; 16)
                data[8] = byte(stmt.id &gt;&gt; 24)

                // Add paramID [16 bit]
                data[9] = byte(paramID)
                data[10] = byte(paramID &gt;&gt; 8)

                // Send CMD packet
                err := stmt.mc.writePacket(data[:4+pktLen])
                if err == nil </span><span class="cov8" title="1">{
                        data = data[pktLen-dataOffset:]
                        continue</span>
                }
                <span class="cov0" title="0">return err</span>

        }

        // Reset Packet Sequence
        <span class="cov8" title="1">stmt.mc.sequence = 0
        return nil</span>
}

// Execute Prepared Statement
// http://dev.mysql.com/doc/internals/en/com-stmt-execute.html
func (stmt *mysqlStmt) writeExecutePacket(args []driver.Value) error <span class="cov8" title="1">{
        if len(args) != stmt.paramCount </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "argument count mismatch (got: %d; has: %d)",
                        len(args),
                        stmt.paramCount,
                )
        }</span>

        <span class="cov8" title="1">const minPktLen = 4 + 1 + 4 + 1 + 4
        mc := stmt.mc

        // Determine threshold dynamically to avoid packet size shortage.
        longDataSize := mc.maxAllowedPacket / (stmt.paramCount + 1)
        if longDataSize &lt; 64 </span><span class="cov0" title="0">{
                longDataSize = 64
        }</span>

        // Reset packet-sequence
        <span class="cov8" title="1">mc.sequence = 0

        var data []byte
        var err error

        if len(args) == 0 </span><span class="cov8" title="1">{
                data, err = mc.buf.takeBuffer(minPktLen)
        }</span> else<span class="cov8" title="1"> {
                data, err = mc.buf.takeCompleteBuffer()
                // In this case the len(data) == cap(data) which is used to optimise the flow below.
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                // cannot take the buffer. Something must be wrong with the connection
                errLog.Print(err)
                return errBadConnNoWrite
        }</span>

        // command [1 byte]
        <span class="cov8" title="1">data[4] = comStmtExecute

        // statement_id [4 bytes]
        data[5] = byte(stmt.id)
        data[6] = byte(stmt.id &gt;&gt; 8)
        data[7] = byte(stmt.id &gt;&gt; 16)
        data[8] = byte(stmt.id &gt;&gt; 24)

        // flags (0: CURSOR_TYPE_NO_CURSOR) [1 byte]
        data[9] = 0x00

        // iteration_count (uint32(1)) [4 bytes]
        data[10] = 0x01
        data[11] = 0x00
        data[12] = 0x00
        data[13] = 0x00

        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                pos := minPktLen

                var nullMask []byte
                if maskLen, typesLen := (len(args)+7)/8, 1+2*len(args); pos+maskLen+typesLen &gt;= cap(data) </span><span class="cov8" title="1">{
                        // buffer has to be extended but we don't know by how much so
                        // we depend on append after all data with known sizes fit.
                        // We stop at that because we deal with a lot of columns here
                        // which makes the required allocation size hard to guess.
                        tmp := make([]byte, pos+maskLen+typesLen)
                        copy(tmp[:pos], data[:pos])
                        data = tmp
                        nullMask = data[pos : pos+maskLen]
                        // No need to clean nullMask as make ensures that.
                        pos += maskLen
                }</span> else<span class="cov8" title="1"> {
                        nullMask = data[pos : pos+maskLen]
                        for i := range nullMask </span><span class="cov8" title="1">{
                                nullMask[i] = 0
                        }</span>
                        <span class="cov8" title="1">pos += maskLen</span>
                }

                // newParameterBoundFlag 1 [1 byte]
                <span class="cov8" title="1">data[pos] = 0x01
                pos++

                // type of each parameter [len(args)*2 bytes]
                paramTypes := data[pos:]
                pos += len(args) * 2

                // value of each parameter [n bytes]
                paramValues := data[pos:pos]
                valuesCap := cap(paramValues)

                for i, arg := range args </span><span class="cov8" title="1">{
                        // build NULL-bitmap
                        if arg == nil </span><span class="cov8" title="1">{
                                nullMask[i/8] |= 1 &lt;&lt; (uint(i) &amp; 7)
                                paramTypes[i+i] = byte(fieldTypeNULL)
                                paramTypes[i+i+1] = 0x00
                                continue</span>
                        }

                        <span class="cov8" title="1">if v, ok := arg.(json.RawMessage); ok </span><span class="cov8" title="1">{
                                arg = []byte(v)
                        }</span>
                        // cache types and values
                        <span class="cov8" title="1">switch v := arg.(type) </span>{
                        case int64:<span class="cov8" title="1">
                                paramTypes[i+i] = byte(fieldTypeLongLong)
                                paramTypes[i+i+1] = 0x00

                                if cap(paramValues)-len(paramValues)-8 &gt;= 0 </span><span class="cov8" title="1">{
                                        paramValues = paramValues[:len(paramValues)+8]
                                        binary.LittleEndian.PutUint64(
                                                paramValues[len(paramValues)-8:],
                                                uint64(v),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        paramValues = append(paramValues,
                                                uint64ToBytes(uint64(v))...,
                                        )
                                }</span>

                        case uint64:<span class="cov8" title="1">
                                paramTypes[i+i] = byte(fieldTypeLongLong)
                                paramTypes[i+i+1] = 0x80 // type is unsigned

                                if cap(paramValues)-len(paramValues)-8 &gt;= 0 </span><span class="cov8" title="1">{
                                        paramValues = paramValues[:len(paramValues)+8]
                                        binary.LittleEndian.PutUint64(
                                                paramValues[len(paramValues)-8:],
                                                uint64(v),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        paramValues = append(paramValues,
                                                uint64ToBytes(uint64(v))...,
                                        )
                                }</span>

                        case float64:<span class="cov8" title="1">
                                paramTypes[i+i] = byte(fieldTypeDouble)
                                paramTypes[i+i+1] = 0x00

                                if cap(paramValues)-len(paramValues)-8 &gt;= 0 </span><span class="cov8" title="1">{
                                        paramValues = paramValues[:len(paramValues)+8]
                                        binary.LittleEndian.PutUint64(
                                                paramValues[len(paramValues)-8:],
                                                math.Float64bits(v),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        paramValues = append(paramValues,
                                                uint64ToBytes(math.Float64bits(v))...,
                                        )
                                }</span>

                        case bool:<span class="cov8" title="1">
                                paramTypes[i+i] = byte(fieldTypeTiny)
                                paramTypes[i+i+1] = 0x00

                                if v </span><span class="cov8" title="1">{
                                        paramValues = append(paramValues, 0x01)
                                }</span> else<span class="cov8" title="1"> {
                                        paramValues = append(paramValues, 0x00)
                                }</span>

                        case []byte:<span class="cov8" title="1">
                                // Common case (non-nil value) first
                                if v != nil </span><span class="cov8" title="1">{
                                        paramTypes[i+i] = byte(fieldTypeString)
                                        paramTypes[i+i+1] = 0x00

                                        if len(v) &lt; longDataSize </span><span class="cov8" title="1">{
                                                paramValues = appendLengthEncodedInteger(paramValues,
                                                        uint64(len(v)),
                                                )
                                                paramValues = append(paramValues, v...)
                                        }</span> else<span class="cov0" title="0"> {
                                                if err := stmt.writeCommandLongData(i, v); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                        <span class="cov8" title="1">continue</span>
                                }

                                // Handle []byte(nil) as a NULL value
                                <span class="cov8" title="1">nullMask[i/8] |= 1 &lt;&lt; (uint(i) &amp; 7)
                                paramTypes[i+i] = byte(fieldTypeNULL)
                                paramTypes[i+i+1] = 0x00</span>

                        case string:<span class="cov8" title="1">
                                paramTypes[i+i] = byte(fieldTypeString)
                                paramTypes[i+i+1] = 0x00

                                if len(v) &lt; longDataSize </span><span class="cov8" title="1">{
                                        paramValues = appendLengthEncodedInteger(paramValues,
                                                uint64(len(v)),
                                        )
                                        paramValues = append(paramValues, v...)
                                }</span> else<span class="cov8" title="1"> {
                                        if err := stmt.writeCommandLongData(i, []byte(v)); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }

                        case time.Time:<span class="cov8" title="1">
                                paramTypes[i+i] = byte(fieldTypeString)
                                paramTypes[i+i+1] = 0x00

                                var a [64]byte
                                var b = a[:0]

                                if v.IsZero() </span><span class="cov8" title="1">{
                                        b = append(b, "0000-00-00"...)
                                }</span> else<span class="cov8" title="1"> {
                                        b = v.In(mc.cfg.Loc).AppendFormat(b, timeFormat)
                                }</span>

                                <span class="cov8" title="1">paramValues = appendLengthEncodedInteger(paramValues,
                                        uint64(len(b)),
                                )
                                paramValues = append(paramValues, b...)</span>

                        default:<span class="cov0" title="0">
                                return fmt.Errorf("cannot convert type: %T", arg)</span>
                        }
                }

                // Check if param values exceeded the available buffer
                // In that case we must build the data packet with the new values buffer
                <span class="cov8" title="1">if valuesCap != cap(paramValues) </span><span class="cov8" title="1">{
                        data = append(data[:pos], paramValues...)
                        if err = mc.buf.store(data); err != nil </span><span class="cov0" title="0">{
                                errLog.Print(err)
                                return errBadConnNoWrite
                        }</span>
                }

                <span class="cov8" title="1">pos += len(paramValues)
                data = data[:pos]</span>
        }

        <span class="cov8" title="1">return mc.writePacket(data)</span>
}

func (mc *mysqlConn) discardResults() error <span class="cov8" title="1">{
        for mc.status&amp;statusMoreResultsExists != 0 </span><span class="cov8" title="1">{
                resLen, err := mc.readResultSetHeaderPacket()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if resLen &gt; 0 </span><span class="cov0" title="0">{
                        // columns
                        if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // rows
                        <span class="cov0" title="0">if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// http://dev.mysql.com/doc/internals/en/binary-protocol-resultset-row.html
func (rows *binaryRows) readRow(dest []driver.Value) error <span class="cov8" title="1">{
        data, err := rows.mc.readPacket()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // packet indicator [1 byte]
        <span class="cov8" title="1">if data[0] != iOK </span><span class="cov8" title="1">{
                // EOF Packet
                if data[0] == iEOF &amp;&amp; len(data) == 5 </span><span class="cov8" title="1">{
                        rows.mc.status = readStatus(data[3:])
                        rows.rs.done = true
                        if !rows.HasNextResultSet() </span><span class="cov8" title="1">{
                                rows.mc = nil
                        }</span>
                        <span class="cov8" title="1">return io.EOF</span>
                }
                <span class="cov0" title="0">mc := rows.mc
                rows.mc = nil

                // Error otherwise
                return mc.handleErrorPacket(data)</span>
        }

        // NULL-bitmap,  [(column-count + 7 + 2) / 8 bytes]
        <span class="cov8" title="1">pos := 1 + (len(dest)+7+2)&gt;&gt;3
        nullMask := data[1:pos]

        for i := range dest </span><span class="cov8" title="1">{
                // Field is NULL
                // (byte &gt;&gt; bit-pos) % 2 == 1
                if ((nullMask[(i+2)&gt;&gt;3] &gt;&gt; uint((i+2)&amp;7)) &amp; 1) == 1 </span><span class="cov8" title="1">{
                        dest[i] = nil
                        continue</span>
                }

                // Convert to byte-coded string
                <span class="cov8" title="1">switch rows.rs.columns[i].fieldType </span>{
                case fieldTypeNULL:<span class="cov0" title="0">
                        dest[i] = nil
                        continue</span>

                // Numeric Types
                case fieldTypeTiny:<span class="cov0" title="0">
                        if rows.rs.columns[i].flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                dest[i] = int64(data[pos])
                        }</span> else<span class="cov0" title="0"> {
                                dest[i] = int64(int8(data[pos]))
                        }</span>
                        <span class="cov0" title="0">pos++
                        continue</span>

                case fieldTypeShort, fieldTypeYear:<span class="cov0" title="0">
                        if rows.rs.columns[i].flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                dest[i] = int64(binary.LittleEndian.Uint16(data[pos : pos+2]))
                        }</span> else<span class="cov0" title="0"> {
                                dest[i] = int64(int16(binary.LittleEndian.Uint16(data[pos : pos+2])))
                        }</span>
                        <span class="cov0" title="0">pos += 2
                        continue</span>

                case fieldTypeInt24, fieldTypeLong:<span class="cov8" title="1">
                        if rows.rs.columns[i].flags&amp;flagUnsigned != 0 </span><span class="cov0" title="0">{
                                dest[i] = int64(binary.LittleEndian.Uint32(data[pos : pos+4]))
                        }</span> else<span class="cov8" title="1"> {
                                dest[i] = int64(int32(binary.LittleEndian.Uint32(data[pos : pos+4])))
                        }</span>
                        <span class="cov8" title="1">pos += 4
                        continue</span>

                case fieldTypeLongLong:<span class="cov8" title="1">
                        if rows.rs.columns[i].flags&amp;flagUnsigned != 0 </span><span class="cov8" title="1">{
                                val := binary.LittleEndian.Uint64(data[pos : pos+8])
                                if val &gt; math.MaxInt64 </span><span class="cov8" title="1">{
                                        dest[i] = uint64ToString(val)
                                }</span> else<span class="cov8" title="1"> {
                                        dest[i] = int64(val)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                dest[i] = int64(binary.LittleEndian.Uint64(data[pos : pos+8]))
                        }</span>
                        <span class="cov8" title="1">pos += 8
                        continue</span>

                case fieldTypeFloat:<span class="cov8" title="1">
                        dest[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[pos : pos+4]))
                        pos += 4
                        continue</span>

                case fieldTypeDouble:<span class="cov8" title="1">
                        dest[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[pos : pos+8]))
                        pos += 8
                        continue</span>

                // Length coded Binary Strings
                case fieldTypeDecimal, fieldTypeNewDecimal, fieldTypeVarChar,
                        fieldTypeBit, fieldTypeEnum, fieldTypeSet, fieldTypeTinyBLOB,
                        fieldTypeMediumBLOB, fieldTypeLongBLOB, fieldTypeBLOB,
                        fieldTypeVarString, fieldTypeString, fieldTypeGeometry, fieldTypeJSON:<span class="cov8" title="1">
                        var isNull bool
                        var n int
                        dest[i], isNull, n, err = readLengthEncodedString(data[pos:])
                        pos += n
                        if err == nil </span><span class="cov8" title="1">{
                                if !isNull </span><span class="cov8" title="1">{
                                        continue</span>
                                } else<span class="cov0" title="0"> {
                                        dest[i] = nil
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">return err</span>

                case
                        fieldTypeDate, fieldTypeNewDate, // Date YYYY-MM-DD
                        fieldTypeTime,                         // Time [-][H]HH:MM:SS[.fractal]
                        fieldTypeTimestamp, fieldTypeDateTime:<span class="cov8" title="1"> // Timestamp YYYY-MM-DD HH:MM:SS[.fractal]

                        num, isNull, n := readLengthEncodedInteger(data[pos:])
                        pos += n

                        switch </span>{
                        case isNull:<span class="cov0" title="0">
                                dest[i] = nil
                                continue</span>
                        case rows.rs.columns[i].fieldType == fieldTypeTime:<span class="cov8" title="1">
                                // database/sql does not support an equivalent to TIME, return a string
                                var dstlen uint8
                                switch decimals := rows.rs.columns[i].decimals; decimals </span>{
                                case 0x00, 0x1f:<span class="cov8" title="1">
                                        dstlen = 8</span>
                                case 1, 2, 3, 4, 5, 6:<span class="cov0" title="0">
                                        dstlen = 8 + 1 + decimals</span>
                                default:<span class="cov0" title="0">
                                        return fmt.Errorf(
                                                "protocol error, illegal decimals value %d",
                                                rows.rs.columns[i].decimals,
                                        )</span>
                                }
                                <span class="cov8" title="1">dest[i], err = formatBinaryTime(data[pos:pos+int(num)], dstlen)</span>
                        case rows.mc.parseTime:<span class="cov8" title="1">
                                dest[i], err = parseBinaryDateTime(num, data[pos:], rows.mc.cfg.Loc)</span>
                        default:<span class="cov8" title="1">
                                var dstlen uint8
                                if rows.rs.columns[i].fieldType == fieldTypeDate </span><span class="cov8" title="1">{
                                        dstlen = 10
                                }</span> else<span class="cov8" title="1"> {
                                        switch decimals := rows.rs.columns[i].decimals; decimals </span>{
                                        case 0x00, 0x1f:<span class="cov8" title="1">
                                                dstlen = 19</span>
                                        case 1, 2, 3, 4, 5, 6:<span class="cov0" title="0">
                                                dstlen = 19 + 1 + decimals</span>
                                        default:<span class="cov0" title="0">
                                                return fmt.Errorf(
                                                        "protocol error, illegal decimals value %d",
                                                        rows.rs.columns[i].decimals,
                                                )</span>
                                        }
                                }
                                <span class="cov8" title="1">dest[i], err = formatBinaryDateTime(data[pos:pos+int(num)], dstlen)</span>
                        }

                        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                pos += int(num)
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                return err
                        }</span>

                // Please report if this happens!
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown field type %d", rows.rs.columns[i].fieldType)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2012 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

type mysqlResult struct {
        affectedRows int64
        insertId     int64
}

func (res *mysqlResult) LastInsertId() (int64, error) <span class="cov8" title="1">{
        return res.insertId, nil
}</span>

func (res *mysqlResult) RowsAffected() (int64, error) <span class="cov8" title="1">{
        return res.affectedRows, nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Go MySQL Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2012 The Go-MySQL-Driver Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "database/sql/driver"
        "io"
        "math"
        "reflect"
)

type resultSet struct {
        columns     []mysqlField
        columnNames []string
        done        bool
}

type mysqlRows struct {
        mc     *mysqlConn
        rs     resultSet
        finish func()
}

type binaryRows struct {
        mysqlRows
}

type textRows struct {
        mysqlRows
}

func (rows *mysqlRows) Columns() []string <span class="cov8" title="1">{
        if rows.rs.columnNames != nil </span><span class="cov8" title="1">{
                return rows.rs.columnNames
        }</span>

        <span class="cov8" title="1">columns := make([]string, len(rows.rs.columns))
        if rows.mc != nil &amp;&amp; rows.mc.cfg.ColumnsWithAlias </span><span class="cov8" title="1">{
                for i := range columns </span><span class="cov8" title="1">{
                        if tableName := rows.rs.columns[i].tableName; len(tableName) &gt; 0 </span><span class="cov8" title="1">{
                                columns[i] = tableName + "." + rows.rs.columns[i].name
                        }</span> else<span class="cov8" title="1"> {
                                columns[i] = rows.rs.columns[i].name
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for i := range columns </span><span class="cov8" title="1">{
                        columns[i] = rows.rs.columns[i].name
                }</span>
        }

        <span class="cov8" title="1">rows.rs.columnNames = columns
        return columns</span>
}

func (rows *mysqlRows) ColumnTypeDatabaseTypeName(i int) string <span class="cov8" title="1">{
        return rows.rs.columns[i].typeDatabaseName()
}</span>

// func (rows *mysqlRows) ColumnTypeLength(i int) (length int64, ok bool) {
//         return int64(rows.rs.columns[i].length), true
// }

func (rows *mysqlRows) ColumnTypeNullable(i int) (nullable, ok bool) <span class="cov8" title="1">{
        return rows.rs.columns[i].flags&amp;flagNotNULL == 0, true
}</span>

func (rows *mysqlRows) ColumnTypePrecisionScale(i int) (int64, int64, bool) <span class="cov8" title="1">{
        column := rows.rs.columns[i]
        decimals := int64(column.decimals)

        switch column.fieldType </span>{
        case fieldTypeDecimal, fieldTypeNewDecimal:<span class="cov8" title="1">
                if decimals &gt; 0 </span><span class="cov8" title="1">{
                        return int64(column.length) - 2, decimals, true
                }</span>
                <span class="cov8" title="1">return int64(column.length) - 1, decimals, true</span>
        case fieldTypeTimestamp, fieldTypeDateTime, fieldTypeTime:<span class="cov8" title="1">
                return decimals, decimals, true</span>
        case fieldTypeFloat, fieldTypeDouble:<span class="cov8" title="1">
                if decimals == 0x1f </span><span class="cov8" title="1">{
                        return math.MaxInt64, math.MaxInt64, true
                }</span>
                <span class="cov8" title="1">return math.MaxInt64, decimals, true</span>
        }

        <span class="cov8" title="1">return 0, 0, false</span>
}

func (rows *mysqlRows) ColumnTypeScanType(i int) reflect.Type <span class="cov8" title="1">{
        return rows.rs.columns[i].scanType()
}</span>

func (rows *mysqlRows) Close() (err error) <span class="cov8" title="1">{
        if f := rows.finish; f != nil </span><span class="cov8" title="1">{
                f()
                rows.finish = nil
        }</span>

        <span class="cov8" title="1">mc := rows.mc
        if mc == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if err := mc.error(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // flip the buffer for this connection if we need to drain it.
        // note that for a successful query (i.e. one where rows.next()
        // has been called until it returns false), `rows.mc` will be nil
        // by the time the user calls `(*Rows).Close`, so we won't reach this
        // see: https://github.com/golang/go/commit/651ddbdb5056ded455f47f9c494c67b389622a47
        <span class="cov8" title="1">mc.buf.flip()

        // Remove unread packets from stream
        if !rows.rs.done </span><span class="cov8" title="1">{
                err = mc.readUntilEOF()
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                if err = mc.discardResults(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">rows.mc = nil
        return err</span>
}

func (rows *mysqlRows) HasNextResultSet() (b bool) <span class="cov8" title="1">{
        if rows.mc == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return rows.mc.status&amp;statusMoreResultsExists != 0</span>
}

func (rows *mysqlRows) nextResultSet() (int, error) <span class="cov8" title="1">{
        if rows.mc == nil </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">if err := rows.mc.error(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Remove unread packets from stream
        <span class="cov8" title="1">if !rows.rs.done </span><span class="cov8" title="1">{
                if err := rows.mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">rows.rs.done = true</span>
        }

        <span class="cov8" title="1">if !rows.HasNextResultSet() </span><span class="cov8" title="1">{
                rows.mc = nil
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">rows.rs = resultSet{}
        return rows.mc.readResultSetHeaderPacket()</span>
}

func (rows *mysqlRows) nextNotEmptyResultSet() (int, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                resLen, err := rows.nextResultSet()
                if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>

                <span class="cov8" title="1">if resLen &gt; 0 </span><span class="cov8" title="1">{
                        return resLen, nil
                }</span>

                <span class="cov8" title="1">rows.rs.done = true</span>
        }
}

func (rows *binaryRows) NextResultSet() error <span class="cov8" title="1">{
        resLen, err := rows.nextNotEmptyResultSet()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">rows.rs.columns, err = rows.mc.readColumns(resLen)
        return err</span>
}

func (rows *binaryRows) Next(dest []driver.Value) error <span class="cov8" title="1">{
        if mc := rows.mc; mc != nil </span><span class="cov8" title="1">{
                if err := mc.error(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Fetch next row from stream
                <span class="cov8" title="1">return rows.readRow(dest)</span>
        }
        <span class="cov0" title="0">return io.EOF</span>
}

func (rows *textRows) NextResultSet() (err error) <span class="cov8" title="1">{
        resLen, err := rows.nextNotEmptyResultSet()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">rows.rs.columns, err = rows.mc.readColumns(resLen)
        return err</span>
}

func (rows *textRows) Next(dest []driver.Value) error <span class="cov8" title="1">{
        if mc := rows.mc; mc != nil </span><span class="cov8" title="1">{
                if err := mc.error(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Fetch next row from stream
                <span class="cov8" title="1">return rows.readRow(dest)</span>
        }
        <span class="cov8" title="1">return io.EOF</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "io"
        // syslog "log"
        "reflect"
        "time"
)

type mysqlStmt struct {
        sqlPrepared string
        mc          *mysqlConn
        id          uint32
        paramCount  int
}

func (stmt *mysqlStmt) Close() error <span class="cov8" title="1">{
        if stmt.mc == nil || stmt.mc.closed.IsSet() </span><span class="cov8" title="1">{
                // driver.Stmt.Close can be called more than once, thus this function
                // has to be idempotent.
                // See also Issue #450 and golang/go#16019.
                //errLog.Print(ErrInvalidConn)
                return driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">err := stmt.mc.writeCommandPacketUint32(comStmtClose, stmt.id)
        stmt.mc = nil
        return err</span>
}

func (stmt *mysqlStmt) NumInput() int <span class="cov8" title="1">{
        return stmt.paramCount
}</span>

func (stmt *mysqlStmt) ColumnConverter(idx int) driver.ValueConverter <span class="cov0" title="0">{
        return converter{}
}</span>

func (stmt *mysqlStmt) Exec(args []driver.Value) (driver.Result, error) <span class="cov8" title="1">{

        if stmt.mc.closed.IsSet() </span><span class="cov8" title="1">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">mc := stmt.mc
        ts := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if mc.connector != nil </span><span class="cov8" title="1">{
                        mc.connector.msk.AfterProcess(ts, stmt.sqlPrepared, args)
                }</span>
        }()
        // log.Printf("mysqlStmt:Exec on %v with sql %v", args, stmt.sqlPrepared)
        // Send command
        <span class="cov8" title="1">err := stmt.writeExecutePacket(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, stmt.mc.markBadConn(err)
        }</span>

        <span class="cov8" title="1">mc.affectedRows = 0
        mc.insertId = 0

        // Read Result
        resLen, err := mc.readResultSetHeaderPacket()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resLen &gt; 0 </span><span class="cov8" title="1">{
                // Columns
                if err = mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Rows
                <span class="cov8" title="1">if err := mc.readUntilEOF(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if err := mc.discardResults(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;mysqlResult{
                affectedRows: int64(mc.affectedRows),
                insertId:     int64(mc.insertId),
        }, nil</span>
}

func (stmt *mysqlStmt) Query(args []driver.Value) (driver.Rows, error) <span class="cov0" title="0">{
        return stmt.query(args)
}</span>

func (stmt *mysqlStmt) query(args []driver.Value) (*binaryRows, error) <span class="cov8" title="1">{
        if stmt.mc.closed.IsSet() </span><span class="cov0" title="0">{
                errLog.Print(ErrInvalidConn)
                return nil, driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">mc := stmt.mc
        ts := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if mc.connector != nil </span><span class="cov8" title="1">{
                        mc.connector.msk.AfterProcess(ts, stmt.sqlPrepared, args)
                }</span>
        }()
        // Send command
        <span class="cov8" title="1">err := stmt.writeExecutePacket(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, stmt.mc.markBadConn(err)
        }</span>

        // Read Result
        <span class="cov8" title="1">resLen, err := mc.readResultSetHeaderPacket()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows := new(binaryRows)

        if resLen &gt; 0 </span><span class="cov8" title="1">{
                rows.mc = mc
                rows.rs.columns, err = mc.readColumns(resLen)
        }</span> else<span class="cov0" title="0"> {
                rows.rs.done = true

                switch err := rows.NextResultSet(); err </span>{
                case nil, io.EOF:<span class="cov0" title="0">
                        return rows, nil</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }

        <span class="cov8" title="1">return rows, err</span>
}

var jsonType = reflect.TypeOf(json.RawMessage{})

type Converter struct {
        converter
}

type converter struct{}

func (c converter) ConvertValues(args []interface{}) ([]driver.Value, error) <span class="cov8" title="1">{

        nargs := []driver.Value{}
        var err error
        var narg driver.Value
        for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                narg, err = c.ConvertValue(args[i])
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">nargs = append(nargs, narg)</span>
        }
        // syslog.Printf("ConvertValues args %v nargs %v", args, nargs)
        <span class="cov8" title="1">return nargs, err</span>
}

// ConvertValue mirrors the reference/default converter in database/sql/driver
// with _one_ exception.  We support uint64 with their high bit and the default
// implementation does not.  This function should be kept in sync with
// database/sql/driver defaultConverter.ConvertValue() except for that
// deliberate difference.
func (c converter) ConvertValue(v interface{}) (driver.Value, error) <span class="cov8" title="1">{
        if driver.IsValue(v) </span><span class="cov8" title="1">{
                return v, nil
        }</span>

        <span class="cov8" title="1">if vr, ok := v.(driver.Valuer); ok </span><span class="cov8" title="1">{
                sv, err := callValuerValue(vr)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !driver.IsValue(sv) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("non-Value type %T returned from Value", sv)
                }</span>
                <span class="cov8" title="1">return sv, nil</span>
        }
        <span class="cov8" title="1">rv := reflect.ValueOf(v)
        switch rv.Kind() </span>{
        case reflect.Ptr:<span class="cov8" title="1">
                // indirect pointers
                if rv.IsNil() </span><span class="cov0" title="0">{
                        return nil, nil
                }</span> else<span class="cov8" title="1"> {
                        return c.ConvertValue(rv.Elem().Interface())
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return rv.Int(), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                return rv.Uint(), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return rv.Float(), nil</span>
        case reflect.Bool:<span class="cov8" title="1">
                return rv.Bool(), nil</span>
        case reflect.Slice:<span class="cov8" title="1">
                switch t := rv.Type(); </span>{
                case t == jsonType:<span class="cov8" title="1">
                        return v, nil</span>
                case t.Elem().Kind() == reflect.Uint8:<span class="cov8" title="1">
                        return rv.Bytes(), nil</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("unsupported type %T, a slice of %s", v, t.Elem().Kind())</span>
                }
        case reflect.String:<span class="cov8" title="1">
                return rv.String(), nil</span>
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("unsupported type %T, a %s", v, rv.Kind())</span>
}

var valuerReflectType = reflect.TypeOf((*driver.Valuer)(nil)).Elem()

// callValuerValue returns vr.Value(), with one exception:
// If vr.Value is an auto-generated method on a pointer type and the
// pointer is nil, it would panic at runtime in the panicwrap
// method. Treat it like nil instead.
//
// This is so people can implement driver.Value on value types and
// still use nil pointers to those types to mean nil/NULL, just like
// string/*string.
//
// This is an exact copy of the same-named unexported function from the
// database/sql package.
func callValuerValue(vr driver.Valuer) (v driver.Value, err error) <span class="cov8" title="1">{
        if rv := reflect.ValueOf(vr); rv.Kind() == reflect.Ptr &amp;&amp;
                rv.IsNil() &amp;&amp;
                rv.Type().Elem().Implements(valuerReflectType) </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return vr.Value()</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

type mysqlTx struct {
        mc *mysqlConn
}

func (tx *mysqlTx) Commit() (err error) <span class="cov8" title="1">{
        if tx.mc == nil || tx.mc.closed.IsSet() </span><span class="cov0" title="0">{
                return ErrInvalidConn
        }</span>
        <span class="cov8" title="1">err = tx.mc.exec("COMMIT")
        tx.mc = nil
        return</span>
}

func (tx *mysqlTx) Rollback() (err error) <span class="cov8" title="1">{
        if tx.mc == nil || tx.mc.closed.IsSet() </span><span class="cov8" title="1">{
                return ErrInvalidConn
        }</span>
        <span class="cov8" title="1">err = tx.mc.exec("ROLLBACK")
        tx.mc = nil
        return</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Go MSKeeper Driver - A MySQL-Driver for Go's database/sql package
//
// Copyright 2020 The MSKeeper Authors. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at http://mozilla.org/MPL/2.0/.

package mysql

import (
        "crypto/tls"
        "database/sql"
        "database/sql/driver"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
)

// Registry for custom tls.Configs
var (
        tlsConfigLock     sync.RWMutex
        tlsConfigRegistry map[string]*tls.Config
)

// RegisterTLSConfig registers a custom tls.Config to be used with sql.Open.
// Use the key as a value in the DSN where tls=value.
//
// Note: The provided tls.Config is exclusively owned by the driver after
// registering it.
//
//  rootCertPool := x509.NewCertPool()
//  pem, err := ioutil.ReadFile("/path/ca-cert.pem")
//  if err != nil {
//      log.Fatal(err)
//  }
//  if ok := rootCertPool.AppendCertsFromPEM(pem); !ok {
//      log.Fatal("Failed to append PEM.")
//  }
//  clientCert := make([]tls.Certificate, 0, 1)
//  certs, err := tls.LoadX509KeyPair("/path/client-cert.pem", "/path/client-key.pem")
//  if err != nil {
//      log.Fatal(err)
//  }
//  clientCert = append(clientCert, certs)
//  mysql.RegisterTLSConfig("custom", &amp;tls.Config{
//      RootCAs: rootCertPool,
//      Certificates: clientCert,
//  })
//  db, err := sql.Open("mskeeper", "user@tcp(localhost:3306)/test?tls=custom")
//
func RegisterTLSConfig(key string, config *tls.Config) error <span class="cov8" title="1">{
        if _, isBool := readBool(key); isBool || strings.ToLower(key) == "skip-verify" || strings.ToLower(key) == "preferred" </span><span class="cov8" title="1">{
                return fmt.Errorf("key '%s' is reserved", key)
        }</span>

        <span class="cov8" title="1">tlsConfigLock.Lock()
        if tlsConfigRegistry == nil </span><span class="cov8" title="1">{
                tlsConfigRegistry = make(map[string]*tls.Config)
        }</span>

        <span class="cov8" title="1">tlsConfigRegistry[key] = config
        tlsConfigLock.Unlock()
        return nil</span>
}

// DeregisterTLSConfig removes the tls.Config associated with key.
func DeregisterTLSConfig(key string) <span class="cov8" title="1">{
        tlsConfigLock.Lock()
        if tlsConfigRegistry != nil </span><span class="cov8" title="1">{
                delete(tlsConfigRegistry, key)
        }</span>
        <span class="cov8" title="1">tlsConfigLock.Unlock()</span>
}

func getTLSConfigClone(key string) (config *tls.Config) <span class="cov8" title="1">{
        tlsConfigLock.RLock()
        if v, ok := tlsConfigRegistry[key]; ok </span><span class="cov8" title="1">{
                config = v.Clone()
        }</span>
        <span class="cov8" title="1">tlsConfigLock.RUnlock()
        return</span>
}

// Returns the bool value of the input.
// The 2nd return value indicates if the input was a valid bool value
func readBool(input string) (value bool, valid bool) <span class="cov8" title="1">{
        switch input </span>{
        case "1", "true", "TRUE", "True":<span class="cov8" title="1">
                return true, true</span>
        case "0", "false", "FALSE", "False":<span class="cov8" title="1">
                return false, true</span>
        }

        // Not a valid bool value
        <span class="cov8" title="1">return</span>
}

/******************************************************************************
*                           Time related utils                                *
******************************************************************************/

func parseDateTime(str string, loc *time.Location) (t time.Time, err error) <span class="cov8" title="1">{
        base := "0000-00-00 00:00:00.0000000"
        switch len(str) </span>{
        case 10, 19, 21, 22, 23, 24, 25, 26:<span class="cov8" title="1"> // up to "YYYY-MM-DD HH:MM:SS.MMMMMM"
                if str == base[:len(str)] </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">t, err = time.Parse(timeFormat[:len(str)], str)</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf("invalid time string: %s", str)
                return</span>
        }

        // Adjust location
        <span class="cov8" title="1">if err == nil &amp;&amp; loc != time.UTC </span><span class="cov8" title="1">{
                y, mo, d := t.Date()
                h, mi, s := t.Clock()
                t, err = time.Date(y, mo, d, h, mi, s, t.Nanosecond(), loc), nil
        }</span>

        <span class="cov8" title="1">return</span>
}

func parseBinaryDateTime(num uint64, data []byte, loc *time.Location) (driver.Value, error) <span class="cov8" title="1">{
        switch num </span>{
        case 0:<span class="cov8" title="1">
                return time.Time{}, nil</span>
        case 4:<span class="cov8" title="1">
                return time.Date(
                        int(binary.LittleEndian.Uint16(data[:2])), // year
                        time.Month(data[2]),                       // month
                        int(data[3]),                              // day
                        0, 0, 0, 0,
                        loc,
                ), nil</span>
        case 7:<span class="cov8" title="1">
                return time.Date(
                        int(binary.LittleEndian.Uint16(data[:2])), // year
                        time.Month(data[2]),                       // month
                        int(data[3]),                              // day
                        int(data[4]),                              // hour
                        int(data[5]),                              // minutes
                        int(data[6]),                              // seconds
                        0,
                        loc,
                ), nil</span>
        case 11:<span class="cov8" title="1">
                return time.Date(
                        int(binary.LittleEndian.Uint16(data[:2])), // year
                        time.Month(data[2]),                       // month
                        int(data[3]),                              // day
                        int(data[4]),                              // hour
                        int(data[5]),                              // minutes
                        int(data[6]),                              // seconds
                        int(binary.LittleEndian.Uint32(data[7:11]))*1000, // nanoseconds
                        loc,
                ), nil</span>
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("invalid DATETIME packet length %d", num)</span>
}

// zeroDateTime is used in formatBinaryDateTime to avoid an allocation
// if the DATE or DATETIME has the zero value.
// It must never be changed.
// The current behavior depends on database/sql copying the result.
var zeroDateTime = []byte("0000-00-00 00:00:00.000000")

const digits01 = "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
const digits10 = "0000000000111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999"

func appendMicrosecs(dst, src []byte, decimals int) []byte <span class="cov8" title="1">{
        if decimals &lt;= 0 </span><span class="cov8" title="1">{
                return dst
        }</span>
        <span class="cov8" title="1">if len(src) == 0 </span><span class="cov8" title="1">{
                return append(dst, ".000000"[:decimals+1]...)
        }</span>

        <span class="cov8" title="1">microsecs := binary.LittleEndian.Uint32(src[:4])
        p1 := byte(microsecs / 10000)
        microsecs -= 10000 * uint32(p1)
        p2 := byte(microsecs / 100)
        microsecs -= 100 * uint32(p2)
        p3 := byte(microsecs)

        switch decimals </span>{
        default:<span class="cov8" title="1">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                        digits10[p2], digits01[p2],
                        digits10[p3], digits01[p3],
                )</span>
        case 1:<span class="cov8" title="1">
                return append(dst, '.',
                        digits10[p1],
                )</span>
        case 2:<span class="cov8" title="1">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                )</span>
        case 3:<span class="cov8" title="1">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                        digits10[p2],
                )</span>
        case 4:<span class="cov8" title="1">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                        digits10[p2], digits01[p2],
                )</span>
        case 5:<span class="cov8" title="1">
                return append(dst, '.',
                        digits10[p1], digits01[p1],
                        digits10[p2], digits01[p2],
                        digits10[p3],
                )</span>
        }
}

func formatBinaryDateTime(src []byte, length uint8) (driver.Value, error) <span class="cov8" title="1">{
        // length expects the deterministic length of the zero value,
        // negative time and 100+ hours are automatically added if needed
        if len(src) == 0 </span><span class="cov8" title="1">{
                return zeroDateTime[:length], nil
        }</span>
        <span class="cov8" title="1">var dst []byte      // return value
        var p1, p2, p3 byte // current digit pair

        switch length </span>{
        case 10, 19, 21, 22, 23, 24, 25, 26:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                t := "DATE"
                if length &gt; 10 </span><span class="cov8" title="1">{
                        t += "TIME"
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("illegal %s length %d", t, length)</span>
        }
        <span class="cov8" title="1">switch len(src) </span>{
        case 4, 7, 11:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                t := "DATE"
                if length &gt; 10 </span><span class="cov8" title="1">{
                        t += "TIME"
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("illegal %s packet length %d", t, len(src))</span>
        }
        <span class="cov8" title="1">dst = make([]byte, 0, length)
        // start with the date
        year := binary.LittleEndian.Uint16(src[:2])
        pt := year / 100
        p1 = byte(year - 100*uint16(pt))
        p2, p3 = src[2], src[3]
        dst = append(dst,
                digits10[pt], digits01[pt],
                digits10[p1], digits01[p1], '-',
                digits10[p2], digits01[p2], '-',
                digits10[p3], digits01[p3],
        )
        if length == 10 </span><span class="cov8" title="1">{
                return dst, nil
        }</span>
        <span class="cov8" title="1">if len(src) == 4 </span><span class="cov8" title="1">{
                return append(dst, zeroDateTime[10:length]...), nil
        }</span>
        <span class="cov8" title="1">dst = append(dst, ' ')
        p1 = src[4] // hour
        src = src[5:]

        // p1 is 2-digit hour, src is after hour
        p2, p3 = src[0], src[1]
        dst = append(dst,
                digits10[p1], digits01[p1], ':',
                digits10[p2], digits01[p2], ':',
                digits10[p3], digits01[p3],
        )
        return appendMicrosecs(dst, src[2:], int(length)-20), nil</span>
}

func formatBinaryTime(src []byte, length uint8) (driver.Value, error) <span class="cov8" title="1">{
        // length expects the deterministic length of the zero value,
        // negative time and 100+ hours are automatically added if needed
        if len(src) == 0 </span><span class="cov8" title="1">{
                return zeroDateTime[11 : 11+length], nil
        }</span>
        <span class="cov8" title="1">var dst []byte // return value

        switch length </span>{
        case
                8,                      // time (can be up to 10 when negative and 100+ hours)
                10, 11, 12, 13, 14, 15:<span class="cov8" title="1"></span> // time with fractional seconds
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("illegal TIME length %d", length)</span>
        }
        <span class="cov8" title="1">switch len(src) </span>{
        case 8, 12:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid TIME packet length %d", len(src))</span>
        }
        // +2 to enable negative time and 100+ hours
        <span class="cov8" title="1">dst = make([]byte, 0, length+2)
        if src[0] == 1 </span><span class="cov8" title="1">{
                dst = append(dst, '-')
        }</span>
        <span class="cov8" title="1">days := binary.LittleEndian.Uint32(src[1:5])
        hours := int64(days)*24 + int64(src[5])

        if hours &gt;= 100 </span><span class="cov8" title="1">{
                dst = strconv.AppendInt(dst, hours, 10)
        }</span> else<span class="cov8" title="1"> {
                dst = append(dst, digits10[hours], digits01[hours])
        }</span>

        <span class="cov8" title="1">min, sec := src[6], src[7]
        dst = append(dst, ':',
                digits10[min], digits01[min], ':',
                digits10[sec], digits01[sec],
        )
        return appendMicrosecs(dst, src[8:], int(length)-9), nil</span>
}

/******************************************************************************
*                       Convert from and to bytes                             *
******************************************************************************/

func uint64ToBytes(n uint64) []byte <span class="cov8" title="1">{
        return []byte{
                byte(n),
                byte(n &gt;&gt; 8),
                byte(n &gt;&gt; 16),
                byte(n &gt;&gt; 24),
                byte(n &gt;&gt; 32),
                byte(n &gt;&gt; 40),
                byte(n &gt;&gt; 48),
                byte(n &gt;&gt; 56),
        }
}</span>

func uint64ToString(n uint64) []byte <span class="cov8" title="1">{
        var a [20]byte
        i := 20

        // U+0030 = 0
        // ...
        // U+0039 = 9

        var q uint64
        for n &gt;= 10 </span><span class="cov8" title="1">{
                i--
                q = n / 10
                a[i] = uint8(n-q*10) + 0x30
                n = q
        }</span>

        <span class="cov8" title="1">i--
        a[i] = uint8(n) + 0x30

        return a[i:]</span>
}

// treats string value as unsigned integer representation
func stringToInt(b []byte) int <span class="cov8" title="1">{
        val := 0
        for i := range b </span><span class="cov8" title="1">{
                val *= 10
                val += int(b[i] - 0x30)
        }</span>
        <span class="cov8" title="1">return val</span>
}

// returns the string read as a bytes slice, wheter the value is NULL,
// the number of bytes read and an error, in case the string is longer than
// the input slice
func readLengthEncodedString(b []byte) ([]byte, bool, int, error) <span class="cov8" title="1">{
        // Get length
        num, isNull, n := readLengthEncodedInteger(b)
        if num &lt; 1 </span><span class="cov8" title="1">{
                return b[n:n], isNull, n, nil
        }</span>

        <span class="cov8" title="1">n += int(num)

        // Check data length
        if len(b) &gt;= n </span><span class="cov8" title="1">{
                return b[n-int(num) : n : n], false, n, nil
        }</span>
        <span class="cov0" title="0">return nil, false, n, io.EOF</span>
}

// returns the number of bytes skipped and an error, in case the string is
// longer than the input slice
func skipLengthEncodedString(b []byte) (int, error) <span class="cov8" title="1">{
        // Get length
        num, _, n := readLengthEncodedInteger(b)
        if num &lt; 1 </span><span class="cov8" title="1">{
                return n, nil
        }</span>

        <span class="cov8" title="1">n += int(num)

        // Check data length
        if len(b) &gt;= n </span><span class="cov8" title="1">{
                return n, nil
        }</span>
        <span class="cov0" title="0">return n, io.EOF</span>
}

// returns the number read, whether the value is NULL and the number of bytes read
func readLengthEncodedInteger(b []byte) (uint64, bool, int) <span class="cov8" title="1">{
        // See issue #349
        if len(b) == 0 </span><span class="cov8" title="1">{
                return 0, true, 1
        }</span>

        <span class="cov8" title="1">switch b[0] </span>{
        // 251: NULL
        case 0xfb:<span class="cov8" title="1">
                return 0, true, 1</span>

        // 252: value of following 2
        case 0xfc:<span class="cov8" title="1">
                return uint64(b[1]) | uint64(b[2])&lt;&lt;8, false, 3</span>

        // 253: value of following 3
        case 0xfd:<span class="cov8" title="1">
                return uint64(b[1]) | uint64(b[2])&lt;&lt;8 | uint64(b[3])&lt;&lt;16, false, 4</span>

        // 254: value of following 8
        case 0xfe:<span class="cov8" title="1">
                return uint64(b[1]) | uint64(b[2])&lt;&lt;8 | uint64(b[3])&lt;&lt;16 |
                                uint64(b[4])&lt;&lt;24 | uint64(b[5])&lt;&lt;32 | uint64(b[6])&lt;&lt;40 |
                                uint64(b[7])&lt;&lt;48 | uint64(b[8])&lt;&lt;56,
                        false, 9</span>
        }

        // 0-250: value of first byte
        <span class="cov8" title="1">return uint64(b[0]), false, 1</span>
}

// encodes a uint64 value and appends it to the given bytes slice
func appendLengthEncodedInteger(b []byte, n uint64) []byte <span class="cov8" title="1">{
        switch </span>{
        case n &lt;= 250:<span class="cov8" title="1">
                return append(b, byte(n))</span>

        case n &lt;= 0xffff:<span class="cov8" title="1">
                return append(b, 0xfc, byte(n), byte(n&gt;&gt;8))</span>

        case n &lt;= 0xffffff:<span class="cov8" title="1">
                return append(b, 0xfd, byte(n), byte(n&gt;&gt;8), byte(n&gt;&gt;16))</span>
        }
        <span class="cov8" title="1">return append(b, 0xfe, byte(n), byte(n&gt;&gt;8), byte(n&gt;&gt;16), byte(n&gt;&gt;24),
                byte(n&gt;&gt;32), byte(n&gt;&gt;40), byte(n&gt;&gt;48), byte(n&gt;&gt;56))</span>
}

// reserveBuffer checks cap(buf) and expand buffer to len(buf) + appendSize.
// If cap(buf) is not enough, reallocate new buffer.
func reserveBuffer(buf []byte, appendSize int) []byte <span class="cov8" title="1">{
        newSize := len(buf) + appendSize
        if cap(buf) &lt; newSize </span><span class="cov8" title="1">{
                // Grow buffer exponentially
                newBuf := make([]byte, len(buf)*2+appendSize)
                copy(newBuf, buf)
                buf = newBuf
        }</span>
        <span class="cov8" title="1">return buf[:newSize]</span>
}

// escapeBytesBackslash escapes []byte with backslashes (\)
// This escapes the contents of a string (provided as []byte) by adding backslashes before special
// characters, and turning others into specific escape sequences, such as
// turning newlines into \n and null bytes into \0.
// https://github.com/mysql/mysql-server/blob/mysql-5.7.5/mysys/charset.c#L823-L932
func escapeBytesBackslash(buf, v []byte) []byte <span class="cov8" title="1">{
        pos := len(buf)
        buf = reserveBuffer(buf, len(v)*2)

        for _, c := range v </span><span class="cov8" title="1">{
                switch c </span>{
                case '\x00':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = '0'
                        pos += 2</span>
                case '\n':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = 'n'
                        pos += 2</span>
                case '\r':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = 'r'
                        pos += 2</span>
                case '\x1a':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = 'Z'
                        pos += 2</span>
                case '\'':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = '\''
                        pos += 2</span>
                case '"':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = '"'
                        pos += 2</span>
                case '\\':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = '\\'
                        pos += 2</span>
                default:<span class="cov8" title="1">
                        buf[pos] = c
                        pos++</span>
                }
        }

        <span class="cov8" title="1">return buf[:pos]</span>
}

// escapeStringBackslash is similar to escapeBytesBackslash but for string.
func escapeStringBackslash(buf []byte, v string) []byte <span class="cov8" title="1">{
        pos := len(buf)
        buf = reserveBuffer(buf, len(v)*2)

        for i := 0; i &lt; len(v); i++ </span><span class="cov8" title="1">{
                c := v[i]
                switch c </span>{
                case '\x00':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = '0'
                        pos += 2</span>
                case '\n':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = 'n'
                        pos += 2</span>
                case '\r':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = 'r'
                        pos += 2</span>
                case '\x1a':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = 'Z'
                        pos += 2</span>
                case '\'':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = '\''
                        pos += 2</span>
                case '"':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = '"'
                        pos += 2</span>
                case '\\':<span class="cov8" title="1">
                        buf[pos] = '\\'
                        buf[pos+1] = '\\'
                        pos += 2</span>
                default:<span class="cov8" title="1">
                        buf[pos] = c
                        pos++</span>
                }
        }

        <span class="cov8" title="1">return buf[:pos]</span>
}

// escapeBytesQuotes escapes apostrophes in []byte by doubling them up.
// This escapes the contents of a string by doubling up any apostrophes that
// it contains. This is used when the NO_BACKSLASH_ESCAPES SQL_MODE is in
// effect on the server.
// https://github.com/mysql/mysql-server/blob/mysql-5.7.5/mysys/charset.c#L963-L1038
func escapeBytesQuotes(buf, v []byte) []byte <span class="cov8" title="1">{
        pos := len(buf)
        buf = reserveBuffer(buf, len(v)*2)

        for _, c := range v </span><span class="cov8" title="1">{
                if c == '\'' </span><span class="cov8" title="1">{
                        buf[pos] = '\''
                        buf[pos+1] = '\''
                        pos += 2
                }</span> else<span class="cov8" title="1"> {
                        buf[pos] = c
                        pos++
                }</span>
        }

        <span class="cov8" title="1">return buf[:pos]</span>
}

// escapeStringQuotes is similar to escapeBytesQuotes but for string.
func escapeStringQuotes(buf []byte, v string) []byte <span class="cov8" title="1">{
        pos := len(buf)
        buf = reserveBuffer(buf, len(v)*2)

        for i := 0; i &lt; len(v); i++ </span><span class="cov8" title="1">{
                c := v[i]
                if c == '\'' </span><span class="cov8" title="1">{
                        buf[pos] = '\''
                        buf[pos+1] = '\''
                        pos += 2
                }</span> else<span class="cov8" title="1"> {
                        buf[pos] = c
                        pos++
                }</span>
        }

        <span class="cov8" title="1">return buf[:pos]</span>
}

/******************************************************************************
*                               Sync utils                                    *
******************************************************************************/

// noCopy may be embedded into structs which must not be copied
// after the first use.
//
// See https://github.com/golang/go/issues/8005#issuecomment-190753527
// for details.
type noCopy struct{}

// Lock is a no-op used by -copylocks checker from `go vet`.
func (*noCopy) Lock() {<span class="cov8" title="1">}</span>

// atomicBool is a wrapper around uint32 for usage as a boolean value with
// atomic access.
type atomicBool struct {
        _noCopy noCopy
        value   uint32
}

// IsSet returns whether the current boolean value is true
func (ab *atomicBool) IsSet() bool <span class="cov8" title="1">{
        return atomic.LoadUint32(&amp;ab.value) &gt; 0
}</span>

// Set sets the value of the bool regardless of the previous value
func (ab *atomicBool) Set(value bool) <span class="cov8" title="1">{
        if value </span><span class="cov8" title="1">{
                atomic.StoreUint32(&amp;ab.value, 1)
        }</span> else<span class="cov8" title="1"> {
                atomic.StoreUint32(&amp;ab.value, 0)
        }</span>
}

// TrySet sets the value of the bool and returns whether the value changed
func (ab *atomicBool) TrySet(value bool) bool <span class="cov8" title="1">{
        if value </span><span class="cov8" title="1">{
                return atomic.SwapUint32(&amp;ab.value, 1) == 0
        }</span>
        <span class="cov8" title="1">return atomic.SwapUint32(&amp;ab.value, 0) &gt; 0</span>
}

// atomicError is a wrapper for atomically accessed error values
type atomicError struct {
        value atomic.Value
}

// Set sets the error value regardless of the previous value.
// The value must not be nil
func (ae *atomicError) Set(value error) <span class="cov8" title="1">{
        ae.value.Store(value)
}</span>

// Value returns the current error value
func (ae *atomicError) Value() error <span class="cov8" title="1">{
        if v := ae.value.Load(); v != nil </span><span class="cov8" title="1">{
                // this will panic if the value doesn't implement the error interface
                return v.(error)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func namedValueToValue(named []driver.NamedValue) ([]driver.Value, error) <span class="cov8" title="1">{
        dargs := make([]driver.Value, len(named))
        for n, param := range named </span><span class="cov8" title="1">{
                if len(param.Name) &gt; 0 </span><span class="cov0" title="0">{
                        // TODO: support the use of Named Parameters #561
                        return nil, errors.New("mysql: driver does not support the use of Named Parameters")
                }</span>
                <span class="cov8" title="1">dargs[n] = param.Value</span>
        }
        <span class="cov8" title="1">return dargs, nil</span>
}

func mapIsolationLevel(level driver.IsolationLevel) (string, error) <span class="cov8" title="1">{
        switch sql.IsolationLevel(level) </span>{
        case sql.LevelRepeatableRead:<span class="cov8" title="1">
                return "REPEATABLE READ", nil</span>
        case sql.LevelReadCommitted:<span class="cov8" title="1">
                return "READ COMMITTED", nil</span>
        case sql.LevelReadUncommitted:<span class="cov8" title="1">
                return "READ UNCOMMITTED", nil</span>
        case sql.LevelSerializable:<span class="cov8" title="1">
                return "SERIALIZABLE", nil</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("mysql: unsupported isolation level: %v", level)</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package options

import (
        "io"
        "io/ioutil"
        "sync"
        "time"

        "gitlab.papegames.com/fringe/mskeeper/log"
        "gitlab.papegames.com/fringe/mskeeper/notifier"
        "gitlab.papegames.com/fringe/mskeeper/policy"
)

type Options struct {
        mutex           sync.RWMutex
        Switch          bool                // mskeeper的开关，可重入
        Notifier        notifier.Notifier   // 检查结果的通知对象
        MaxExecTime     time.Duration       // SQL的最大执行时间，超出则通知告警
        Capacity        int                 // mskeeper队列的最大长度，超出则丢失后来的SQL的检查
        MaxSilentPeriod time.Duration       // 最大的静默周期，即周期MaxSilentPeriod，相同签名的SQL告警至多只有一次。
        LogOutput       io.Writer           // mskeeper自身的日志输出 eg. os.Stdout, logfile
        SQLWhiteLists   map[string]struct{} // 不需要检测的SQL白名单
        SQLCacheSize    int                 // SQL哈希缓存大小设置, 0为不设置缓存, 默认以及上限是2千
}

const MaxSQLCacheSize = 2000

type Option func(*Options)

func NewOptions(opts ...Option) *Options <span class="cov8" title="1">{
        opt := DefaultOptions()

        for _, o := range opts </span><span class="cov8" title="1">{
                o(opt)
        }</span>

        <span class="cov8" title="1">return opt</span>
}

func (o *Options) Clone() *Options <span class="cov8" title="1">{
        nop := new(Options)
        nop.Switch = o.Switch
        nop.Notifier = o.Notifier
        nop.MaxExecTime = o.MaxExecTime
        nop.Capacity = o.Capacity
        nop.MaxSilentPeriod = o.MaxSilentPeriod
        nop.LogOutput = o.LogOutput
        nop.SQLCacheSize = o.SQLCacheSize

        nop.SQLWhiteLists = make(map[string]struct{})
        for k, v := range o.SQLWhiteLists </span><span class="cov8" title="1">{
                nop.SQLWhiteLists[k] = v
        }</span>
        <span class="cov8" title="1">return nop</span>
}

func DefaultOptions() *Options <span class="cov8" title="1">{
        opt := &amp;Options{
                Switch:          false,
                MaxExecTime:     policy.DefaultMaxExecTime,
                MaxSilentPeriod: 1 * time.Hour,
                Notifier:        notifier.NewDefaultNotifier(),
                Capacity:        10240,
                LogOutput:       ioutil.Discard,
                SQLWhiteLists:   map[string]struct{}{},
                SQLCacheSize:    MaxSQLCacheSize,
        }
        return opt
}</span>

func CheckIfInSQLWhiteLists(o *Options, sqlstring string) bool <span class="cov8" title="1">{
        o.mutex.RLock()
        defer o.mutex.RUnlock()

        _, ok := o.SQLWhiteLists[sqlstring]

        return ok
}</span>

func WithSQLWhiteLists(sqlstring string) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{
                o.mutex.Lock()
                defer o.mutex.Unlock()

                o.SQLWhiteLists[sqlstring] = struct{}{}
        }</span>
}

func FetchLogLevel(o *Options) notifier.Level <span class="cov8" title="1">{

        return log.MSKLog().GetLevel()
}</span>

func WithLogLevel(level notifier.Level) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{

                log.MSKLog().SetLevel(level)
        }</span>
}

func FetchLogOutput(o *Options) io.Writer <span class="cov8" title="1">{

        return log.MSKLog().Out
}</span>

func WithLogOutput(lo io.Writer) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{
                log.MSKLog().SetOutput(lo)
        }</span>
}

func FetchMaxSilentPeriod(o *Options) time.Duration <span class="cov8" title="1">{
        o.mutex.RLock()
        defer o.mutex.RUnlock()

        return o.MaxSilentPeriod
}</span>

func FetchSQLCacheSize(o *Options) int <span class="cov8" title="1">{
        o.mutex.RLock()
        defer o.mutex.RUnlock()

        return o.SQLCacheSize
}</span>

func WithSQLCacheSize(s int) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{
                o.mutex.Lock()
                defer o.mutex.Unlock()
                if s &gt; MaxSQLCacheSize </span><span class="cov8" title="1">{
                        s = MaxSQLCacheSize
                }</span>
                <span class="cov8" title="1">o.SQLCacheSize = s</span>
        }
}

func WithMaxSilentPeriod(sp time.Duration) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{
                o.mutex.Lock()
                defer o.mutex.Unlock()

                o.MaxSilentPeriod = sp
        }</span>
}

func FetchSwitch(o *Options) bool <span class="cov8" title="1">{

        return o.Switch
}</span>

func WithSwitch(s bool) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{

                o.Switch = s
        }</span>
}

func FetchMaxExecTime(o *Options) time.Duration <span class="cov8" title="1">{
        o.mutex.RLock()
        defer o.mutex.RUnlock()

        return o.MaxExecTime
}</span>

func WithMaxExecTime(t time.Duration) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{
                o.mutex.Lock()
                defer o.mutex.Unlock()

                o.MaxExecTime = t
        }</span>
}

func FetchNotifier(o *Options) notifier.Notifier <span class="cov8" title="1">{
        o.mutex.RLock()
        defer o.mutex.RUnlock()

        return o.Notifier
}</span>

func WithNotifier(n notifier.Notifier) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{
                o.mutex.Lock()
                defer o.mutex.Unlock()

                o.Notifier = n
        }</span>
}

func FetchCapacity(o *Options) int <span class="cov8" title="1">{
        o.mutex.RLock()
        defer o.mutex.RUnlock()

        return o.Capacity
}</span>

func WithCapacity(n int) Option <span class="cov8" title="1">{
        return func(o *Options) </span><span class="cov8" title="1">{
                o.mutex.Lock()
                defer o.mutex.Unlock()

                o.Capacity = n
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package policy

import (
        // "bytes"
        "context"
        "database/sql"
        "fmt"
        "gitlab.papegames.com/fringe/mskeeper/log"
        "gitlab.papegames.com/fringe/mskeeper/misc"
        // syslog "log"
        "regexp"
        "strconv"
        "strings"
        "time"
)

/*
策略：
前置：
1. 操作影响的行数 &gt; 1/3 总行数（count(1))
2. 行数 rows &gt; 1w

*/

// REF
// MySQL Doc: 8.0https://dev.mysql.com/doc/refman/8.0/en/explain-output.html
//       all: https://dev.mysql.com/doc/refman/5.5/en/alter-table-online-operations.html
// 中文解释:   https://www.cnblogs.com/danhuangpai/p/8475458.html
/*

SIMPLE
explain insert into test select * from test where test.value in (select value from test)

SUBQUERY
explain insert into test select * from test where test.id = (select id from test limit 1)

UNION
UNION RESULT
explain
select * from test where test.value_str = '111'
union
select * from test where test.value_str = '222';

DEPENDENT SUBQUERY
explain select * from test t1 where t1.value = (select id from test t2 where t2.value = t1.value limit 1)

DERIVED (5.7+中优化去掉了部分)
explain select * from (select * from test) b;

MATERIALIZED

UNCACHEABLE SUBQUERY
UNCACHEABLE UNION

关于filtered字段
filtered (JSON name: filtered)

The filtered column indicates an estimated percentage of table rows that will be filtered by the table condition.
The maximum value is 100, which means no filtering of rows occurred. Values decreasing from 100 indicate _
increasing amounts of filtering.
rows shows the estimated number of rows examined and rows × filtered shows the number of rows that will be joined _
with the following table. For example, if rows is 1000 and filtered is 50.00 (50%),
the number of rows to be joined with the following table is 1000 × 50% = 500.

5.5和5.7在同样类型不匹配的情况下，表现并不一样。

explain extended select * from test_policy where value = 72
5.7
1        SIMPLE        test_policy        NULL        ALL        NULL        NULL        NULL        NULL        10157        10.00        Using where

5.5
1        SIMPLE        test_policy        ALL        NULL        NULL        NULL        NULL        10443        100.00        Using where

目测是做了优化。例如, 对于类型不匹配（value1 is varchar[6]），5.7查询效率filtered = 10, 是5.5的十倍
select * from test where value1 = 5

*/

var (
        supportExtended bool = true // true表示支持 explain extended语法，8.0以上不支持

        delayVersion bool = false // 表示已经获取了mysql的版本，假设一个包只有一个版本的MySQL（假设很强吗？）

        notSupportContext bool = false // true表示当前mysql版本（5.7.X）在context的事务处理方面存在bug

        notSupportExplainInsert bool = false // true表示当前mysql版本 (5.5.x) 不支持explain insert 语句

        tableNameReg = regexp.MustCompile(`&lt;.*?&gt;`)

        // mysql的 context 超时被取消之后，可能会死锁。这里的时间大一些。
        // 避开 5.7.25版本
        MaxTimeoutOfExplain = 3 * time.Second
)

type PolicyCode int

var (
        ErrExplainRowsFormatErr = fmt.Errorf("rows field is invalid")
)

const (
        ErrPolicyCodeSafe          PolicyCode = 5200
        ErrPolicyCodeExeCost       PolicyCode = 5201
        ErrPolicyCodeRowsAbs       PolicyCode = 5202
        ErrPolicyCodeRowsInvolve   PolicyCode = 5203
        ErrPolicyCodeAllTableScan  PolicyCode = 5204
        ErrPolicyCodeDataTruncate  PolicyCode = 5205
        WarnPolicyCodeDataTruncate PolicyCode = 5206
)

func (pl PolicyCode) String() string <span class="cov8" title="1">{
        switch pl </span>{
        case ErrPolicyCodeSafe:<span class="cov8" title="1">
                return "ErrPolicyCodeSafe"</span>
        case ErrPolicyCodeExeCost:<span class="cov8" title="1">
                return "ErrPolicyCodeExeCost"</span>
        case ErrPolicyCodeRowsAbs:<span class="cov8" title="1">
                return "ErrPolicyCodeRowsAbs"</span>
        case ErrPolicyCodeRowsInvolve:<span class="cov8" title="1">
                return "ErrPolicyCodeRowsInvolve"</span>
        case ErrPolicyCodeAllTableScan:<span class="cov8" title="1">
                return "ErrPolicyCodeAllTableScan"</span>
        case ErrPolicyCodeDataTruncate:<span class="cov8" title="1">
                return "ErrPolicyCodeDataTruncate"</span>
        case WarnPolicyCodeDataTruncate:<span class="cov8" title="1">
                return "WarnPolicyCodeDataTruncate"</span>
        default:<span class="cov8" title="1">
                str := strconv.Itoa(int(pl))
                return str</span>
        }
}

type PolicyError struct {
        Code PolicyCode `json:"code"`
        Msg  string     `json:"msg"`
}

func NewPolicyErrorSafe(rowsAffected int, cost time.Duration) *PolicyError <span class="cov8" title="1">{
        return &amp;PolicyError{Code: ErrPolicyCodeSafe,
                Msg: fmt.Sprintf("safe sql, rows_affected:%v cost:%0.3vms", rowsAffected, float64(cost.Nanoseconds())/float64(1000000))}
}</span>

func NewPolicyError(code PolicyCode, msg string) *PolicyError <span class="cov8" title="1">{
        return &amp;PolicyError{Code: code, Msg: msg}
}</span>

func (err *PolicyError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("[policy_code=%v,policy_msg=%v]", err.Code, err.Msg)
}</span>

type PolicyChecker interface {
        Check(db *sql.DB, er []ExplainRecord, query string, args []interface{}) error
}

type ExplainRecord struct {
        ID           sql.NullString
        SelectType   sql.NullString
        Table        sql.NullString
        Partitions   sql.NullString
        Type         sql.NullString
        PossibleKeys sql.NullString
        Key          sql.NullString
        KeyLen       sql.NullString
        Ref          sql.NullString
        Rows         sql.NullString
        Filtered     sql.NullString
        Extra        sql.NullString
}

// 根据 filtered 和 rows 的比例, 获取真正受影响的行数
func (er *ExplainRecord) GetExplainRealRows() (int, error) <span class="cov8" title="1">{

        if !er.Rows.Valid </span><span class="cov8" title="1">{
                return 0, ErrExplainRowsFormatErr
        }</span> else<span class="cov8" title="1"> {
                rowCnt, _ := strconv.Atoi(er.Rows.String)
                var rate float64 = 100.0
                if er.Filtered.Valid </span><span class="cov8" title="1">{
                        rate, _ = strconv.ParseFloat(er.Filtered.String, 64)
                }</span>
                <span class="cov8" title="1">realRowCnt := int(float64(rowCnt) * (rate / float64(100.0)))
                // syslog.Printf("GetExplainRealRows: rate %v, rowCnt %v realRowCnt %v", rate, rowCnt, realRowCnt)
                log.MSKLog().Debugf("GetExplainRealRows: rate %v, rowCnt %v realRowCnt %v", rate, rowCnt, realRowCnt)
                return realRowCnt, nil</span>
        }
}

func NewExplainRecord() *ExplainRecord <span class="cov8" title="1">{
        return &amp;ExplainRecord{}
}</span>

// func MakeExplainRecords(db *sql.DB, query string, args ...interface{}) ([]ExplainRecord, error) {
//         explainRecords := []ExplainRecord{}

//         //        originQuery := query
//         query = "explain " + query

//         rows, err := db.Query(query, args...)
//         if err != nil {
//                 return explainRecords, err
//         }
//         defer rows.Close()

//         explainRecords, err = genExplainRecordsFromRows(rows)
//         if err != nil {
//                 // log.Printf("MakeExplainRecords(%v, %v) GenExplainRecordsFromRows failed %v", query, args, err)
//                 return explainRecords, err
//         }
//         //log.Printf("MakeExplainRecords %v on origin query %v", explainRecords, originQuery)
//         return explainRecords, nil
// }

func safeRollback(memo string, tx *sql.Tx) error <span class="cov8" title="1">{
        err := tx.Rollback()
        if err != sql.ErrTxDone &amp;&amp; err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("safeRollback(%v) rollback failed %v",
                        memo, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// !!!!!!!!!!!!!!!!!!!
// mysql 5.7.25 实测，偶发的会出现死亡deadlock：
// show 不出来线程,
// BeginTx、QueryContext的时候不能通过ctx取消!!!!!否则会出现Begin了的事务无法结束，锁住整个表
func MakeExplainRecords(db *sql.DB, query string, timeout time.Duration, args []interface{}) ([]ExplainRecord, error) <span class="cov8" title="1">{
        explainRecords := []ExplainRecord{}

        ctx, cancel := context.WithCancel(context.Background())
        // 针对 mysql 5.7.x 版本在context方面的bug，workaround
        if notSupportContext </span><span class="cov8" title="1">{
                timeout = timeout * 100
        }</span>
        <span class="cov8" title="1">defer time.AfterFunc(timeout, cancel).Stop()

        tx, err := db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MakeExplainRecords(%v, %v) BeginTx failed %v", query, args, err)
                return explainRecords, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = safeRollback(fmt.Sprintf("MakeExplainRecords() query of %v rollback", query), tx)
        }</span>()

        <span class="cov8" title="1">if !delayVersion </span><span class="cov8" title="1">{
                supportExtended = true
                versionQuery := "SELECT version();"
                row := tx.QueryRowContext(ctx, versionQuery)
                var version string
                if err := row.Scan(&amp;version); err != nil </span><span class="cov0" title="0">{
                        log.MSKLog().Errorf("MakeExplainRecords(%v, %v) QueryRowContext failed %v", query, args, err)
                        return explainRecords, err
                }</span>

                <span class="cov8" title="1">vs := strings.Split(version, ".")
                if len(vs) &gt;= 1 &amp;&amp; vs[0] == "8" </span><span class="cov8" title="1">{ // mysql 8.0.x+
                        supportExtended = false
                }</span>
                <span class="cov8" title="1">if len(vs) &gt;= 2 &amp;&amp; vs[0] == "5" &amp;&amp; vs[1] == "7" </span><span class="cov0" title="0">{ // mysql 5.7.x+
                        notSupportContext = true
                }</span>
                <span class="cov8" title="1">if len(vs) &gt;= 2 &amp;&amp; vs[0] == "5" &amp;&amp; vs[1] == "5" </span><span class="cov0" title="0">{
                        notSupportExplainInsert = true
                }</span>
                <span class="cov8" title="1">delayVersion = true</span>
        }
        // 已知 mysql 8.0 不支持 explain 的 extended关键字！！！！！
        <span class="cov8" title="1">if supportExtended </span><span class="cov0" title="0">{
                query = "explain extended " + query
        }</span> else<span class="cov8" title="1"> {
                query = "explain " + query
        }</span>

        // 已知 mysql 5.5 不支持 explain insert select 句式，过滤insert
        <span class="cov8" title="1">if notSupportExplainInsert </span><span class="cov0" title="0">{
                query = misc.FilterInnerSelectFor55Minus(query)
        }</span>

        <span class="cov8" title="1">rows, err := tx.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MakeExplainRecords(%v, %v) QueryContext failed %v", query, args, err)
                return explainRecords, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        explainRecords, err = genExplainRecordsFromRows(rows)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MakeExplainRecords(%v, %v) GenExplainRecordsFromRows failed %v", query, args, err)
                return explainRecords, err
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MakeExplainRecords(%v, %v) Commit failed %v", query, args, err)
                return explainRecords, err
        }</span>
        //log.Printf("MakeExplainRecords %v on origin query %v", explainRecords, originQuery)
        <span class="cov8" title="1">return explainRecords, nil</span>
}

func genExplainRecordsFromRows(rows *sql.Rows) ([]ExplainRecord, error) <span class="cov8" title="1">{
        records := make([]ExplainRecord, 0)
        columns, _ := rows.Columns()

        for rows.Next() </span><span class="cov8" title="1">{
                record := NewExplainRecord()
                // mysql 5.5-, 5.6
                if len(columns) == 11 </span><span class="cov0" title="0">{
                        if err := rows.Scan(
                                &amp;record.ID, &amp;record.SelectType, &amp;record.Table, &amp;record.Type, &amp;record.PossibleKeys,
                                &amp;record.Key, &amp;record.KeyLen, &amp;record.Ref, &amp;record.Rows, &amp;record.Filtered, &amp;record.Extra); err != nil </span><span class="cov0" title="0">{
                                log.MSKLog().Warnf("GenExplainRecordsFromRows(%v) failed %v", rows, err)
                                return records, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        // mysql 5.7,8.0+
                        if err := rows.Scan(
                                &amp;record.ID, &amp;record.SelectType, &amp;record.Table, &amp;record.Partitions, &amp;record.Type,
                                &amp;record.PossibleKeys, &amp;record.Key, &amp;record.KeyLen, &amp;record.Ref, &amp;record.Rows, &amp;record.Filtered, &amp;record.Extra); err != nil </span><span class="cov8" title="1">{
                                log.MSKLog().Warnf("GenExplainRecordsFromRows(%v) failed %v", rows, err)
                                return records, err
                        }</span>
                }

                <span class="cov8" title="1">records = append(records, *record)</span>
                //log.Printf("GenExplainRecords(%+v)", record)
        }
        <span class="cov8" title="1">return records, rows.Err()</span>
}

func MaxRowsFromExplainRecords(explainRecords []ExplainRecord) int <span class="cov8" title="1">{
        maxRows := 0
        for i := 0; i &lt; len(explainRecords); i++ </span><span class="cov8" title="1">{
                rowCnt, _ := strconv.Atoi(explainRecords[i].Rows.String)
                if maxRows &lt; rowCnt </span><span class="cov8" title="1">{
                        maxRows = rowCnt
                }</span>
        }
        <span class="cov8" title="1">return maxRows</span>
}

func isTableName(tn string) bool <span class="cov8" title="1">{

        if len(strings.TrimSpace(tn)) &lt;= 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        //返回匹配到的结果
        <span class="cov8" title="1">result := tableNameReg.FindStringSubmatch(tn)
        // log.Printf("isTableName(%v): result %v", tn, result)

        return len(result) &lt;= 0</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package policy

import (
        "context"
        "database/sql"
        "fmt"
        "gitlab.papegames.com/fringe/mskeeper/log"
        "gitlab.papegames.com/fringe/mskeeper/misc"
        "gitlab.papegames.com/fringe/mskeeper/sqlparser"
        "gitlab.papegames.com/fringe/mskeeper/sqlparser/dependency/sqltypes"
        // syslog "log"
        "time"
        // "math/big"
        // "reflect"
        "strconv"
        "strings"
)

/*

操作数长度检测策略，对应varchar，text，int等的长度检测。

背景：
通过 SELECT @@GLOBAL.sql_mode;命令，可以查询MySQL长度硬检测的开关是否打开。
如果包含"STRICT_TRANS_TABLES", 则数据过长是会即时返回错误。
本地的话，5.5没开，5.6、5.7以及8.0的都开了
可通过 set @@global.sql_mode=""; 来关闭严格检查。


调查了阿里云和腾讯云，

1. SDK的阿里云，都没开
2. 腾讯云，恋与的部分开了严格，部分又木有。
3. JAVA的JDBC貌似支持i，https://book.51cto.com/art/201008/219125.htm
4. MySQL各种数据类型的操作示例，https://www.cnblogs.com/qq631243523/p/9791393.html

*/

var (
        ErrFieldDataTruncated     = fmt.Errorf("Data truncated")
        ErrExprToSQLValueFail     = fmt.Errorf("Expr to sqlval failure")
        WarnFieldDataMayTruncated = fmt.Errorf("Data might be truncated in future")
        DataTruncationUplimit     = 0.8
)

const (
        NoTruncated   int = 0
        TruncatedWarn int = 1
        Truncated     int = 2
)

type ColumnMap map[string]*ColumnRecord

// func (cm ColumnMap) String() string {
//         str := "ColumnMap "
//         for k, v := range cm {
//                 str += fmt.Sprintf("(k:%v,v:%v) ", k, v)
//         }
//         return str
// }

type ColumnRecord struct {
        Field sql.NullString
        Type  sql.NullString
        // Key
        // Default
        // Extra
}

func NewColumnRecord() *ColumnRecord <span class="cov8" title="1">{
        return &amp;ColumnRecord{}
}</span>

func MakeColumnRecords(db *sql.DB, table string, timeout time.Duration) (map[string]*ColumnRecord, []ColumnRecord, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithCancel(context.Background())

        // 针对 mysql 5.7.x 版本在context方面的bug，workaround
        if notSupportContext </span><span class="cov8" title="1">{
                timeout = timeout * 100
        }</span>

        <span class="cov8" title="1">defer time.AfterFunc(timeout, cancel).Stop()
        // ctx, cancel := context.WithTimeout(context.Background(), timeout)
        // defer cancel()

        //        originQuery := query
        columnsMap := ColumnMap{}
        var columnRecords []ColumnRecord
        query := "show columns from " + table

        tx, err := db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                return columnsMap, columnRecords, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = safeRollback(fmt.Sprintf("MakeColumnRecords() query of %v rollback", query), tx)
        }</span>()

        <span class="cov8" title="1">rows, err := tx.QueryContext(ctx, query)
        if err != nil </span><span class="cov8" title="1">{
                return columnsMap, columnRecords, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        columnRecords, err = genColumnRecordsFromRows(rows)
        if err != nil </span><span class="cov8" title="1">{
                return columnsMap, columnRecords, err
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov8" title="1">{
                return columnsMap, columnRecords, err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(columnRecords); i++ </span><span class="cov8" title="1">{
                if columnRecords[i].Field.Valid </span><span class="cov8" title="1">{
                        columnsMap[columnRecords[i].Field.String] = &amp;columnRecords[i]
                }</span>
        }
        <span class="cov8" title="1">return columnsMap, columnRecords, nil</span>

}

// 计算一段SQL表达式的值，by select 语句
func calExprValue(db *sql.DB, timeout time.Duration, expr string, args ...interface{}) (*sqlparser.SQLVal, error) <span class="cov8" title="1">{
        //  InterfaceToValue
        //  ExprFromValue

        var sqlval *sqlparser.SQLVal
        ctx, cancel := context.WithCancel(context.Background())

        // 针对 mysql 5.7.x 版本在context方面的bug，workaround
        if notSupportContext </span><span class="cov8" title="1">{
                timeout = timeout * 100
        }</span>
        <span class="cov8" title="1">defer time.AfterFunc(timeout, cancel).Stop()

        query := "SELECT (" + expr + ")"
        tx, err := db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return sqlval, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = safeRollback(fmt.Sprintf("calExprValue() query of %v rollback", query), tx)
        }</span>()

        <span class="cov8" title="1">var dest interface{}
        err = tx.QueryRowContext(ctx, query, args...).Scan(&amp;dest)
        if err != nil </span><span class="cov8" title="1">{
                return sqlval, err
        }</span>
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return sqlval, err
        }</span>

        <span class="cov8" title="1">typeval, _ := sqltypes.InterfaceToValue(dest)
        parserExpr, _ := sqlparser.ExprFromValue(typeval)
        sv, ok := parserExpr.(*sqlparser.SQLVal)
        if !ok </span><span class="cov0" title="0">{
                return sqlval, ErrExprToSQLValueFail
        }</span>
        <span class="cov8" title="1">sqlval = sv
        log.MSKLog().Infof("calExprValue(%v, %v, %v, %v) got sqlval %v", db, timeout, expr, args, sqlval)
        return sqlval, nil</span>
}

func genColumnRecordsFromRows(rows *sql.Rows) ([]ColumnRecord, error) <span class="cov8" title="1">{
        records := make([]ColumnRecord, 0)

        for rows.Next() </span><span class="cov8" title="1">{
                record := NewColumnRecord()
                var noCare1, noCare2, noCare3, noCare4 sql.NullString
                if err := rows.Scan(
                        &amp;record.Field,
                        &amp;record.Type,
                        &amp;noCare1, &amp;noCare2, &amp;noCare3, &amp;noCare4); err != nil </span><span class="cov8" title="1">{
                        log.MSKLog().Warnf("genColumnRecordsFromRows(%v) failed %v", rows, err)
                        return records, err
                }</span>
                <span class="cov8" title="1">if !record.Field.Valid || !record.Type.Valid </span><span class="cov0" title="0">{
                        log.MSKLog().Warnf("genColumnRecordsFromRows(%v) invalid of record field %v", rows, record)
                        continue</span>
                }
                <span class="cov8" title="1">record.Field.String = strings.ToUpper(record.Field.String)
                records = append(records, *record)</span>
        }
        <span class="cov8" title="1">return records, rows.Err()</span>
}

type PolicyCheckerFieldsLength struct {
        uplimit float64
}

func NewPolicyCheckerFieldsLength(uplimits ...interface{}) *PolicyCheckerFieldsLength <span class="cov8" title="1">{

        uplimit := DataTruncationUplimit
        // Parse uplimit
        for i := 0; i &lt; len(uplimits); i++ </span><span class="cov8" title="1">{
                u, ok := uplimits[i].(float64)
                if ok &amp;&amp; u &lt; 1.000000001 </span><span class="cov8" title="1">{
                        uplimit = u
                        break</span>
                }
        }
        <span class="cov8" title="1">return &amp;PolicyCheckerFieldsLength{uplimit: uplimit}</span>
}

//    REF: https://dev.mysql.com/doc/refman/5.6/en/integer-types.html
//    MySQL Integer Type:
//    Type:            TINYINT(), SMALLINT,  MEDIUMINT,      INT,     BIGINT
//    Max:                255        65535    16777215  4294967295    2^64-1
//    Min(signed):       -128        -32768   -8388608  -2147483648   -2^63

//    MySQL type representation:
//    T(length) [unsigned]
//    T is in (tinyint, SMALLINT, MEDIUMINT, INT, BIGINT)
//    length is work when zerofill was set, none bussiness with it's value.
func calNumberOfBitsByFieldTypeInt(fieldType string) int <span class="cov8" title="1">{
        switch fieldType </span>{
        case msFieldTypeTiny:<span class="cov8" title="1">
                return 8</span>
        case msFieldTypeShort:<span class="cov8" title="1">
                return 16</span>
        case msFieldTypeInt24:<span class="cov8" title="1">
                return 24</span>
        case msFieldTypeLong:<span class="cov8" title="1">
                return 32</span>
        case msFieldTypeLongLong:<span class="cov8" title="1">
                return 64</span>
        // no ban no sure
        default:<span class="cov0" title="0">
                return 64</span>
        }
}

// 对于Update语句支持的三类table：AliasedTable, (AliasedTable) 和 (AliasedTable join AliasedTable)
// 只试图返回前两种， 暂时不支持join, eg. update test_policy join test on test_policy.value1 = test.value1 set test_policy.value = '123';
func getAliasedTableFromUpdateStmt(tb sqlparser.TableExpr) *sqlparser.AliasedTableExpr <span class="cov8" title="1">{

        aliaTable, ok := tb.(*sqlparser.AliasedTableExpr)
        if ok </span><span class="cov8" title="1">{
                return aliaTable
        }</span>

        <span class="cov8" title="1">pTable, ok := tb.(*sqlparser.ParenTableExpr)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        // TODO：暂时不支持 update (table1, table2)..., 只支持 update (table1), (table2)...
        <span class="cov8" title="1">if len(pTable.Exprs) &gt; 1 || len(pTable.Exprs) &lt; 1 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">aliaTable, ok = pTable.Exprs[0].(*sqlparser.AliasedTableExpr)
        if ok </span><span class="cov8" title="1">{
                return aliaTable
        }</span>

        <span class="cov8" title="1">pTable, ok = pTable.Exprs[0].(*sqlparser.ParenTableExpr)
        if ok </span><span class="cov8" title="1">{
                return getAliasedTableFromUpdateStmt(pTable)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

//    REF:https://dev.mysql.com/doc/refman/5.6/en/string-types.html
func calNumberOfBytesByFieldTypeValue(fieldType string, parenthesisLength int64) int64 <span class="cov8" title="1">{

        switch fieldType </span>{
        case msFieldTypeBinary:<span class="cov8" title="1">
                return parenthesisLength</span>
        case msFieldTypeVarBinary:<span class="cov8" title="1">
                return parenthesisLength</span>
        case msFieldTypeString:<span class="cov8" title="1">
                return parenthesisLength</span>
        case msFieldTypeVarString:<span class="cov8" title="1">
                return parenthesisLength</span>
        case msFieldTypeTinyBLOB, msFieldTypeTinyTEXT:<span class="cov8" title="1">
                return 255</span>
        case msFieldTypeBLOB, msFieldTypeTEXT:<span class="cov8" title="1">
                return 65535</span>
        case msFieldTypeMediumBLOB, msFieldTypeMediumTEXT:<span class="cov8" title="1">
                return 16777215</span>
        case msFieldTypeLongBLOB, msFieldTypeLongTEXT:<span class="cov8" title="1">
                return 4294967295</span>
        // no ban no sure
        default:<span class="cov8" title="1">
                return 4294967295</span>
        }
}

// Check if value was truncated by the definition of cr
// eg. value = 'abcdefg', cr.Type.String = varchar(5)  ==&gt; data in db: 'abcde' was truncated
func (pcri *PolicyCheckerFieldsLength) checkIfMySQLTruncate(cr *ColumnRecord, sqlV *sqlparser.SQLVal, value []byte) int <span class="cov8" title="1">{
        if sqlV == nil </span><span class="cov8" title="1">{
                log.MSKLog().Debugf("checkIfMySQLTruncate:Check(%v, %v, %v) nil of sqlV, possiblely FuncExpr",
                        cr, sqlV, value)
                return NoTruncated
        }</span>
        <span class="cov8" title="1">msFieldType := strings.Split(cr.Type.String, " ")
        var unsigned bool = false
        if len(msFieldType) &gt; 1 &amp;&amp; msFieldType[1] == "unsigned" </span><span class="cov8" title="1">{
                unsigned = true
        }</span>
        <span class="cov8" title="1">typeString := ""
        if strings.Index(msFieldType[0], "(") &gt; 0 </span><span class="cov8" title="1">{
                typeString = msFieldType[0][0:strings.Index(msFieldType[0], "(")]
        }</span> else<span class="cov8" title="1"> {
                typeString = msFieldType[0]
        }</span>
        <span class="cov8" title="1">typeLength := int64(0)

        if strings.Contains(msFieldType[0], "(") &amp;&amp; strings.Index(msFieldType[0], ")") &gt; strings.Index(msFieldType[0], "(") </span><span class="cov8" title="1">{
                typeLengthStr := msFieldType[0][strings.Index(msFieldType[0], "(")+1 : strings.Index(msFieldType[0], ")")]
                var err error
                typeLength, err = strconv.ParseInt(string(typeLengthStr), 0, 64)
                if err != nil </span><span class="cov8" title="1">{
                        log.MSKLog().Warnf("checkIfMySQLTruncate:Check(%v, %v, %v) strconv.ParseInt of (%v) failed with err %v",
                                cr, sqlV, value, typeLengthStr, err)
                        return NoTruncated
                }</span>
        }
        <span class="cov8" title="1">log.MSKLog().Debugf("~~~~~~~!!!!!column(%v): checkIfMySQLTruncate sqlV.Type %v typeString %v value %v", cr, sqlV.Type, typeString, string(value))
        var numOfBits int
        switch typeString </span>{
        case msFieldTypeYear:<span class="cov0" title="0"></span>
                // TODO
        case msFieldTypeTiny, msFieldTypeShort, msFieldTypeInt24,
                msFieldTypeLong, msFieldTypeLongLong:<span class="cov8" title="1">

                numOfBits = calNumberOfBitsByFieldTypeInt(typeString)
                var valueInSQL uint64
                if strings.Contains(string(value), "-") </span><span class="cov8" title="1">{
                        valueInSQLInt64, err := strconv.ParseInt(string(value), 0, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                err, _ := err.(*strconv.NumError)
                                if err.Err == strconv.ErrRange </span><span class="cov8" title="1">{
                                        log.MSKLog().Warnf("checkIfMySQLTruncate:Check(%v, %v, %v) strconv.ParseInt of %v failed with err %v",
                                                cr, sqlV, value, string(value), err)
                                        return Truncated
                                }</span> else<span class="cov8" title="1"> {
                                        log.MSKLog().Warnf("checkIfMySQLTruncate:Check(%v, %v, %v) strconv.ParseInt of %v failed with err %v",
                                                cr, sqlV, value, string(value), err)
                                        return NoTruncated
                                }</span>
                        }
                        <span class="cov8" title="1">valueInSQL = uint64(valueInSQLInt64)</span>
                } else<span class="cov8" title="1"> {
                        valueInSQLUnInt64, err := strconv.ParseUint(string(value), 0, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                err, _ := err.(*strconv.NumError)
                                if err.Err == strconv.ErrRange </span><span class="cov8" title="1">{
                                        log.MSKLog().Warnf("checkIfMySQLTruncate:Check(%v, %v, %v) strconv.ParseUint of %v failed with err %v",
                                                cr, sqlV, value, string(value), err)
                                        return Truncated
                                }</span> else<span class="cov8" title="1"> {
                                        log.MSKLog().Warnf("checkIfMySQLTruncate:Check(%v, %v, %v) strconv.ParseUint of %v failed with err %v",
                                                cr, sqlV, value, string(value), err)
                                        return NoTruncated
                                }</span>
                        }
                        <span class="cov8" title="1">valueInSQL = valueInSQLUnInt64</span>
                }

                <span class="cov8" title="1">log.MSKLog().Debugf("@@@@@@@@@@@@@@@@ valueInSQL %v string(value) %v unsigned %v numOfBits %v, unsigned %v",
                        valueInSQL, string(value), unsigned, numOfBits, unsigned)
                if unsigned </span><span class="cov8" title="1">{
                        targetVal, _ := strconv.ParseUint(string(value), 0, numOfBits)
                        if uint64(targetVal) != valueInSQL </span><span class="cov8" title="1">{
                                return Truncated
                        }</span>
                } else<span class="cov8" title="1"> {
                        targetVal, _ := strconv.ParseInt(string(value), 0, numOfBits)
                        if uint64(targetVal) != valueInSQL </span><span class="cov8" title="1">{
                                return Truncated
                        }</span>
                }
        case msFieldTypeFloat:<span class="cov0" title="0"></span>
        case msFieldTypeDouble:<span class="cov0" title="0"></span>
                // TODO
        case msFieldTypeBit:<span class="cov0" title="0"></span>
                // https://www.twle.cn/c/yufei/mysqlfav/mysqlfav-basic-bit.html
                // TODO
        case msFieldTypeDecimal, msFieldTypeEnum, msFieldTypeSet:<span class="cov0" title="0"></span>
                // TODO

        case msFieldTypeTinyBLOB, msFieldTypeMediumBLOB, msFieldTypeLongBLOB, msFieldTypeBLOB,
                msFieldTypeTinyTEXT, msFieldTypeMediumTEXT, msFieldTypeLongTEXT, msFieldTypeTEXT,
                msFieldTypeString, msFieldTypeJSON, msFieldTypeVarString,
                msFieldTypeBinary, msFieldTypeVarBinary, msFieldTypeGeometry:<span class="cov8" title="1">

                switch sqlV.Type </span>{
                case sqlparser.StrVal:<span class="cov8" title="1"></span>
                case sqlparser.IntVal, sqlparser.FloatVal, sqlparser.HexNum:<span class="cov8" title="1"></span>
                case sqlparser.HexVal:<span class="cov8" title="1">
                        var realVal []byte
                        n, err := fmt.Sscanf(string(value), "%x", &amp;realVal)
                        if err != nil || n != 1 </span><span class="cov8" title="1">{
                                log.MSKLog().Warnf("checkIfMySQLTruncate:Check(%v, %v, %v) fmt.Sscanf failed %v",
                                        cr, sqlV, value, err)
                                return NoTruncated
                        }</span>
                        <span class="cov8" title="1">value = realVal</span>
                case sqlparser.BitVal:<span class="cov8" title="1">
                        byteLen := len(value) / 8
                        if len(value)%8 &gt; 0 </span><span class="cov8" title="1">{
                                byteLen += 1
                        }</span>
                        <span class="cov8" title="1">value = make([]byte, byteLen)</span>
                case sqlparser.ValArg:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov8" title="1">dataTruncUplimit := pcri.uplimit
                targetValLen := calNumberOfBytesByFieldTypeValue(typeString, typeLength)
                log.MSKLog().Debugf("################### typeString %v, typeLength %v, targetValLen %v valueLen %v value %v",
                        typeString, typeLength, targetValLen, len(value), string(value))
                if int64(len(value)) &gt; targetValLen </span><span class="cov8" title="1">{
                        return Truncated
                }</span> else<span class="cov8" title="1"> if int64(len(value)) &gt; int64(float64(targetValLen)*dataTruncUplimit) </span><span class="cov8" title="1">{
                        return TruncatedWarn
                }</span>

        case msFieldTypeDate, msFieldTypeTimestamp, msFieldTypeDateTime, msFieldTypeTime:<span class="cov0" title="0"></span>
                // TODO
        case msFieldTypeNULL:<span class="cov0" title="0"></span>
                // TODO
        default:<span class="cov8" title="1">
                log.MSKLog().Warnf("checkIfMySQLTruncate:Check(%v, %v, %v) unknown typeString %v",
                        cr, sqlV, value, typeString)
                return NoTruncated</span>
        }

        <span class="cov8" title="1">return NoTruncated</span>
}

func (pcri *PolicyCheckerFieldsLength) checkValueLengthBy(columnSlice []string, valueSlice []*sqlparser.SQLVal,
        columnTypeValueMap ColumnMap, args interface{}, argsIdx *int) error <span class="cov8" title="1">{

        // argsIdx := 0
        argCnt := 0
        // assert
        argsSlice, ok := args.([]interface{})
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("checkValueLengthBy: args.([]interface{}) failed %v for it's Type %T ",
                        args, args)
        }</span>
        // syslog.Printf("args %v args %T args0 %v args0 %T", args, args, args0, args0)

        <span class="cov8" title="1">for i := 0; i &lt; len(valueSlice); i++ </span><span class="cov8" title="1">{
                sqlVal := valueSlice[i]
                if sqlVal != nil &amp;&amp; sqlVal.Type == sqlparser.ValArg </span><span class="cov8" title="1">{
                        argCnt++
                }</span>
        }
        // assert sth
        // argCnt 为Update的target的?个数，where及之后条件中的？不是本策略关注的重点
        <span class="cov8" title="1">if len(argsSlice) &lt; argCnt </span><span class="cov8" title="1">{
                return fmt.Errorf(
                        fmt.Sprintf("checkValueLengthBy: len(argsSlice) %v &lt; argCnt %v ",
                                len(argsSlice), argCnt))
        }</span>

        // assert sth
        <span class="cov8" title="1">if len(columnSlice) != len(valueSlice) </span><span class="cov8" title="1">{
                return fmt.Errorf("checkValueLengthBy: len(columnSlice) %v != len(valueSlice) %v ",
                        len(columnSlice), len(valueSlice))
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(columnSlice); i++ </span><span class="cov8" title="1">{
                columnRecord, ok := columnTypeValueMap[columnSlice[i]]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">sqlVal := valueSlice[i]
                var value []byte
                if sqlVal == nil </span>{<span class="cov8" title="1">
                        // *sqlparser.FuncExpr, such as now()
                }</span> else<span class="cov8" title="1"> if sqlVal.Type == sqlparser.ValArg </span><span class="cov8" title="1">{
                        value = []byte(fmt.Sprintf("%v", argsSlice[*argsIdx]))
                        *argsIdx++
                }</span> else<span class="cov8" title="1"> {
                        value = sqlVal.Val
                }</span>

                <span class="cov8" title="1">truncated := pcri.checkIfMySQLTruncate(columnRecord, sqlVal, value)
                if truncated == Truncated </span><span class="cov8" title="1">{
                        return ErrFieldDataTruncated
                }</span> else<span class="cov8" title="1"> if truncated == TruncatedWarn </span><span class="cov8" title="1">{
                        return WarnFieldDataMayTruncated
                }</span>
                // syslog.Printf("~~~~checkValueLengthBy argsSlice[argsIdx] %v argsSlice[argsIdx]  %T reflect.Type(argsSlice[argsIdx]) %v",
                //         argsSlice[argsIdx], argsSlice[argsIdx], reflect.TypeOf(argsSlice[argsIdx]))
        }

        <span class="cov8" title="1">return nil</span>
}

func (pcri *PolicyCheckerFieldsLength) Check(db *sql.DB, explainRecords []ExplainRecord, query string, args []interface{}) error <span class="cov8" title="1">{
        log.MSKLog().Infof("PolicyCheckerFieldsLength:Check(%v, %v, %v) with %v", explainRecords, query, args, pcri)

        stmt, err := sqlparser.Parse(query)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Warnf("PolicyCheckerFieldsLength:Check(%v, %v, %v) sqlparser.Parse failed with err %v",
                        explainRecords, query, args, err)
                return nil
        }</span>
        <span class="cov8" title="1">switch stmt := stmt.(type) </span>{
        case *sqlparser.Insert:<span class="cov8" title="1">
                insertStruct := stmt
                tableNameString := insertStruct.Table.Name.String()

                columnTypeMap, columnNameSlices, err := MakeColumnRecords(db, tableNameString, MaxTimeoutOfExplain)
                if err != nil </span><span class="cov8" title="1">{
                        log.MSKLog().Warnf("PolicyCheckerFieldsLength:Check(%v, %v, %v) MakeColumnRecords of %v failed",
                                explainRecords, query, args, tableNameString)
                        break</span>
                }
                <span class="cov8" title="1">log.MSKLog().Debugf("insertStruct %v columnTypeMap %v", insertStruct, len(columnTypeMap))
                columnSlice := []string{}
                for _, column := range insertStruct.Columns </span><span class="cov8" title="1">{
                        columnName := column.CompliantName()
                        columnSlice = append(columnSlice, strings.ToUpper(columnName))

                        log.MSKLog().Debugf("tableName %v column %T column %v CompliantName %v",
                                tableNameString, column, column, column)
                }</span>
                // For case of no explicit fields declared, eg. Insert TableName values ....
                <span class="cov8" title="1">if len(columnSlice) &lt;= 0 </span><span class="cov8" title="1">{
                        for i := 0; i &lt; len(columnNameSlices); i++ </span><span class="cov8" title="1">{
                                fieldName := columnNameSlices[i].Field.String
                                columnSlice = append(columnSlice, fieldName)
                        }</span>
                }

                <span class="cov8" title="1">insertValues, ok := insertStruct.Rows.(sqlparser.Values)
                if !ok </span><span class="cov8" title="1">{
                        log.MSKLog().Infof("PolicyCheckerFieldsLength:Check(%v, %v, %v) insertStruct.Rows %T failed cast into sqlparser.Values",
                                explainRecords, query, args, insertStruct.Rows)
                        break</span>
                }
                <span class="cov8" title="1">var argIdx int = 0
                for _, rowValues := range insertValues </span><span class="cov8" title="1">{
                        valueSlice := []*sqlparser.SQLVal{}
                        for _, columnValue := range rowValues </span><span class="cov8" title="1">{

                                insertValueColumn, ok := columnValue.(*sqlparser.SQLVal)
                                if ok </span><span class="cov8" title="1">{
                                        valueSlice = append(valueSlice, insertValueColumn)
                                }</span> else<span class="cov8" title="1"> {
                                        valueSlice = append(valueSlice, nil)
                                }</span>
                        }

                        <span class="cov8" title="1">err = pcri.checkValueLengthBy(columnSlice, valueSlice, columnTypeMap, args, &amp;argIdx)
                        if err != nil </span><span class="cov8" title="1">{
                                if err == WarnFieldDataMayTruncated </span><span class="cov8" title="1">{
                                        return NewPolicyError(WarnPolicyCodeDataTruncate, fmt.Sprintf("Possible data fields near the edge of overflow on table %v with err %v",
                                                tableNameString, err))
                                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                                        return NewPolicyError(ErrPolicyCodeDataTruncate, fmt.Sprintf("Possible data fields overflow on table %v with err %v",
                                                tableNameString, err))
                                }</span>
                        }
                }

        case *sqlparser.Update:<span class="cov8" title="1">
                updateStruct := stmt

                for _, table := range updateStruct.TableExprs </span><span class="cov8" title="1">{

                        aliaTable := getAliasedTableFromUpdateStmt(table)
                        if aliaTable == nil </span><span class="cov8" title="1">{
                                log.MSKLog().Warnf("PolicyCheckerFieldsLength:Check(%v, %v, %v) table %T failed cast into sqlparser.AliasedTableExpr",
                                        explainRecords, query, args, table)
                                break</span>
                        }

                        <span class="cov8" title="1">tableName := sqlparser.GetTableName(aliaTable.Expr)
                        tableNameString := tableName.String()
                        columnTypeMap, _, err := MakeColumnRecords(db, tableNameString, MaxTimeoutOfExplain)
                        if err != nil </span><span class="cov8" title="1">{
                                log.MSKLog().Warnf("PolicyCheckerFieldsLength:Check(%v, %v, %v) MakeColumnRecords of %v failed",
                                        explainRecords, query, args, tableNameString)
                                break</span>
                        }

                        <span class="cov8" title="1">var argFilteredIdx int = 0
                        valueSlice := []*sqlparser.SQLVal{}
                        columnSlice := []string{}
                        var argsPrev int = 0
                        var argsFilterd []interface{}
                        for _, expr := range updateStruct.Exprs </span><span class="cov8" title="1">{
                                columnName := expr.Name
                                var updateExpr *sqlparser.SQLVal
                                var ok bool
                                switch expr.Expr.(type) </span>{
                                case *sqlparser.SQLVal:<span class="cov8" title="1">
                                        updateExpr, ok = expr.Expr.(*sqlparser.SQLVal)
                                        if updateExpr.Type == sqlparser.ValArg </span><span class="cov8" title="1">{
                                                if argFilteredIdx &gt;= len(args) </span><span class="cov8" title="1">{
                                                        log.MSKLog().Warnf("PolicyCheckerFieldsLength:Check(%v, %v, %v) mismatch of number of valArg with argFilteredIdx %v &gt;= len(args) %v",
                                                                explainRecords, query, args, argFilteredIdx, len(args))
                                                        ok = false
                                                        break</span>
                                                }
                                                <span class="cov8" title="1">argsFilterd = append(argsFilterd, args[argFilteredIdx])
                                                argFilteredIdx++</span>
                                        }
                                // Complex expression instead of single SQLVal
                                default:<span class="cov8" title="1">
                                        // Firstly, calculate the expression by select statement
                                        buf := sqlparser.NewTrackedBuffer(nil)
                                        expr.Expr.Format(buf)

                                        // 统计之前的？的个数，选择相应的args
                                        strWithQues := misc.ReplaceColonMark(buf.String())
                                        ac := misc.CountQuestionMark(strWithQues)
                                        if argsPrev+ac &gt; len(args) </span><span class="cov8" title="1">{
                                                log.MSKLog().Warnf("PolicyCheckerFieldsLength:Check(%v, %v, %v) mismatch of number of valArg in %v",
                                                        explainRecords, query, args, strWithQues)
                                                ok = false
                                                break</span>
                                        }
                                        <span class="cov8" title="1">updateExpr, err = calExprValue(db, MaxTimeoutOfExplain, strWithQues, args[argsPrev:argsPrev+ac]...)
                                        if err != nil </span><span class="cov8" title="1">{
                                                log.MSKLog().Warnf("PolicyCheckerFieldsLength:Check(%v, %v, %v) expr.Expr %T failed(%v) cast into SQLVal",
                                                        explainRecords, query, args, expr.Expr, err)
                                                ok = false
                                                break</span>
                                        }
                                        <span class="cov8" title="1">ok = true
                                        argsPrev += ac
                                        argFilteredIdx += ac</span>
                                }
                                <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                                        break</span>
                                }

                                <span class="cov8" title="1">valueSlice = append(valueSlice, updateExpr)
                                columnSlice = append(columnSlice, strings.ToUpper(columnName.Name.String()))
                                log.MSKLog().Debugf("tableNameString %T tableNameString %v columnName %v updateExpr %T updateExpr.Type %v",
                                        tableNameString, tableNameString, columnName.Name.String(), updateExpr, updateExpr.Type)</span>
                        }
                        <span class="cov8" title="1">var argIdx int
                        err = pcri.checkValueLengthBy(columnSlice, valueSlice, columnTypeMap, argsFilterd, &amp;argIdx)
                        if err == WarnFieldDataMayTruncated </span><span class="cov8" title="1">{
                                return NewPolicyError(WarnPolicyCodeDataTruncate, fmt.Sprintf("Possible data fields near the edge of overflow on table %v with err %v",
                                        tableNameString, err))
                        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                                return NewPolicyError(ErrPolicyCodeDataTruncate, fmt.Sprintf("Possible data fields overflow on table %v with err %v",
                                        tableNameString, err))
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package policy

import (
        "database/sql"
        // "database/sql/driver"
        "fmt"
        "gitlab.papegames.com/fringe/mskeeper/log"
        // syslog "log"
        "strings"
)

const (
        DefaultMaxLinesForTypeALL          = 1000 // 1. 1000行以下且没有使用where的全表扫描是安全的，针对配置表
        DefaultMaxLinesForTypeALLWithWhere = 100  // 2. 100行以下，使用了where是安全的

        ExtraKeyWordsUsingWhere = "USING WHERE"
)

// 操作数的类型检查，通过SELECT_TYPE = ALL的方式

type PolicyCheckerFieldsType struct {
}

func NewPolicyCheckerFieldsType() *PolicyCheckerFieldsType <span class="cov8" title="1">{

        return &amp;PolicyCheckerFieldsType{}
}</span>

func (pcri *PolicyCheckerFieldsType) Check(db *sql.DB, explainRecords []ExplainRecord, query string, args []interface{}) error <span class="cov8" title="1">{
        log.MSKLog().Infof("PolicyCheckerFieldsType:Check(%v, %v, %v) with %v", explainRecords, query, args, pcri)

        for i := 0; i &lt; len(explainRecords); i++ </span><span class="cov8" title="1">{
                var rowsAffected int
                var err error
                // syslog.Printf("[DEBUG] +++++ explainRecords[i] %v", explainRecords[i])
                if rowsAffected, err = explainRecords[i].GetExplainRealRows(); err != nil </span><span class="cov8" title="1">{
                        // syslog.Printf("[DEBUG] +++++ explainRecords[i].Rows %v query %v", rowsAffected, query)
                        continue</span>
                }
                <span class="cov8" title="1">rowCnt := rowsAffected

                // syslog.Printf("[DEBUG] +++++ explainRecords[i] %v", explainRecords[i])
                if strings.ToUpper(explainRecords[i].Type.String) == "ALL" </span><span class="cov8" title="1">{

                        if !explainRecords[i].Extra.Valid </span><span class="cov8" title="1">{
                                // 没有使用where语句,Extra "Using where"，则需要排除类似于配置表(1000行以下)
                                if rowCnt &gt; DefaultMaxLinesForTypeALL </span><span class="cov8" title="1">{
                                        return NewPolicyError(ErrPolicyCodeAllTableScan, fmt.Sprintf("Possbile all table scaned on table %v extra %v pkey %v key %v with rows %v",
                                                explainRecords[i].Table, explainRecords[i].Extra, explainRecords[i].PossibleKeys, explainRecords[i].Key, explainRecords[i].Rows))
                                }</span> else<span class="cov8" title="1"> {
                                        log.MSKLog().Infof("PolicyCheckerFieldsType:Check rowcnt%v &lt;= DefaultMaxLinesForTypeALL%v for all table scan, skipped",
                                                rowCnt, DefaultMaxLinesForTypeALL)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // using where, but still has full table scans
                                if rowCnt &gt; DefaultMaxLinesForTypeALLWithWhere </span><span class="cov8" title="1">{
                                        if strings.Contains(strings.ToUpper(explainRecords[i].Extra.String), ExtraKeyWordsUsingWhere) </span><span class="cov8" title="1">{
                                                return NewPolicyError(ErrPolicyCodeAllTableScan, fmt.Sprintf("Possbile all table scaned on table %v extra %v pkey %v key %v with rows %v",
                                                        explainRecords[i].Table, explainRecords[i].Extra, explainRecords[i].PossibleKeys, explainRecords[i].Key, explainRecords[i].Rows))
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        log.MSKLog().Infof("PolicyCheckerFieldsType:Check rowcnt%v &lt;= DefaultMaxLinesForTypeALLWithWhere%v for all table scan with where, skipped",
                                                rowCnt, DefaultMaxLinesForTypeALLWithWhere)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package policy

import (
        "database/sql"
        // "database/sql/driver"
        "fmt"
        "gitlab.papegames.com/fringe/mskeeper/log"
)

// 操作影响的行数 &gt; 1w
/*
        Mark for 0806
        SELECT 1 FROM redeem_consume WHERE clientid = '1008' and binary redeem = 'nAfewAA8ufddsAaBD'
*/

type PolicyCheckerRowsAbsolute struct {
        maxRowsAcceptable int
}

func NewPolicyCheckerRowsAbsolute(mra int) *PolicyCheckerRowsAbsolute <span class="cov8" title="1">{

        return &amp;PolicyCheckerRowsAbsolute{maxRowsAcceptable: mra}
}</span>

func (pcri *PolicyCheckerRowsAbsolute) Check(db *sql.DB, explainRecords []ExplainRecord, query string, args []interface{}) error <span class="cov8" title="1">{

        log.MSKLog().Infof("PolicyCheckerRowsAbsolute:Check(%v, %v, %v) with %v", explainRecords, query, args, pcri)
        for i := 0; i &lt; len(explainRecords); i++ </span><span class="cov8" title="1">{
                var rowsAffected int
                var err error

                // log.MSKLog().Warnf("PolicyCheckerRowsAbsolute explainRecords[i] %v = %v", i, explainRecords[i])
                if rowsAffected, err = explainRecords[i].GetExplainRealRows(); err != nil </span><span class="cov8" title="1">{
                        // log.Printf("[DEBUG] +++++ explainRecords[i].Rows %v query %v", rowsAffected, query)
                        continue</span>
                }
                <span class="cov8" title="1">rowCnt := rowsAffected
                if rowCnt &gt; pcri.maxRowsAcceptable </span><span class="cov8" title="1">{
                        return NewPolicyError(ErrPolicyCodeRowsAbs, fmt.Sprintf("Too many rows affected absolutely: rowcnt %v &gt; pcri.maxRowsAcceptable %v",
                                rowCnt, pcri.maxRowsAcceptable))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package policy

import (
        "database/sql"
        // "database/sql/driver"
        "fmt"
        "gitlab.papegames.com/fringe/mskeeper/log"
)

const DefaultRowsRate float32 = float32(0.3)
const RowsSafeLine int = 1000

// 操作影响的行数 &gt; 1/3 总行数（count(1)) &amp;&amp; 操作影响的行数 &gt; 1000
type PolicyCheckerRowsInvolved struct {
        rate float32
}

func NewPolicyCheckerRowsInvolved() *PolicyCheckerRowsInvolved <span class="cov8" title="1">{

        return &amp;PolicyCheckerRowsInvolved{rate: DefaultRowsRate}
}</span>

func (pcri *PolicyCheckerRowsInvolved) Check(db *sql.DB, explainRecords []ExplainRecord, query string, args []interface{}) error <span class="cov8" title="1">{

        log.MSKLog().Infof("PolicyCheckerRowsInvolved:Check(%v, %v, %v) with %v", explainRecords, query, args, pcri)
        for i := 0; i &lt; len(explainRecords); i++ </span><span class="cov8" title="1">{
                // log.Printf("[DEBUG] ----- explainRecords[i].Rows %v query %v", explainRecords[i].Rows, query)
                var rowsAffected int
                var err error
                if rowsAffected, err = explainRecords[i].GetExplainRealRows(); err != nil </span><span class="cov8" title="1">{
                        // log.Printf("[DEBUG] +++++ explainRecords[i].Rows %v query %v", rowsAffected, query)
                        continue</span>
                }
                <span class="cov8" title="1">rowCnt := rowsAffected
                if !isTableName(explainRecords[i].Table.String) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">subTableCountQuery := "select count(1) from " + explainRecords[i].Table.String
                subExplainRecords, err := MakeExplainRecords(db, subTableCountQuery, MaxTimeoutOfExplain, []interface{}{})
                if err != nil </span><span class="cov0" title="0">{
                        // 没有行数的直接跳过，包括了
                        // log.Printf("[DEBUG] +++++ continue explainRecords[i].Rows %v query %v", rowsAffected, query)
                        continue</span>
                }

                <span class="cov8" title="1">maxRows := MaxRowsFromExplainRecords(subExplainRecords)
                // log.Printf("[DEBUG] +++++ explainRecords[i].Rows %v query %v maxRows %v rowsAffected %v", rowCnt, query, maxRows, rowsAffected)
                if rowCnt &gt; int(float32(maxRows)*pcri.rate) &amp;&amp;
                        rowCnt &gt; RowsSafeLine </span><span class="cov8" title="1">{
                        return NewPolicyError(ErrPolicyCodeRowsInvolve, fmt.Sprintf("Too many rows will involve by target sql: rowcnt %v &gt; maxrows %v * pcri.rate %v",
                                rowCnt, maxRows, pcri.rate))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package httpsvr

import (
        "encoding/json"
        "github.com/gin-gonic/gin"
        "gitlab.papegames.com/fringe/mskeeper/log"
        "gitlab.papegames.com/fringe/mskeeper/server/service"
        // syslog "log"
        "fmt"
        "net/http"
        "strconv"
        "time"
)

type GinWrapper func(*gin.Context, http.ResponseWriter, *http.Request)

// type HTTPWrapperGin struct {
//         handle http.HandlerFunc
// }

// func NewHTTPWrapperGin(handle http.HandlerFunc) *HTTPWrapperGin {
//         return &amp;HTTPWrapperGin{handle: handle}
// }

// func (httpwg *HTTPWrapperGin) HandleFunc(c *gin.Context) {
//         httpwg.handle(c.Writer, c.Request)
// }
func NewHTTPWrapperGin(handle http.HandlerFunc) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                handle(c.Writer, c.Request)
        }</span>
}

// @Title 初始化mskeeper的会话
// @Description 通过dsn初始化mskeeper实例, dsn规则 https://www.cnblogs.com/diegodu/p/5586861.html
// @Produce json
// @Accept x-www-form-urlencoded
// @Param dsn formData string true "mysql dsn, eg. mskeeper_test:123456@tcp(192.168.0.86:3306)/mskeepertest?timeout=30s"
// @Param timeout formData float64 false "DB连接的超时时间, 单位:micros, defautyl 5s"
// @Success 200 {object} RetData
// @Router /mysql/init [post]
func MySQLInitHandlerS(c *gin.Context) <span class="cov8" title="1">{
        ret := NewRet()
        defer c.JSON(http.StatusOK, ret)

        timeoutstr := c.Request.FormValue("timeout")
        dsn := c.Request.FormValue("dsn") // mysql driver的dsn，用于生成UUID以及打开数据库
        if dsn == "" </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLInitHandlerS(%v): failed to parse dsn %v",
                        dsn, dsn)
                ret.Error(RetErrArgs, service.Tr(service.GetLanguage(c.Request), "dsn_empty"))
                return
        }</span>

        <span class="cov8" title="1">timeout, _ := strconv.ParseFloat(timeoutstr, 64)
        sess, err := service.NewMySQLService(dsn)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLInitHandlerS(%v): failed(%v) to init MySQL Service",
                        dsn, err)
                ret.Error(RetErrFailToInitService, err.Error())
                return
        }</span>

        <span class="cov8" title="1">requestDB := service.ServicePingDBRequest{Timeout: timeout}
        responseDB := &amp;service.ServicePingDBResponse{Request: requestDB}
        err = sess.PingDB(requestDB, responseDB)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLInitHandlerS(%v): failed(%v) to ping MySQL instance",
                        dsn, err)
                ret.Error(RetErrPingFailure, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ret.SetData("msid", sess.GetUUID())</span>
}

// @Title 检测SQL的安全性
// @Description check sql through mskeeper
// @Produce json
// @Accept x-www-form-urlencoded
// @Param msid formData string true "Init API返回的MSID"
// @Param sql formData string true "执行的SQL"
// @Param args formData string false "SQL执行的参数，eg. [1,2,'333',4.44]"
// @Param timeout formData float64 false "DB连接的超时时间, 单位:micros, defautyl 5s"
// @Success 200 {object} RetData
// @Router /mysql/check [post]
func MySQLCheckHandlerS(c *gin.Context) <span class="cov8" title="1">{
        ret := NewRet()
        defer c.JSON(http.StatusOK, ret)

        msid := c.Request.FormValue("msid")
        sql := c.Request.FormValue("sql")
        argstr := c.Request.FormValue("args")
        timeoutstr := c.Request.FormValue("timeout")

        var args []interface{}
        if argstr != "" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(argstr), &amp;args)
                if err != nil </span><span class="cov8" title="1">{
                        log.MSKLog().Errorf("MySQLCheckHandlerS(%v, %v, %v): failed(%v) parse args %v",
                                msid, sql, argstr, err, argstr)
                        ret.Error(RetErrArgs, err.Error())
                        return
                }</span>
        }
        <span class="cov8" title="1">timeout, _ := strconv.ParseFloat(timeoutstr, 64)

        sess, err := service.GetMSKSession(msid)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLCheckHandlerS(%v, %v, %v): failed(%v) to fetch MySQL Service",
                        msid, sql, argstr, err)
                ret.Error(RetErrFailToGetService, err.Error())
                return
        }</span>

        // 由于CheckSQL本身不检查DB的连通性，就是即使SQL有问题但是DB不同，结果也是SafeSQL
        // 因而为了提高体验，增加了PingDB以区别SafeSQL和DB Fail这两种情况
        <span class="cov8" title="1">requestDB := service.ServicePingDBRequest{Timeout: timeout}
        responseDB := &amp;service.ServicePingDBResponse{Request: requestDB}
        err = sess.PingDB(requestDB, responseDB)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLCheckHandlerS(%v, %v, %v): failed(%v) to connect DB",
                        msid, sql, argstr, err)
                ret.Error(RetErrPingFailure, err.Error())
                return
        }</span>

        <span class="cov8" title="1">request := service.ServiceCheckSQLRequest{SQL: sql, MSID: msid, Args: args}
        response := &amp;service.ServiceCheckSQLResponse{Request: request}
        err = sess.CheckSQL(request, response)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLCheckHandlerS(%v, %v, %v): failed(%v) check sql",
                        msid, sql, argstr, err)
                ret.Error(RetErrCheckFailure, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ret.SetData("request", response.Request)
        ret.SetData("notifies", response.Notifies)</span>
}

// @Title 在给定的dsn上跑SQL
// @Description run the sql by dsn passed by /v1/mysql/init
// @Produce json
// @Accept x-www-form-urlencoded
// @Param msid formData string true "Init API返回的MSID"
// @Param sql formData string true "执行的SQL"
// @Param duration formData int false "SQL执行时间的告警上限，单位：microsec"
// @Param args formData string false "SQL执行的参数，eg. [1,2,'333',4.44]"
// @Param timeout formData int false "DB连接的超时时间, 单位:micros, defautyl 5s"
// @Success 200 {object} RetData
// @Router /mysql/run [post]
func MySQLRunHandlerS(c *gin.Context) <span class="cov8" title="1">{
        ret := NewRet()
        defer c.JSON(http.StatusOK, ret)
        stime := time.Now()

        msid := c.Request.FormValue("msid")
        sql := c.Request.FormValue("sql")
        durastr := c.Request.FormValue("duration")
        argstr := c.Request.FormValue("args")
        timeoutstr := c.Request.FormValue("timeout")

        var args []interface{}
        if argstr != "" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(argstr), &amp;args)
                if err != nil </span><span class="cov8" title="1">{
                        log.MSKLog().Errorf("MySQLCheckHandlerS(%v, %v, %v, %v): failed(%v) parse args %v",
                                msid, sql, durastr, argstr, err, argstr)
                        ret.Error(RetErrArgs, err.Error())
                        return
                }</span>
        }

        <span class="cov8" title="1">var dura int64
        if durastr != "" </span><span class="cov8" title="1">{
                dura, _ = strconv.ParseInt(durastr, 10, 64)
        }</span>

        <span class="cov8" title="1">timeout, _ := strconv.ParseFloat(timeoutstr, 64)

        sess, err := service.GetMSKSession(msid)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLRunHandlerS(%v, %v, %v, %v): failed(%v) to fetch MySQL Service",
                        msid, sql, durastr, argstr, err)
                ret.Error(RetErrFailToGetService, err.Error())
                return
        }</span>

        <span class="cov8" title="1">request := service.ServiceRunSQLRequest{SQL: sql, MSID: msid, Duration: dura, Args: args, Timeout: timeout}
        response := &amp;service.ServiceRunSQLResponse{Request: request}
        err = sess.RunSQL(request, response)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLRunHandlerS(%v, %v, %v, %v): failed(%v) run sql",
                        msid, sql, durastr, argstr, err)
                ret.Error(RetErrRunFailure, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ret.SetData("request", response.Request)
        ret.SetData("notifies", response.Notifies)
        ret.SetData("results", response.Result)
        ret.SetData("taking", fmt.Sprintf("%.1fms", time.Since(stime).Seconds()*1000))</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package httpsvr

import (
        "bytes"
        "net"
)

//ipRange - a structure that holds the start and end of a range of ip addresses
type ipRange struct {
        start net.IP
        end   net.IP
}

// inRange - check to see if a given ip address is within a range given
func inRange(r ipRange, ipAddress net.IP) bool <span class="cov8" title="1">{
        // strcmp type byte comparison
        if bytes.Compare(ipAddress, r.start) &gt;= 0 &amp;&amp; bytes.Compare(ipAddress, r.end) &lt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

var privateRanges = []ipRange{
        {
                start: net.ParseIP("10.0.0.0"),
                end:   net.ParseIP("10.255.255.255"),
        },
        {
                start: net.ParseIP("100.64.0.0"),
                end:   net.ParseIP("100.127.255.255"),
        },
        {
                start: net.ParseIP("172.16.0.0"),
                end:   net.ParseIP("172.31.255.255"),
        },
        {
                start: net.ParseIP("192.0.0.0"),
                end:   net.ParseIP("192.0.0.255"),
        },
        {
                start: net.ParseIP("192.168.0.0"),
                end:   net.ParseIP("192.168.255.255"),
        },
        {
                start: net.ParseIP("198.18.0.0"),
                end:   net.ParseIP("198.19.255.255"),
        },
}

// isPrivateSubnet - check to see if this ip is in a private subnet
func isPrivateSubnet(ipAddress net.IP) bool <span class="cov8" title="1">{
        // my use case is only concerned with ipv4 atm
        if ipCheck := ipAddress.To4(); ipCheck != nil </span><span class="cov8" title="1">{
                // iterate over all our ranges
                for _, r := range privateRanges </span><span class="cov8" title="1">{
                        // check if this ip is in a private range
                        if inRange(r, ipAddress) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package httpsvr

import (
        "github.com/gin-gonic/gin"
        "github.com/swaggo/gin-swagger"
        "github.com/swaggo/gin-swagger/swaggerFiles"
        _ "gitlab.papegames.com/fringe/mskeeper/server/docs"
        "net/http"
        "net/http/pprof"
)

// 注册 HTTPS handler
func RegisterHTTPSHandler() *gin.Engine <span class="cov8" title="1">{

        gin.SetMode(gin.ReleaseMode)

        router := gin.Default()

        debug := router.Group("/debug")
        </span><span class="cov8" title="1">{
                debug.GET("/pprof", NewHTTPWrapperGin(pprof.Index))
        }</span>

        <span class="cov8" title="1">v1 := router.Group("/v1")
        </span><span class="cov8" title="1">{
                v1.POST("/mysql/init", MySQLInitHandlerS)
                v1.POST("/mysql/check", MySQLCheckHandlerS)
                v1.POST("/mysql/run", MySQLRunHandlerS)
        }</span>

        // 文档界面访问URL
        <span class="cov8" title="1">router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        router.GET("/", func(c *gin.Context) </span><span class="cov8" title="1">{
                // 指定重定向的URL 通过HandleContext进行重定向到test2 页面显示json数据
                c.Redirect(http.StatusMovedPermanently, "/swagger/index.html")
        }</span>)

        <span class="cov8" title="1">return router</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package httpsvr

import (
        "time"
)

const (
        RetSuccess = 0

        RetErrCommon            = 1000 // 通用错误
        RetErrServerTimeout     = 1001 // 服务器处理超时（一般会处理完成、必要情况下需要rollback处理）
        RetErrFailToInitService = 1002 // mskeeper服务初始化失败
        RetErrFailToGetService  = 1003 // mskeeper服务获取失败
        RetErrCheckFailure      = 1004 // sql检测异常
        RetErrArgs              = 1005 // 参数错误
        RetErrRunFailure        = 1006 // sql运行失败
        RetErrPingFailure       = 1007 // 数据库连接异常
)

type RetModel map[string]interface{}

type RetData struct {
        Data RetModel `json:"data,omitempty"`
        Ret  uint32   `json:"ret"`
        Msg  string   `json:"msg,omitempty"`
        Time int64    `json:"time"`
}

func NewRet() *RetData <span class="cov8" title="1">{
        return &amp;RetData{
                Ret:  RetSuccess,
                Time: time.Now().Unix(),
                Data: make(RetModel),
        }
}</span>

func (r *RetData) SetData(key string, value interface{}) <span class="cov8" title="1">{
        r.Data[key] = value
}</span>

func (r *RetData) Error(ret uint32, msg string) <span class="cov8" title="1">{
        r.Ret = ret
        r.Msg = msg
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package service

import (
        "encoding/json"
        "errors"
        "io/ioutil"
        "net/http"
        "path/filepath"
        "strings"
)

// Translation - localization structure
type translation struct {
        locales      []string
        translations map[string]map[string]string
}

var trans *translation

// initLocales - initiate locales from the folder
func initLocales(trPath string) error <span class="cov8" title="1">{
        trans = &amp;translation{translations: make(map[string]map[string]string)}
        return loadTranslations(trPath)
}</span>

// Tr - translate for current locale
func Tr(locale string, trKey string) string <span class="cov8" title="1">{
        trValue, ok := trans.translations[locale][trKey]
        if ok </span><span class="cov8" title="1">{
                return trValue
        }</span>
        <span class="cov8" title="1">trValue, ok = trans.translations["en"][trKey]
        if ok </span><span class="cov8" title="1">{
                return trValue
        }</span>
        <span class="cov8" title="1">return trKey</span>
}

// GetLanguage - get language, which is in force
func GetLanguage(r *http.Request) string <span class="cov8" title="1">{

        langLower := r.FormValue("lang")
        langUpper := r.FormValue("LANG")

        if langLower != "" </span><span class="cov8" title="1">{
                return langLower
        }</span> else<span class="cov8" title="1"> if langUpper != "" </span><span class="cov8" title="1">{
                return langUpper
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// LoadTranslations - load translations files from the folder
func loadTranslations(trPath string) error <span class="cov8" title="1">{
        files, err := filepath.Glob(trPath + "/*.json")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(files) == 0 </span><span class="cov8" title="1">{
                return errors.New("No translations found")
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                err := loadFileToMap(file)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func loadFileToMap(filename string) error <span class="cov8" title="1">{
        var objmap map[string]string

        localName := strings.Replace(filepath.Base(filename), ".json", "", 1)

        content, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(content, &amp;objmap)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">trans.translations[localName] = objmap
        trans.locales = append(trans.locales, localName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package service

import (
        "database/sql"
        "fmt"
        uuid "github.com/satori/go.uuid"
        mskdriver "gitlab.papegames.com/fringe/mskeeper/driver"
        "gitlab.papegames.com/fringe/mskeeper/log"
        "gitlab.papegames.com/fringe/mskeeper/misc"
        "gitlab.papegames.com/fringe/mskeeper/mysql"
        "gitlab.papegames.com/fringe/mskeeper/notifier"
        "gitlab.papegames.com/fringe/mskeeper/options"
        "gitlab.papegames.com/fringe/mskeeper/policy"
        "gitlab.papegames.com/fringe/mskeeper/sqlparser"
        // syslog "log"
        "context"
        "os"
        "reflect"
        "time"
)

const (
        MaxConnForEachDSN = 2 // 每个dns对应的最大DB链接数
)

type MySQLService struct {
        msk  *mskdriver.MSKeeper
        msid string
}

func (msqls *MySQLService) GetMSKeeper() *mskdriver.MSKeeper <span class="cov8" title="1">{
        return msqls.msk
}</span>

func NewMySQLService(dsn string) (*MySQLService, error) <span class="cov8" title="1">{
        msid := uuid.NewV3(uuid.UUID{}, misc.MD5String(dsn)).String()

        sess, err := GetMSKSession(msid)
        if err == nil &amp;&amp; sess.(*MySQLService) != nil </span><span class="cov8" title="1">{
                return sess.(*MySQLService), nil
        }</span>

        <span class="cov8" title="1">msservice := &amp;MySQLService{msid: msid}
        // Verify the dsn and register the driver
        db, err := sql.Open("mskeeper", dsn)
        if err != nil </span><span class="cov8" title="1">{
                return msservice, err
        }</span>
        <span class="cov8" title="1">defer db.Close()

        // dsn should have been registered successfully when sql.Open
        msservice.msk = mysql.MSKeeperInstance(dsn)
        msservice.msk.Flush()
        msservice.msk.ClearStatus() // 单元的时候应为dsn唯一，为了防止单元相互影响，初始化一下。

        // ignore exists
        _ = os.Mkdir("./logs", os.ModePerm)

        msservice.msk.SetOptions(
                options.WithSwitch(false), // 异步check队列关闭
                options.WithMaxExecTime(5*time.Second),
                options.WithNotifier(notifier.NewNotifierMux(
                        notifier.NewNotifierLog(fmt.Sprintf("./logs/mskeeper_%v.log", msid)).SetLogLevel(notifier.InfoLevel),
                        notifier.NewDefaultNotifier().SetLogLevel(notifier.WarnLevel))),
                options.WithLogOutput(os.Stdout),
                options.WithLogLevel(notifier.WarnLevel),       // 设置mskeeper自身的日志级别
                options.WithSQLWhiteLists("SELECT version();"), // skip the sql that used by mskeeper itself
                options.WithMaxSilentPeriod(1*time.Second),     // restfulapi 暂时只需要瞬时排重
                options.WithSQLCacheSize(0),
        )

        _ = msservice.msk.AttachPolicy(policy.NewPolicyCheckerRowsAbsolute(10000))
        _ = msservice.msk.AttachPolicy(policy.NewPolicyCheckerRowsInvolved())
        _ = msservice.msk.AttachPolicy(policy.NewPolicyCheckerFieldsType())
        _ = msservice.msk.AttachPolicy(policy.NewPolicyCheckerFieldsLength())

        _ = addMSKSession(msid, msservice)

        return msservice, nil</span>
}

func (this *MySQLService) RunSQL(req ServiceRunSQLRequest, res *ServiceRunSQLResponse) (reterr error) <span class="cov8" title="1">{
        stmt, err := sqlparser.Parse(req.SQL)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLService:RunSQL(%v, %v) sqlparser.Parse failed with err %v",
                        req, res, err)
                reterr = err
                return
        }</span>
        <span class="cov8" title="1">if req.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                req.Timeout = MaxPingTimeout
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(req.Timeout*float64(time.Microsecond)))
        defer cancel()
        res.Notifies = []policy.PolicyError{}
        if req.Duration &gt; 0 </span><span class="cov8" title="1">{
                this.GetMSKeeper().SetOption(options.WithMaxExecTime(time.Duration(req.Duration) * time.Millisecond))
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                chkReq := ServiceCheckSQLRequest{
                        SQL:  req.SQL,
                        MSID: req.MSID,
                        Args: req.Args,
                }
                chkRes := &amp;ServiceCheckSQLResponse{Request: chkReq}
                err := this.CheckSQL(chkReq, chkRes)
                if err != nil </span><span class="cov8" title="1">{
                        log.MSKLog().Infof("MySQLService:RunSQL(%v, %v) CheckSQL(%v, %v) failed with err %v",
                                req, res, chkReq, chkRes, err)
                        return
                }</span>

                <span class="cov8" title="1">res.Notifies = chkRes.Notifies</span>
        }()
        <span class="cov8" title="1">switch stmt.(type) </span>{
        case *sqlparser.Select, *sqlparser.OtherRead, *sqlparser.Show:<span class="cov8" title="1">
                res.Result.RowsAffected = 0

                // select with result
                // nargs, _ := mysql.Converter{}.ConvertValues(req.Args)
                rows, err := this.msk.RawDB().QueryContext(ctx, req.SQL, req.Args...)
                if err != nil </span><span class="cov8" title="1">{
                        log.MSKLog().Errorf("MySQLService:RunSQL(%v, %v) Query failed with err %v",
                                req, res, err)
                        reterr = err
                        return
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                columnNames, _ := rows.Columns()
                res.Result.Columns = make([]RunColumn, len(columnNames))
                tt, _ := rows.ColumnTypes()
                types := make([]reflect.Type, len(columnNames))
                for i, tp := range tt </span><span class="cov8" title="1">{
                        types[i] = tp.ScanType()
                        res.Result.Columns[i] = RunColumn{Name: tp.Name(), DataType: tp.DatabaseTypeName()}
                }</span>
                <span class="cov8" title="1">columns := make([]interface{}, len(columnNames))
                for i := range columns </span><span class="cov8" title="1">{
                        columns[i] = reflect.New(types[i]).Interface()
                }</span>
                // syslog.Printf("columnNames %v", columnNames)

                <span class="cov8" title="1">res.Result.Rows = make([][]interface{}, 0)
                for rows.Next() </span><span class="cov8" title="1">{

                        err := rows.Scan(columns...)
                        if err != nil </span><span class="cov8" title="1">{
                                log.MSKLog().Errorf("MySQLService:RunSQL(%v, %v) rows.Scan with err %v",
                                        req, res, err)
                                reterr = err
                                return
                        }</span>
                        <span class="cov8" title="1">var row []interface{} = make([]interface{}, 0)
                        for _, columnValue := range columns </span><span class="cov8" title="1">{
                                value, _ := mysql.Converter{}.ConvertValue(columnValue)
                                // []byte to string
                                if reflect.ValueOf(columnValue).Elem().Kind() == reflect.Slice </span><span class="cov8" title="1">{
                                        row = append(row, string(value.([]byte)))
                                }</span> else<span class="cov8" title="1"> {
                                        row = append(row, value)
                                }</span>
                        }
                        // syslog.Printf("row %v ", row)
                        <span class="cov8" title="1">res.Result.Rows = append(res.Result.Rows, row)</span>
                }
                <span class="cov8" title="1">return rows.Err()</span>

        case *sqlparser.Begin, *sqlparser.Rollback, *sqlparser.Commit:<span class="cov8" title="1">
                // not support
                err := ErrStatementNotSupported
                log.MSKLog().Warnf("MySQLService:RunSQL(%v, %v) statement not supported",
                        req, res)
                reterr = err
                return</span>
        default:<span class="cov8" title="1">
                // execute sql
                result, err := this.msk.RawDB().ExecContext(ctx, req.SQL, req.Args...)
                if err != nil </span><span class="cov8" title="1">{
                        log.MSKLog().Errorf("MySQLService:RunSQL(%v, %v) Execute failed with err %v",
                                req, res, err)
                        reterr = err
                        return
                }</span>
                <span class="cov8" title="1">ra, _ := result.RowsAffected()
                res.Result.RowsAffected = ra</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (this *MySQLService) CheckSQL(req ServiceCheckSQLRequest, res *ServiceCheckSQLResponse) error <span class="cov8" title="1">{

        res.Notifies = []policy.PolicyError{}
        rawerrors := []error{}
        nargs, _ := mysql.Converter{}.ConvertValues(req.Args)
        err := this.msk.SyncProcess(
                time.Now(), req.SQL, nargs, &amp;rawerrors)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Infof("MySQLService:CheckSQL(%v, %v) failed %v",
                        req, res, err)
                return err
        }</span>
        <span class="cov8" title="1">for _, rawerror := range rawerrors </span><span class="cov8" title="1">{
                pe, _ := rawerror.(*policy.PolicyError)
                res.Notifies = append(res.Notifies, *pe)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (this *MySQLService) PingDB(req ServicePingDBRequest, res *ServicePingDBResponse) error <span class="cov8" title="1">{

        if req.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                req.Timeout = MaxPingTimeout
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(req.Timeout*float64(time.Microsecond)))
        defer cancel()
        err := this.msk.RawDB().PingContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                log.MSKLog().Errorf("MySQLService:PingDB(%v, %v): failed(%v) to ping MySQL instance",
                        req, res, err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (this *MySQLService) GetUUID() string <span class="cov8" title="1">{
        return this.msid
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package service

import (
        "errors"
        lru "github.com/hashicorp/golang-lru"
        mskdriver "gitlab.papegames.com/fringe/mskeeper/driver"
        logmsk "gitlab.papegames.com/fringe/mskeeper/log"
        "gitlab.papegames.com/fringe/mskeeper/policy"
)

const (
        MaxSessionClient = 100     // 一个msk server实例最大的msk instance数 by dsn
        MaxPingTimeout   = 5000000 // DB连接最大的超时时间，unit: microsec
)

var (
        ErrSessionNotExists      = errors.New("MSKeeper session not exists")
        ErrStatementNotSupported = errors.New("MSKeeper sql statement not supported")
)

var (
        sessionmap *lru.Cache
)

func Init(langPath string, maxClient ...interface{}) error <span class="cov8" title="1">{
        var err error

        uplimit := MaxSessionClient
        // Parse uplimit
        for i := 0; i &lt; len(maxClient); i++ </span><span class="cov8" title="1">{
                u, ok := maxClient[i].(int)
                if ok </span><span class="cov8" title="1">{
                        uplimit = u
                        break</span>
                }
        }

        <span class="cov8" title="1">sessionmap, err = lru.New(uplimit)
        if err != nil </span><span class="cov8" title="1">{
                logmsk.MSKLog().Errorf("sessionmap init failed (%v)\n", err)
                return err
        }</span>
        <span class="cov8" title="1">if err := initLocales(langPath); err != nil </span><span class="cov8" title="1">{
                logmsk.MSKLog().Errorf("Locales failed (%v)\n", err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func GetMSKSession(uuid string) (Servicer, error) <span class="cov8" title="1">{
        session, ok := sessionmap.Get(uuid)
        if !ok </span><span class="cov8" title="1">{
                return nil, ErrSessionNotExists
        }</span>
        <span class="cov8" title="1">return session.(Servicer), nil</span>
}

func addMSKSession(uuid string, sess Servicer) error <span class="cov8" title="1">{
        sessionmap.Add(uuid, sess)
        return nil
}</span>

type Servicer interface {
        CheckSQL(req ServiceCheckSQLRequest, res *ServiceCheckSQLResponse) error
        RunSQL(req ServiceRunSQLRequest, res *ServiceRunSQLResponse) error
        PingDB(req ServicePingDBRequest, res *ServicePingDBResponse) error
        GetUUID() string
        GetMSKeeper() *mskdriver.MSKeeper
}

type ServiceCheckSQLRequest struct {
        MSID string        `json:"msid"`
        SQL  string        `json:"sql"`
        Args []interface{} `json:"args,omitempty"`
}

type ServiceCheckSQLResponse struct {
        Request  ServiceCheckSQLRequest `json:"request,omitempty"`
        Notifies []policy.PolicyError   `json:"notifies,omitempty"`
}

type ServiceRunSQLRequest struct {
        MSID     string        `json:"msid"`
        SQL      string        `json:"sql"`
        Duration int64         `json:"duration"` // milliseconds
        Args     []interface{} `json:"args,omitempty"`
        Timeout  float64       `json:"timeout"`
}

type RunColumn struct {
        Name     string `json:"name"`
        DataType string `json:"type"`
}

type ServiceRunSQLResponse struct {
        Request ServiceRunSQLRequest `json:"request,omitempty"`
        Result  struct {
                Columns      []RunColumn     `json:"columns,omitempty"`
                Rows         [][]interface{} `json:"rows,omitempty"`
                RowsAffected int64           `json:"rows_affected"`
        }
        Notifies []policy.PolicyError `json:"notifies,omitempty"`
        MSID     string               `json:"msid"`
        SQL      string               `json:"sql"`
        Duration int64                `json:"duration"` // milliseconds
        Args     []interface{}        `json:"args"`
}

type ServicePingDBRequest struct {
        Timeout float64 `json:"timeout"` // milliseconds
}

type ServicePingDBResponse struct {
        Request ServicePingDBRequest `json:"request,omitempty"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
